const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let width, height;
let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2, down: false };
let frame = 0;

// --- GLOBAL SCALING ---
const G_SCALE = 0.5; 

// --- THEME & RARITY ---
const COLORS = {
    bone: "#001a4d", accent: "#0066ff", glow: "#00ffff", laser: "#ccf2ff",
    plasma: "#ff00ff", enemyProj: "#ff3333", shield: "rgba(0, 255, 255, 0.3)",
    shockwave: "rgba(255, 255, 0, 0.4)", bossBar: "#ff0000", fury: "#ff3300",
    cursed: "#800080",
    common: "#b0b0b0", rare: "#0088ff", epic: "#9900ff", legendary: "#ffaa00", mythic: "#00ffcc"
};

// --- GAME STATE ---
let dragonHP = 18000; 
let dragonMaxHP = 18000;
let dragonShield = 0;
let dragonMaxShield = 0;
let dragonShieldRegen = 0; 
let shieldCooldown = 0;

// --- CAPS & CONFIG ---
const CAP_DEF = 0.50;  
const CAP_DODGE = 0.60; // Increased cap for Ghost builds
const CAP_CRIT_DMG = 5.0; 
const CAP_CRIT_CHANCE = 1.0;

const MAX_LASER_MAIN = 12;
const MAX_LASER_SIDE = 8;
const MAX_LASER_REAR = 6;

// --- STATS ---
let dragonDefPct = 0; 
let dragonAtk = 1;
let dragonRegen = 0.2; 
let xpMultiplier = 1.0;
let lifeSteal = 0; 
let dodgeChance = 0; 
let globalSlow = 1.0;
let tailDmgMult = 1.0;
let critChance = 0.05;
let critDmg = 1.5;     
let thornsDmg = 0;
let knockbackStr = 1.0;
let executeThreshold = 0; 
let dmgTakenMult = 1.0;
let laserDmgMult = 1.0; 
let fireRateMult = 1.0; 

// --- SPECIAL MECHANICS ---
let unlockedShield = false;
let unlockedFury = false;
let unlockedOrbs = false;
let unlockedMissiles = false;
let unlockedMines = false;
let unlockedStatic = false; 

// Ghost Tree
let unlockedGhost = false;
let ghostActive = false; // Always true if unlocked, or toggle? Let's make it a passive form.
let ghostDmg = 0; // Poltergeist damage
let ghostPhaseShift = false; // Teleport on hit

// Fury Tree
let furyEnabled = false;
let furyMeter = 0;
let furyActive = false;
let furyTimer = 0;
let furyDuration = 600;
let furyExplosion = false; // Hellfire upgrade
let furyInvuln = false;    // Undying Rage upgrade

// Utils
let autoTurretCount = 0;
let magnetRange = 1.0;
let hasBloodLust = false; 
let reviveCount = 0;
let timeStopChance = 0;
let timeStopActive = false;
let timeStopTimer = 0;
let chainLightningChance = 0;
let poisonDmg = 0;
let burnDmg = 0;
let missileCount = 0;
let mineTimer = 0;
let auraFireDmg = 0;
let auraIceSlow = 0;
let summonDrakeCount = 0;
let ricochetCount = 0;
let fearChance = 0;
let webbedTimer = 0;

// Shield Specials
let shieldExplode = false; 
let shieldAmpDmg = false; 
let shieldAmpFire = false; 
let shieldStunBreak = false;

let tailTurret = false; 
let discoMode = false;
let gamblerMode = false;
let gamblerTimer = 0;

// Shockwave
let shockwaveEnabled = false;
let shockwaveTimer = 0;
let shockwaveInterval = 180;
let shockwaveRange = 300 * G_SCALE;
let shockwaveDmg = 50;
let shockwaveActiveFrame = 0;

// Progression
let level = 1;
let exp = 0;
let expNext = 800;
let wave = 0;
let score = 0;
let gameActive = true;
let isPaused = false;
let canReroll = false; 

// Weapons
let laserCount = 1;
let laserWidthBase = 1;
let laserRear = 0;
let laserSide = 0;
let laserType = 'normal'; 
let orbLevel = 0;
let orbStats = { speed: 8 * G_SCALE, size: 10 * G_SCALE, pen: 1, damageMult: 1, count: 1 };
let reactorDmg = 0; 
let reactorRadiusMult = 1.0;

// Entities
let enemies = [];
let projectiles = [];
let enemyProjectiles = [];
let gems = [];
let upgradeChoices = [];
let cardBounds = [];
let damageNumbers = [];
let summons = [];
let lightningEffects = [];
let myUpgrades = []; 

// --- DRAGON SPECS ---
let VISUAL_SCALE = 0.6 * G_SCALE;
const CONFIG = {
    segmentCount: 85,
    segmentDist: 8 * VISUAL_SCALE, 
    headSpeed: 0.015, 
    maxRibWidth: 42 * VISUAL_SCALE, 
    legSpeed: 0.05,
    upperLegLen: 75 * VISUAL_SCALE, 
    lowerLegLen: 85 * VISUAL_SCALE, 
    wingSpan: 340 * VISUAL_SCALE,   
    wingFlapSpeed: 0.03,
    wingAttachment: 18
};
let spine = [];
let legs = [];

// --- HELPER FUNCTIONS ---
function healPct(pct) {
    let amt = dragonMaxHP * pct;
    dragonHP = Math.min(dragonMaxHP, dragonHP + amt);
    damageNumbers.push(new FloatingText(spine[0].x, spine[0].y, "+" + Math.floor(amt), "#0f0", 25));
}
function addMaxHP(pct) {
    let oldMax = dragonMaxHP;
    dragonMaxHP *= (1 + pct);
    dragonHP += (dragonMaxHP - oldMax);
}
function romanize(num) {
    if (num === 1) return "I"; if (num === 2) return "II";
    if (num === 3) return "III"; if (num === 4) return "IV"; 
    if (num === 5) return "V"; return "X";
}

// --- UPGRADES DATABASE ---
const UPGRADES = [
    // --- COMMON (Tier 1) ---
    { r: 0, type: 'def', name: "Thick Skin", desc: "Max Health +10%", run: () => addMaxHP(0.1) },
    { r: 0, type: 'def', name: "Regen Cell", desc: "Regen +1 HP/frame", run: () => dragonRegen += 1 },
    { r: 0, type: 'def', name: "Hard Scales", desc: "Defense +5% (Max 50%)", run: () => dragonDefPct = Math.min(CAP_DEF, dragonDefPct + 0.05) },
    { r: 0, type: 'def', name: "Spikes", desc: "Enemies take 20 DMG on touch", run: () => thornsDmg += 20 },
    { r: 0, type: 'wep', name: "Extra Barrel", desc: "+1 Main Beam (-10% Dmg)", req: () => laserCount < MAX_LASER_MAIN, run: () => { laserCount++; laserDmgMult *= 0.90; } },
    { r: 0, type: 'wep', name: "Focus Lens", desc: "Beams are 10% wider", run: () => laserWidthBase += 0.1 },
    { r: 0, type: 'wep', name: "Sharpen", desc: "Attack Damage +10%", run: () => dragonAtk += 0.1 },
    { r: 0, type: 'util', name: "Magnetism", desc: "Pickup Range +25%", run: () => magnetRange *= 1.25 },
    { r: 0, type: 'util', name: "Learning", desc: "XP Gain +10%", run: () => xpMultiplier += 0.1 },
    { r: 0, type: 'wep', name: "Rear Shot", desc: "Add Rear Laser (-5% Dmg)", req: () => laserRear < MAX_LASER_REAR, run: () => { laserRear++; laserDmgMult *= 0.95; } },
    { r: 0, type: 'wep', name: "Side Cannons", desc: "Add Side Lasers (-5% Dmg)", req: () => laserSide < MAX_LASER_SIDE, run: () => { laserSide++; laserDmgMult *= 0.95; } },
    { r: 0, type: 'util', name: "Agility", desc: "Move Speed +5%", run: () => CONFIG.headSpeed *= 1.05 },
    { r: 0, type: 'wep', name: "Sniper", desc: "Crit Chance +5%", run: () => critChance = Math.min(CAP_CRIT_CHANCE, critChance + 0.05) },
    
    // --- RARE (Tier 2) ---
    { r: 1, type: 'def', name: "Reinforced Plating", desc: "Max HP +25%", run: () => addMaxHP(0.25) },
    { r: 1, type: 'def', name: "Shield Generator", desc: "Unlock 500 Shield", req: () => !unlockedShield, run: () => { unlockedShield = true; dragonMaxShield += 500; dragonShieldRegen += 2; } },
    { r: 1, type: 'def', name: "Shield Battery", desc: "Shield +500", req: () => unlockedShield, run: () => { dragonMaxShield += 500; dragonShieldRegen += 2; } },
    { r: 1, type: 'def', name: "Amp Shield", desc: "+20% DMG while Shielded", req: () => unlockedShield, run: () => shieldAmpDmg = true },
    { r: 1, type: 'wep', name: "Dual Beam", desc: "+1 Beam, +10% DMG", req: () => laserCount < MAX_LASER_MAIN, run: () => { laserCount++; dragonAtk += 0.1; } },
    { r: 1, type: 'wep', name: "Tail Mastery", desc: "Tail DMG x3", run: () => tailDmgMult += 3 },
    
    // ORB WEAPON TREE
    { r: 1, type: 'wep', name: "Orbiter", desc: "Unlock Projectile Weapon", req: () => !unlockedOrbs, run: () => { unlockedOrbs = true; orbLevel++; orbStats.count++; } },
    { r: 1, type: 'wep', name: "Orb Upgrade", desc: "+1 Orb, +Speed", req: () => unlockedOrbs, run: () => { orbLevel++; orbStats.count++; orbStats.speed += 2; } },
    { r: 2, type: 'wep', name: "Ricochet", desc: "Orbs bounce +1 times", req: () => unlockedOrbs, run: () => ricochetCount++ },
    { r: 3, type: 'wep', name: "Orbital Cannon", desc: "Massive Orbs, High Dmg", req: () => unlockedOrbs, run: () => { orbStats.size *= 2; orbStats.damageMult *= 1.5; } },

    { r: 1, type: 'util', name: "Greed", desc: "XP +30%", run: () => xpMultiplier += 0.3 },
    
    // TURRET TREE
    { r: 1, type: 'wep', name: "Auto Turret", desc: "Unlock Auto Turret", req: () => autoTurretCount === 0, run: () => autoTurretCount++ },
    { r: 1, type: 'wep', name: "Twin Turrets", desc: "+1 Turret", req: () => autoTurretCount > 0, run: () => autoTurretCount++ },
    { r: 2, type: 'wep', name: "Overclock", desc: "Turrets Fire 2x Faster", req: () => autoTurretCount > 0, run: () => { /* Logic handled in draw/update */ autoTurretCount += 0.5; } }, // Hacky way to boost power without adding visual lines

    { r: 1, type: 'wep', name: "Crit Master", desc: "Crit Dmg +50%", run: () => critDmg = Math.min(CAP_CRIT_DMG, critDmg + 0.5) },
    { r: 1, type: 'def', name: "Dodge Roll", desc: "Dodge +10%", run: () => dodgeChance = Math.min(CAP_DODGE, dodgeChance + 0.1) },
    { r: 1, type: 'wep', name: "Reactor", desc: "Burn nearby enemies", run: () => reactorDmg += 40 },
    { r: 1, type: 'wep', name: "Frost Aura", desc: "Slow nearby enemies", run: () => auraIceSlow = Math.min(0.5, auraIceSlow + 0.1) },
    
    // --- EPIC (Tier 3) ---
    // FURY TREE
    { r: 2, type: 'abil', name: "Draconic Fury", desc: "Unlock FURY bar", req: () => !unlockedFury, run: () => { unlockedFury = true; furyEnabled = true; } },
    { r: 2, type: 'abil', name: "Rage Fuel", desc: "Fury lasts +5s", req: () => unlockedFury, run: () => furyDuration += 300 },
    { r: 2, type: 'abil', name: "Hellfire", desc: "Fury Activation Explodes", req: () => unlockedFury && !furyExplosion, run: () => furyExplosion = true },
    { r: 3, type: 'abil', name: "Undying Rage", desc: "Invincible during Fury", req: () => unlockedFury && !furyInvuln, run: () => furyInvuln = true },

    // GHOST TREE
    { r: 2, type: 'abil', name: "Spectral Form", desc: "Unlock Ghost Form (+15% Dodge)", req: () => !unlockedGhost, run: () => { unlockedGhost = true; ghostActive = true; dodgeChance += 0.15; } },
    { r: 2, type: 'abil', name: "Poltergeist", desc: "Damage enemies you pass through", req: () => unlockedGhost, run: () => ghostDmg += 50 },
    { r: 3, type: 'abil', name: "Phase Shift", desc: "Teleport away when hit", req: () => unlockedGhost && !ghostPhaseShift, run: () => ghostPhaseShift = true },

    { r: 2, type: 'wep', name: "Missile Silo", desc: "Unlock Homing Missiles", req: () => !unlockedMissiles, run: () => { unlockedMissiles = true; missileCount++; } },
    { r: 2, type: 'wep', name: "Heavy Payload", desc: "+1 Missile", req: () => unlockedMissiles, run: () => missileCount++ },

    { r: 2, type: 'def', name: "Second Heart", desc: "+1 Revive", run: () => reviveCount++ },
    { r: 2, type: 'wep', name: "Plasma Beam", desc: "Lasers Pierce 50% Def", run: () => laserType = 'plasma' },
    { r: 2, type: 'wep', name: "Tesla Coil", desc: "15% Chance to Chain Zap", run: () => chainLightningChance = Math.min(0.8, chainLightningChance + 0.15) },
    { r: 2, type: 'wep', name: "Executioner", desc: "Kill enemies <10% HP", run: () => executeThreshold = 0.1 },
    { r: 2, type: 'wep', name: "Giga Blast", desc: "Laser Size +50%", run: () => laserWidthBase += 0.5 },
    { r: 2, type: 'util', name: "Chronos", desc: "Enemies -15% Speed", run: () => globalSlow *= 0.85 },
    { r: 2, type: 'sum', name: "Mini Drake", desc: "Summon Ally Dragon", run: () => { summonDrakeCount++; summons.push(new SummonDrake(summonDrakeCount)); } },
    { r: 2, type: 'wep', name: "Vampiric Touch", desc: "Crit Heals +2 HP", run: () => lifeSteal += 2 },
    { r: 2, type: 'wep', name: "Mine Layer", desc: "Drop Mines", req: () => !unlockedMines, run: () => { unlockedMines = true; } },
    { r: 2, type: 'def', name: "Overload", desc: "Shield Break Explosion", req: () => unlockedShield && !shieldExplode, run: () => { shieldExplode = true; } },
    { r: 2, type: 'def', name: "Aegis", desc: "Shielded = +15% Fire Rate", req: () => unlockedShield, run: () => shieldAmpFire = true },
    { r: 2, type: 'wep', name: "Tail Turret", desc: "Tail shoots lasers", req: () => !tailTurret, run: () => { tailTurret = true; } },

    // --- CRAZY / FUN UPGRADES ---
    { r: 3, type: 'util', name: "Size Matters", desc: "Size +30%, HP x2, Speed -10%", run: () => { VISUAL_SCALE *= 1.3; updateDragonSize(); addMaxHP(1.0); CONFIG.headSpeed *= 0.9; } },
    { r: 3, type: 'wep', name: "Disco Inferno", desc: "Lasers do Random Status FX", req: () => !discoMode, run: () => { discoMode = true; } },
    { r: 3, type: 'util', name: "Bullet Time", desc: "Global Slow 20%", run: () => { globalSlow *= 0.8; } },
    { r: 3, type: 'util', name: "Gambler", desc: "Randomize ATK every 10s", req: () => !gamblerMode, run: () => { gamblerMode = true; } },
    { r: 3, type: 'wep', name: "Machine Gun", desc: "Fire Rate x2, Dmg -20%", run: () => { dragonAtk *= 0.8; fireRateMult *= 2.0; laserDmgMult *= 1.25; }},

    // --- LEGENDARY (Tier 4) ---
    { r: 3, type: 'wep', name: "Void Cannon", desc: "% Max HP Dmg", run: () => laserType = 'void' },
    { r: 3, type: 'util', name: "Time Stop", desc: "5% Chance to Freeze Time", run: () => timeStopChance += 0.05 },
    { r: 3, type: 'def', name: "Titan Scales", desc: "Cap Armor 50% & +10% Def", run: () => dragonDefPct = Math.min(CAP_DEF, dragonDefPct + 0.1) },
    { r: 3, type: 'wep', name: "Armageddon", desc: "Projectiles Explode", req: () => unlockedOrbs, run: () => orbStats.damageMult *= 1.5 },
    { r: 3, type: 'def', name: "Phoenix Soul", desc: "+3 Revives", run: () => reviveCount += 3 },
    { r: 3, type: 'abil', name: "Perma-Fury", desc: "Fury charges 2x faster", req: () => unlockedFury, run: () => furyDuration -= 100 },
    { r: 3, type: 'def', name: "Flash Shield", desc: "Shield break Stuns", req: () => unlockedShield, run: () => shieldStunBreak = true },

    // --- MYTHIC (Tier 5) ---
    { r: 5, type: 'god', name: "God Mode", desc: "All Stats +50%", run: () => { dragonAtk*=1.5; addMaxHP(0.5); dragonDefPct+=0.1; } },
    { r: 5, type: 'god', name: "Evolution", desc: "Grow larger, HP x2", run: () => { VISUAL_SCALE *= 1.2; updateDragonSize(); addMaxHP(1.0); } },
    { r: 5, type: 'god', name: "Black Hole Sun", desc: "Reactor pulls strong", run: () => reactorRadiusMult *= 2 },

    // --- CURSED ---
    { r: 4, type: 'cursed', name: "Blood Contract", desc: "DMG +100%, Max HP -40%", run: () => { dragonAtk += 1.0; dragonMaxHP *= 0.6; dragonHP = Math.min(dragonHP, dragonMaxHP); } },
    { r: 4, type: 'cursed', name: "Glass Cannon", desc: "DMG +200%, Take +50% DMG", run: () => { dragonAtk += 2.0; dmgTakenMult += 0.5; } },
    { r: 4, type: 'cursed', name: "Death Wish", desc: "XP +200%, Enemies HP x2", run: () => { xpMultiplier += 2.0; } },
    { r: 4, type: 'cursed', name: "Berserk", desc: "Infinite Fury, No Regen", req: () => unlockedFury, run: () => { furyActive = true; furyDuration = 999999; dragonRegen = -10; } }
];

// Procedural Upgrades
const STAT_TYPES = [
    { name: "Vitality", stat: () => addMaxHP(0.15), desc: "HP +15%", type: 'def' },
    { name: "Strength", stat: () => dragonAtk += 0.15, desc: "ATK +15%", type: 'wep' },
    { name: "Haste", stat: () => CONFIG.headSpeed *= 1.1, desc: "Speed +10%", type: 'util' },
    { name: "Fortitude", stat: () => dragonDefPct = Math.min(CAP_DEF, dragonDefPct + 0.03), desc: "Def +3%", type: 'def' }
];
for (let i = 0; i < 40; i++) {
    let t = STAT_TYPES[i % STAT_TYPES.length];
    UPGRADES.push({ 
        r: 0, 
        type: t.type, 
        name: `${t.name} ${romanize(Math.floor(i/4)+1)}`, 
        desc: t.desc, 
        run: t.stat 
    });
}

function updateDragonSize() {
    CONFIG.segmentDist = 8 * VISUAL_SCALE;
    CONFIG.maxRibWidth = 42 * VISUAL_SCALE;
    CONFIG.upperLegLen = 75 * VISUAL_SCALE;
    CONFIG.lowerLegLen = 85 * VISUAL_SCALE;
    CONFIG.wingSpan = 340 * VISUAL_SCALE;
}

// --- CLASSES ---
class FloatingText {
    constructor(x, y, text, color, size) {
        this.x = x + (Math.random()-0.5)*20;
        this.y = y;
        this.text = text; this.color = color; this.life = 60;
        this.size = size; this.vy = -1;
    }
    update() { this.y += this.vy; this.life--; return this.life > 0; }
    draw() {
        ctx.globalAlpha = Math.max(0, this.life / 20);
        ctx.fillStyle = this.color; ctx.font = `bold ${this.size}px monospace`;
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1.0;
    }
}

class LightningEffect {
    constructor(x1, y1, x2, y2) {
        this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2;
        this.life = 10; 
    }
    update() { this.life--; return this.life > 0; }
    draw() {
        ctx.save();
        ctx.globalAlpha = this.life / 10;
        ctx.strokeStyle = "#00ffff";
        ctx.lineWidth = 3;
        ctx.shadowBlur = 10; ctx.shadowColor = "cyan";
        ctx.beginPath();
        ctx.moveTo(this.x1, this.y1);
        let midX = (this.x1 + this.x2) / 2 + (Math.random()-0.5) * 50;
        let midY = (this.y1 + this.y2) / 2 + (Math.random()-0.5) * 50;
        ctx.lineTo(midX, midY);
        ctx.lineTo(this.x2, this.y2);
        ctx.stroke();
        ctx.restore();
    }
}

class ExpGem {
    constructor(x, y, val) { this.x = x; this.y = y; this.val = val; }
    update() {
        const head = spine[0];
        const d = Math.hypot(head.x - this.x, head.y - this.y);
        if (d < 400 * G_SCALE * magnetRange) { 
            const a = Math.atan2(head.y - this.y, head.x - this.x);
            this.x += Math.cos(a) * (25 * G_SCALE); this.y += Math.sin(a) * (25 * G_SCALE);
        }
        if (d < 60 * G_SCALE) {
            exp += this.val * xpMultiplier;
            if (furyEnabled && !furyActive) furyMeter = Math.min(100, furyMeter + 0.3);
            if (exp >= expNext) levelUp();
            return true;
        }
        return false;
    }
    draw() {
        ctx.fillStyle = COLORS.glow; ctx.shadowBlur = 10;
        ctx.shadowColor = COLORS.glow;
        ctx.beginPath(); ctx.arc(this.x, this.y, 6 * G_SCALE, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
    }
}

class SummonDrake {
    constructor(id) {
        this.x = spine[0].x;
        this.y = spine[0].y;
        this.angle = 0; this.target = null;
        this.attackCooldown = 0;
        this.id = id;
    }
    update() {
        let head = spine[0];
        if (!this.target || this.target.hp <= 0) {
            this.target = null;
            let minD = 800; 
            enemies.forEach(e => {
                let d = Math.hypot(e.x - this.x, e.y - this.y);
                if (d < minD) { minD = d; this.target = e; }
            });
        }
        if (this.target) {
            let dx = this.target.x - this.x, dy = this.target.y - this.y;
            let dist = Math.hypot(dx, dy);
            let ang = Math.atan2(dy, dx);
            this.angle = ang;
            this.x += Math.cos(ang) * 7; 
            this.y += Math.sin(ang) * 7;
            if (this.attackCooldown > 0) this.attackCooldown--;
            if (dist < 150 && this.attackCooldown <= 0) {
                this.target.takeDamage(20 * dragonAtk);
                this.attackCooldown = 30;
                ctx.strokeStyle = "lime"; ctx.lineWidth = 2; 
                ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.target.x, this.target.y); ctx.stroke();
            }
        } else {
            let time = frame * 0.05 + (this.id * 2);
            let tx = head.x + Math.cos(time) * 150 * VISUAL_SCALE;
            let ty = head.y + Math.sin(time) * 150 * VISUAL_SCALE;
            this.x += (tx - this.x) * 0.1;
            this.y += (ty - this.y) * 0.1;
            this.angle = Math.atan2(ty - this.y, tx - this.x);
        }
    }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = "#0f0"; 
        ctx.beginPath(); ctx.moveTo(15,0); ctx.lineTo(-10, 8); ctx.lineTo(-5, 0); ctx.lineTo(-10,-8); ctx.fill();
        ctx.restore();
    }
}

class Missile {
    constructor(x, y) {
        this.x = x;
        this.y = y; this.life = 120;
        this.target = enemies.length > 0 ? enemies[Math.floor(Math.random()*enemies.length)] : null;
        this.vx = (Math.random()-0.5)*10;
        this.vy = (Math.random()-0.5)*10;
    }
    update() {
        this.life--;
        if (this.target && this.target.hp > 0) {
            let a = Math.atan2(this.target.y - this.y, this.target.x - this.x);
            this.vx += Math.cos(a) * 1.5; this.vy += Math.sin(a) * 1.5;
            this.vx *= 0.9; this.vy *= 0.9;
        }
        this.x += this.vx; this.y += this.vy;
        for (let e of enemies) {
            if (Math.hypot(e.x - this.x, e.y - this.y) < e.radius + 10) {
                e.takeDamage(100 * dragonAtk);
                ctx.fillStyle = "orange"; ctx.beginPath(); ctx.arc(this.x, this.y, 50, 0, Math.PI*2); ctx.fill();
                return true;
            }
        }
        return this.life <= 0;
    }
    draw() {
        ctx.fillStyle = "yellow"; ctx.fillRect(this.x-2, this.y-2, 4, 4);
        ctx.strokeStyle = "orange"; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x-this.vx*2, this.y-this.vy*2); ctx.stroke();
    }
}

class Mine {
    constructor(x, y) { this.x = x; this.y = y; this.timer = 600; }
    update() {
        this.timer--;
        for (let e of enemies) {
            if (Math.hypot(e.x - this.x, e.y - this.y) < e.radius + 60) { 
                e.takeDamage(200 * dragonAtk);
                ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(this.x, this.y, 120, 0, Math.PI*2); ctx.fill();
                enemies.forEach(subE => {
                    if (Math.hypot(subE.x - this.x, subE.y - this.y) < 120) {
                        subE.takeDamage(200 * dragonAtk);
                    }
                });
                return true; 
            }
        }
        ctx.fillStyle = (frame%20<10)?"red":"#500";
        ctx.beginPath();
        ctx.arc(this.x, this.y, 10, 0, Math.PI*2); ctx.fill();
        return this.timer <= 0;
    }
    draw() {}
}

class EnemyProjectile {
    constructor(x, y, angle, type = 'normal') {
        this.x = x; this.y = y;
        this.vx = Math.cos(angle) * (6 * G_SCALE); 
        this.vy = Math.sin(angle) * (6 * G_SCALE);
        this.radius = 8 * G_SCALE; this.type = type;
        this.dmg = 30;
        
        if(type === 'sniper') { this.dmg = 100; this.vx *= 1.5; this.vy *= 1.5; }
        if(type === 'boss') { this.radius = 20 * G_SCALE; this.dmg = 150; }
        if(type === 'web') { this.radius = 12 * G_SCALE; this.dmg = 20; }
        if(type === 'titan') { this.radius = 50 * G_SCALE; this.dmg = 300; }
        if(type === 'spawner') { this.radius = 15 * G_SCALE; this.dmg = 0; } 
    }
    update() {
        if (timeStopActive) return false;
        this.x += this.vx * globalSlow; this.y += this.vy * globalSlow;
        const head = spine[0];
        const center = spine[Math.floor(spine.length/2)];
        const hitHead = Math.hypot(this.x - head.x, this.y - head.y) < (40 * VISUAL_SCALE);
        const hitBody = Math.hypot(this.x - center.x, this.y - center.y) < (50 * VISUAL_SCALE);
        
        if (this.type === 'spawner' && frame % 5 === 0 && Math.random() < 0.05) {
             let e = new Enemy('swarmer', wave);
             e.x = this.x; e.y = this.y; enemies.push(e);
             return true;
        }

        if (hitHead || hitBody) {
            if (this.type === 'spawner') {
                let e = new Enemy('brute', wave); e.x = this.x; e.y = this.y; enemies.push(e);
                return true;
            }
            takeDamage(this.dmg);
            if(this.type === 'web') webbedTimer = 120; 
            return true; 
        }
        return (this.x < -200 || this.x > width+200 || this.y < -200 || this.y > height+200);
    }
    draw() {
        ctx.fillStyle = this.type === 'boss' ? "#ff00ff" : "#ff3300"; 
        if(this.type === 'web') ctx.fillStyle = "#fff";
        if(this.type === 'titan') ctx.fillStyle = "#ffff00";
        if(this.type === 'spawner') ctx.fillStyle = "#00ff00";
        ctx.shadowBlur = 10; ctx.shadowColor = "red";
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
    }
}

// --- ENEMY DATA ---
const ENEMY_DEFS = {
    'swarmer': { hp: 50, spd: 3.0, xp: 10, col: '#ff5500', r: 12, visual: 'insect', ai: 'swarm', crashDmg: 20 },
    'fly': { hp: 30, spd: 3.5, xp: 8, col: '#ccaa00', r: 10, visual: 'insect', ai: 'strafe', crashDmg: 15 },
    'mite': { hp: 60, spd: 2.5, xp: 12, col: '#aa5500', r: 15, visual: 'bug', ai: 'zigzag', crashDmg: 20 },
    'spore': { hp: 40, spd: 1.8, xp: 15, col: '#00aa00', r: 12, visual: 'bio', ai: 'drift', crashDmg: 10 },
    'splitter': { hp: 40, spd: 2.0, xp: 15, col: '#885500', r: 18, visual: 'blob', ai: 'basic', crashDmg: 15 },
    'charger': { hp: 80, spd: 4.0, xp: 25, col: '#ff8800', r: 15, visual: 'beetle', ai: 'charge', crashDmg: 60 },
    'wasp': { hp: 25, spd: 3.5, xp: 20, col: '#ffff00', r: 8, visual: 'insect', ai: 'range_normal', crashDmg: 5 }, 
    'blob': { hp: 150, spd: 0.8, xp: 25, col: '#0055aa', r: 25, visual: 'blob', crashDmg: 30 },
    'drone': { hp: 60, spd: 3.0, xp: 18, col: '#aaaaaa', r: 14, visual: 'mech', ai: 'range_normal', crashDmg: 5 }, 
    'grunt': { hp: 300, spd: 1.2, xp: 40, col: '#aa0000', r: 22, visual: 'mech', crashDmg: 40 },
    'soldier': { hp: 400, spd: 1.1, xp: 50, col: '#cc0000', r: 25, visual: 'mech', crashDmg: 40 },
    'shielded': { hp: 800, spd: 1.0, xp: 70, col: '#00ffff', r: 30, visual: 'shield_mech', crashDmg: 50 },
    'lancer': { hp: 250, spd: 2.2, xp: 55, col: '#ff8800', r: 18, visual: 'spike', crashDmg: 60 },
    'zealot': { hp: 200, spd: 3.5, xp: 60, col: '#ff00ff', r: 20, visual: 'star', ai: 'kamikaze', crashDmg: 100 },
    'dasher': { hp: 200, spd: 1.8, xp: 60, col: '#00ff00', r: 18, visual: 'triangle', ai: 'dash', crashDmg: 60 },
    'shooter': { hp: 350, spd: 1.0, xp: 80, col: '#8800ff', r: 25, visual: 'turret', ai: 'range_normal', crashDmg: 5 },
    'sniper': { hp: 250, spd: 0.8, xp: 120, col: '#ff0088', r: 20, visual: 'cross', ai: 'range_snipe', crashDmg: 5 },
    'mortar': { hp: 500, spd: 0.7, xp: 100, col: '#444444', r: 35, visual: 'heavy_mech', ai: 'range_heavy', crashDmg: 10 },
    'hunter': { hp: 300, spd: 1.4, xp: 90, col: '#00aa44', r: 22, visual: 'stealth', ai: 'range_move', crashDmg: 30 },
    'webber': { hp: 400, spd: 1.0, xp: 100, col: '#cccccc', r: 30, visual: 'spider', ai: 'range_web', crashDmg: 20 },
    'glitch': { hp: 450, spd: 1.8, xp: 110, col: '#ffffff', r: 22, visual: 'glitch', ai: 'teleport', crashDmg: 40 },
    'phantom': { hp: 350, spd: 1.6, xp: 110, col: '#88aaff', r: 25, visual: 'ghost', ai: 'fade', crashDmg: 30 },
    'tank': { hp: 2000, spd: 0.6, xp: 250, col: '#222222', r: 45, visual: 'heavy_tank', crashDmg: 100 },
    'golem': { hp: 5000, spd: 0.4, xp: 600, col: '#554433', r: 60, visual: 'block', crashDmg: 150 },
    'mini_slayer': { hp: 12000, spd: 1.2, xp: 2000, col: '#aa00aa', r: 40, visual: 'boss_slayer', isBoss: true, ai: 'pounce', crashDmg: 200 },
    'boss_hydra': { hp: 25000, spd: 0.5, xp: 5000, col: '#00aa00', r: 90, visual: 'boss_hydra', isBoss: true, ai: 'range_heavy', crashDmg: 300 },
    'boss_titan': { hp: 60000, spd: 0.3, xp: 8000, col: '#aa5500', r: 120, visual: 'boss_titan', isBoss: true, ai: 'swarm', crashDmg: 400 },
    'boss_ufo': { hp: 30000, spd: 1.5, xp: 6000, col: '#8888ff', r: 60, visual: 'boss_ufo', isBoss: true, ai: 'range_move', crashDmg: 100 },
    'mini_mecha': { hp: 15000, spd: 1.0, xp: 3000, col: '#555555', r: 50, visual: 'mini_mecha', isBoss: true, ai: 'range_normal', crashDmg: 150 }
};

class Enemy {
    constructor(type, waveNum) {
        let def = ENEMY_DEFS[type] || ENEMY_DEFS['swarmer'];
        const side = Math.random() > 0.5;
        this.x = side ? -100 : width + 100;
        this.y = Math.random() * height;
        this.type = type;
        this.angle = 0;
        this.timer = Math.random() * 100;
        this.state = 0;
        let scale = 1 + (waveNum * 0.25);
        if (def.isBoss && waveNum < 10) scale *= 0.5;
        if (hasBloodLust) scale *= 2; 

        this.hp = def.hp * scale;
        this.maxHp = this.hp;
        this.speed = def.spd * G_SCALE;
        this.radius = def.r * G_SCALE; 
        this.xp = Math.floor(def.xp * scale);
        this.isBoss = def.isBoss || false;
        this.col = def.col;
        this.visual = def.visual;
        this.ai = def.ai || (def.isBoss && def.ai ? def.ai : 'basic'); 
        this.crashDmg = def.crashDmg || 20;

        this.poisonTimer = 0;
        this.burnTimer = 0;
        this.burnDmgPerTick = 0;

        this.animFrame = Math.random() * 100; 
        this.legs = [];
        if (this.visual === 'spider' || this.visual === 'heavy_tank' || this.visual === 'beetle') {
            for(let i=0; i<6; i++) this.legs.push({x:0, y:0, tX:0, tY:0, step:0});
        }

        this.eliteMod = null;
        if (!this.isBoss && Math.random() < 0.15 + (wave * 0.01)) { 
            const mods = ['AEGIS', 'WARP', 'REGEN', 'VOLATILE', 'GIANT'];
            this.eliteMod = mods[Math.floor(Math.random() * mods.length)];
            this.xp *= 3;
        }
        if (this.eliteMod === 'GIANT') { this.hp *= 2; this.radius *= 1.5; this.maxHp = this.hp; }
        if (this.eliteMod === 'AEGIS') { this.shield = this.hp * 0.5; }
    }

    update() {
        this.animFrame++;
        if (timeStopActive) return;
        
        if (this.poisonTimer > 0) {
            if (this.poisonTimer % 30 === 0) this.takeDamage(Math.max(5, poisonDmg * 0.5), true, 'poison');
            this.poisonTimer--;
        }
        if (this.burnTimer > 0) {
            if (this.burnTimer % 15 === 0) this.takeDamage(this.burnDmgPerTick, true, 'burn');
            this.burnTimer--;
        }

        if (this.eliteMod === 'REGEN' && frame % 60 === 0) this.hp = Math.min(this.maxHp, this.hp + this.maxHp*0.05);

        const head = spine[0];
        let targetX = head.x; let targetY = head.y;
        const dist = Math.hypot(targetX - this.x, targetY - this.y);
        
        enemies.forEach(other => {
            if (other === this) return;
            let dx = this.x - other.x, dy = this.y - other.y;
            let d = Math.hypot(dx, dy);
            let minDist = this.radius + other.radius + 10;
            if (d < minDist && d > 0) {
                let push = (minDist - d) * 0.05;
                this.x += (dx / d) * push; this.y += (dy / d) * push;
            }
        });

        if (reactorDmg > 0 && reactorRadiusMult > 1.0) {
            let pullRange = 500 * G_SCALE * reactorRadiusMult;
            if (dist < pullRange) {
                this.x += (targetX - this.x) * 0.02 * reactorRadiusMult;
                this.y += (targetY - this.y) * 0.02 * reactorRadiusMult;
            }
        }

        const angleToPlayer = Math.atan2(targetY - this.y, targetX - this.x);
        let angleDiff = angleToPlayer - this.angle;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        this.angle += angleDiff * 0.1;

        this.timer++;
        let moveSpeed = this.speed * globalSlow;
        if (auraIceSlow > 0 && dist < 300) moveSpeed *= (1 - auraIceSlow);
        if (fearChance > 0 && Math.random() < fearChance && dist < 200) moveSpeed *= -1; 
        
        if (this.isStunned) {
            moveSpeed *= 0.1;
            this.stunTimer--;
            if(this.stunTimer <= 0) this.isStunned = false;
        }

        let mx = Math.cos(angleToPlayer);
        let my = Math.sin(angleToPlayer);

        if (this.eliteMod === 'WARP' && frame % 120 === 0 && Math.random() < 0.3) {
            this.x += (Math.random()-0.5)*300; this.y += (Math.random()-0.5)*300;
            ctx.fillStyle = "white"; ctx.fillRect(this.x-10, this.y-10, 20, 20);
        }

        if (this.isBoss && this.hp < this.maxHp * 0.5) {
            moveSpeed *= 1.3;
            if (frame % 30 === 0) {
                ctx.fillStyle = "red"; ctx.font = "20px monospace"; ctx.fillText("!", this.x, this.y - 50);
            }
        }

        switch(this.ai) {
            case 'swarm':
                if (dist < 300 * G_SCALE) moveSpeed *= 1.5;
                if (this.isBoss && this.timer > 100) { 
                    moveSpeed = 0;
                    if (this.timer > 160) {
                        for(let i=0; i<12; i++) enemyProjectiles.push(new EnemyProjectile(this.x, this.y, i*(Math.PI/6), 'titan'));
                        this.timer = 0;
                    }
                }
                break;
            case 'strafe':
                mx = Math.cos(angleToPlayer + Math.sin(frame * 0.1) * 0.5);
                my = Math.sin(angleToPlayer + Math.sin(frame * 0.1) * 0.5);
                break;
            case 'zigzag':
                let zig = (frame % 30 < 15) ? 0.5 : -0.5;
                mx = Math.cos(angleToPlayer + zig); my = Math.sin(angleToPlayer + zig);
                break;
            case 'drift':
                if (dist > 800 * G_SCALE) { mx = Math.cos(angleToPlayer); my = Math.sin(angleToPlayer); } 
                else { mx = Math.cos(this.angle + Math.sin(frame*0.05)); my = Math.sin(this.angle + Math.sin(frame*0.05)); }
                break;
            case 'charge': 
                if (this.state === 0) { 
                    mx = Math.cos(angleToPlayer); my = Math.sin(angleToPlayer); moveSpeed *= 0.5;
                    if (this.timer > 60) { this.state = 1; this.timer = 0; }
                } else { 
                    moveSpeed *= 4.0;
                    if (this.timer > 30) { this.state = 0; this.timer = 0; }
                }
                break;
            case 'pounce': 
                if (this.state === 0) { 
                    moveSpeed *= 0.8;
                    if (this.timer > 120) { this.state = 1; this.timer = 0; }
                } else if (this.state === 1) { 
                    moveSpeed = 0;
                    if (this.timer > 40) { this.state = 2; this.timer = 0; }
                } else if (this.state === 2) { 
                    moveSpeed *= 6;
                    if (this.timer > 15) { this.state = 0; this.timer = 0; }
                }
                break;
            case 'dash':
                if (this.state === 0) { if (this.timer > 100) { this.state = 1; this.timer = 0; } } 
                else if (this.state === 1) { moveSpeed = 0; this.x += (Math.random()-0.5)*2; if (this.timer > 40) { this.state = 2; this.timer = 0; } } 
                else if (this.state === 2) { moveSpeed *= 8; if (this.timer > 15) { this.state = 0; this.timer = 0; } }
                break;
            case 'range_normal':
            case 'range_snipe':
            case 'range_heavy':
            case 'range_web':
            case 'range_move':
                let keepDist = (this.ai === 'range_snipe' ? 600 : 350) * G_SCALE;
                let retreatDist = keepDist - 100 * G_SCALE;
                if (dist < retreatDist) { mx = Math.cos(angleToPlayer + Math.PI); my = Math.sin(angleToPlayer + Math.PI); moveSpeed *= 1.2; } 
                else if (dist > keepDist + 100) { mx = Math.cos(angleToPlayer); my = Math.sin(angleToPlayer); } 
                else {
                    let strafeDir = (frame % 200 < 100) ? 1 : -1;
                    mx = Math.cos(angleToPlayer + (Math.PI/2 * strafeDir));
                    my = Math.sin(angleToPlayer + (Math.PI/2 * strafeDir));
                }
                
                let fireRate = this.ai === 'range_snipe' ? 220 : 120;
                if (this.type === 'boss_ufo') fireRate = 180;
                
                if (this.type === 'boss_hydra' && this.timer > 90) {
                    for(let k=-1; k<=1; k++) enemyProjectiles.push(new EnemyProjectile(this.x, this.y, angleToPlayer + k*0.3, 'normal'));
                    this.timer = 0;
                }
                else if (this.type === 'boss_ufo' && this.timer > 60 && this.hp < this.maxHp*0.5) {
                     for(let k=0; k<4; k++) enemyProjectiles.push(new EnemyProjectile(this.x, this.y, frame*0.1 + k*(Math.PI/2), 'boss'));
                }
                else if (this.timer > fireRate) {
                    let pType = this.ai === 'range_snipe' ? 'sniper' : (this.ai === 'range_web' ? 'web' : 'normal');
                    if (this.type === 'boss_ufo') pType = 'boss';
                    let aimAngle = angleToPlayer;
                    if (this.ai === 'range_snipe' || this.isBoss) aimAngle += (Math.random()-0.5) * 0.1;
                    enemyProjectiles.push(new EnemyProjectile(this.x, this.y, aimAngle, pType));
                    this.timer = 0;
                }
                break;
            case 'teleport':
                if (this.timer > 120) {
                    this.x = head.x + (Math.random()-0.5)*400; this.y = head.y + (Math.random()-0.5)*400;
                    this.timer = 0;
                }
                break;
        }

        this.x += mx * moveSpeed;
        this.y += my * moveSpeed;
        if (dist > 2500 * G_SCALE) {
            this.x += (targetX - this.x) * 0.05; this.y += (targetY - this.y) * 0.05;
        }

        if (this.legs.length > 0) {
            this.legs.forEach((leg, i) => {
                let offset = (i % 2 === 0 ? 1 : -1) * (i < 2 ? 0.5 : 1.0);
                let legAngle = this.angle + (i%2===0 ? 1.5 : -1.5) + (i > 1 ? (i%2===0?0.5:-0.5) : 0);
                let idealX = this.x + Math.cos(legAngle) * (this.radius * 2);
                let idealY = this.y + Math.sin(legAngle) * (this.radius * 2);
                if (Math.hypot(idealX - leg.x, idealY - leg.y) > this.radius * 1.5 && leg.step <= 0) {
                    leg.step = 1; leg.tX = idealX; leg.tY = idealY;
                }
                if (leg.step > 0) {
                     leg.x += (leg.tX - leg.x) * 0.2; leg.y += (leg.tY - leg.y) * 0.2; leg.step -= 0.1;
                } else { leg.x = idealX; leg.y = idealY; }
            });
        }

        let hit = false;
        let points = [0, Math.floor(spine.length/2), spine.length-1];
        for(let idx of points) {
            let seg = spine[idx];
            if (Math.hypot(this.x - seg.x, this.y - seg.y) < this.radius + (20 * VISUAL_SCALE)) {
                hit = true;
                if (idx === spine.length-1 && tailDmgMult > 1.0) {
                    this.takeDamage(20 * dragonAtk * tailDmgMult, false);
                    let push = 50 * knockbackStr;
                    this.x -= mx * push; this.y -= my * push;
                }
                break;
            }
        }

        if (hit) {
            let collisionDamage = this.crashDmg;
            if(this.ai === 'kamikaze' || this.eliteMod === 'VOLATILE') { 
                collisionDamage = 80; this.hp = 0; 
                for(let k=0; k<8; k++) enemyProjectiles.push(new EnemyProjectile(this.x, this.y, k * (Math.PI/4)));
            }
            takeDamage(collisionDamage); 
            if(thornsDmg > 0) this.takeDamage(thornsDmg, false);
            // Poltergeist Effect
            if(ghostActive && ghostDmg > 0) this.takeDamage(ghostDmg * dragonAtk, false);
        }
        
        if (reactorDmg > 0 && dist < 200 * VISUAL_SCALE * reactorRadiusMult) {
             if (frame % 20 === 0) this.applyBurn(reactorDmg * 2, 60); 
        }
        if (auraFireDmg > 0 && dist < 250 && frame % 20 === 0) this.applyBurn(auraFireDmg * 2, 60);

        if (mouse.down || autoTurretCount > 0) {
            if (mouse.down) {
                checkLaserHit(this, head, laserCount, 0);
                if(laserRear > 0) checkLaserHit(this, head, laserRear, Math.PI); 
                if(laserSide > 0) {
                    checkLaserHit(this, head, laserSide, Math.PI/2);
                    checkLaserHit(this, head, laserSide, -Math.PI/2);
                }
            }
            if (autoTurretCount > 0 && dist < 600 * G_SCALE) {
                 this.takeDamage(3 * dragonAtk * autoTurretCount * 0.1, true);
            }
        }
    }

    applyBurn(dmg, duration) {
        this.burnTimer = duration;
        this.burnDmgPerTick = dmg;
        this.isBurned = true;
    }

    applyStun(duration) {
        this.isStunned = true;
        this.stunTimer = duration;
        damageNumbers.push(new FloatingText(this.x, this.y, "STUN", "#ffff00", 25));
    }

    takeDamage(amount, isDoT = false, type = 'normal') {
        if (this.eliteMod === 'AEGIS' && Math.random() < 0.5) { 
            if (laserType !== 'plasma' || Math.random() < 0.5) {
                damageNumbers.push(new FloatingText(this.x, this.y, "BLOCK", "#fff", 20));
                return;
            }
        }

        if (furyActive) amount *= 2;
        if (shieldAmpDmg && dragonShield > 0) amount *= 1.2;

        let isCrit = false;
        if (!isDoT && Math.random() < critChance) {
            amount *= critDmg;
            isCrit = true;
            if (lifeSteal > 0) dragonHP = Math.min(dragonMaxHP, dragonHP + lifeSteal);
        }
        
        if (!isDoT && chainLightningChance > 0 && Math.random() < chainLightningChance) {
             let neighbor = enemies.find(e => e !== this && Math.hypot(e.x-this.x, e.y-this.y) < 300);
             if (neighbor) {
                 lightningEffects.push(new LightningEffect(this.x, this.y, neighbor.x, neighbor.y));
                 neighbor.takeDamage(amount * 0.5);
             }
        }

        this.hp -= amount;
        if (executeThreshold > 0 && this.hp < this.maxHp * executeThreshold && !this.isBoss) {
            this.hp = -1;
            damageNumbers.push(new FloatingText(this.x, this.y, "EXECUTE", "#ff0000", 30));
        }

        if (!isDoT || frame % 30 === 0) {
            let color = isCrit ? "#ffcc00" : (this.eliteMod ? "#ff00ff" : "#fff");
            let size = isCrit ? 24 : 14;
            if (isDoT) { 
                size = 12;
                if (type === 'poison') color = "#00ff00";
                else if (type === 'burn') color = "#ff5500";
                else color = "#aaa";
            } 
            if (amount > 1) damageNumbers.push(new FloatingText(this.x, this.y, Math.floor(amount), color, size));
        }
        
        if (this.type === 'spore' && this.hp <= 0) {
             ctx.fillStyle="rgba(0,255,0,0.5)"; ctx.beginPath(); ctx.arc(this.x,this.y, 60, 0, Math.PI*2); ctx.fill();
        }
        if (this.type === 'splitter' && this.hp <= 0) {
             for(let k=0; k<2; k++) {
                 let e = new Enemy('swarmer', wave);
                 e.x = this.x + (Math.random()-0.5)*20; e.y = this.y + (Math.random()-0.5)*20;
                 enemies.push(e);
             }
        }
    }

    draw() {
        if (this.x < -200 || this.x > width+200 || this.y < -200 || this.y > height+200) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(G_SCALE, G_SCALE); 

        const barW = this.isBoss ? 100 : 40;
        if (!this.isBoss) { 
            ctx.fillStyle = "red";
            ctx.fillRect(-barW/2, -this.radius/G_SCALE - 15, barW, 4);
            ctx.fillStyle = "#0f0"; ctx.fillRect(-barW/2, -this.radius/G_SCALE - 15, barW * (Math.max(0, this.hp)/this.maxHp), 4);
        }
        if (this.eliteMod) {
            ctx.strokeStyle = "#ff00ff";
            ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0,0,this.radius/G_SCALE + 5, 0, Math.PI*2); ctx.stroke();
            ctx.fillStyle = "rgba(255, 0, 255, 0.2)";
            ctx.beginPath(); ctx.arc(0, 0, this.radius/G_SCALE + 15, 0, Math.PI*2); ctx.fill();
        }

        ctx.rotate(this.angle);
        
        // Status Visuals
        if (this.isStunned || auraIceSlow > 0 && Math.hypot(this.x - spine[0].x, this.y - spine[0].y) < 300) ctx.fillStyle = "cyan"; // Freezing
        else if (this.poisonTimer > 0) ctx.fillStyle = "#00ff00";
        else if (this.burnTimer > 0) ctx.fillStyle = "#ffaa00";
        else ctx.fillStyle = this.eliteMod ? "#ffccff" : this.col;
        
        let r = this.radius / G_SCALE;
        if (this.legs.length > 0) {
            ctx.strokeStyle = "#444"; ctx.lineWidth = 4;
            this.legs.forEach(l => {
                let dx = l.x - this.x; let dy = l.y - this.y;
                let lx = dx * Math.cos(-this.angle) - dy * Math.sin(-this.angle);
                let ly = dx * Math.sin(-this.angle) + dy * Math.cos(-this.angle);
                lx /= G_SCALE; ly /= G_SCALE;
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(lx/2, ly/2); ctx.lineTo(lx, ly); ctx.stroke();
            });
        }

        // DRAW ENEMY SHAPES
        switch(this.visual) {
            case 'boss_hydra': 
                ctx.fillStyle = "#005500";
                ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
                for(let i=-1; i<=1; i++) {
                    ctx.save();
                    ctx.rotate(i * 0.5 + Math.sin(frame*0.1)*0.2);
                    ctx.fillStyle = "#00aa00";
                    ctx.beginPath(); ctx.ellipse(r, 0, r*0.8, r*0.4, 0, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = "red";
                    ctx.beginPath(); ctx.arc(r*1.5, -5, 3, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(r*1.5, 5, 3, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                }
                break;
            case 'boss_titan': 
                ctx.fillStyle = "#332211";
                ctx.fillRect(-r, -r, r*2, r*2);
                ctx.strokeStyle = "gold"; ctx.lineWidth = 5; ctx.strokeRect(-r, -r, r*2, r*2);
                ctx.fillStyle = "red"; ctx.beginPath();
                ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill();
                break;
            case 'mini_mecha':
                ctx.fillStyle = "#444";
                ctx.beginPath(); ctx.moveTo(r,0); ctx.lineTo(-r,r); ctx.lineTo(-r,-r); ctx.fill();
                ctx.fillStyle = "cyan"; ctx.beginPath(); ctx.arc(0,0, r*0.4, 0, Math.PI*2); ctx.fill();
                break;
            case 'insect': 
                let wingFlap = Math.sin(this.animFrame * 0.5) * 10;
                ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                ctx.beginPath(); ctx.ellipse(-5, -r/2, r*1.2, r/2, Math.PI/4 + wingFlap*0.05, 0, Math.PI*2); ctx.fill();
                ctx.beginPath();
                ctx.ellipse(-5, r/2, r*1.2, r/2, -Math.PI/4 - wingFlap*0.05, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = this.col;
                ctx.beginPath();
                ctx.ellipse(0, 0, r, r*0.6, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(r*0.6, 0, r*0.3, 0, Math.PI*2); ctx.fill();
                break;
            case 'beetle':
                ctx.fillStyle = this.col;
                ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = "#000"; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(-r, 0); ctx.lineTo(r, 0); ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(r*0.8, -r*0.4); ctx.lineTo(r*1.5, -r*0.2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(r*0.8, r*0.4); ctx.lineTo(r*1.5, r*0.2); ctx.stroke();
                break;
            case 'mech': 
                ctx.fillStyle = "#444";
                ctx.fillRect(-r, -r, r*2, r*2);
                ctx.fillStyle = this.col;
                ctx.fillRect(-r*0.6, -r*0.6, r*1.2, r*1.2);
                break;
            case 'turret': 
                ctx.fillStyle = "#333";
                ctx.beginPath(); ctx.moveTo(r, 0); ctx.lineTo(-r, r); ctx.lineTo(-r, -r); ctx.fill();
                ctx.save();
                ctx.rotate(this.animFrame * 0.1);
                ctx.fillStyle = this.col;
                ctx.fillRect(-r*0.5, -r*0.5, r, r);
                ctx.restore();
                break;
            case 'boss_slayer': 
                ctx.fillStyle = this.col;
                ctx.beginPath(); ctx.moveTo(r, 0); ctx.lineTo(-r, r); ctx.lineTo(-r*0.5, 0); ctx.lineTo(-r, -r); ctx.fill();
                ctx.strokeStyle = "#fff"; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(-r, 0); ctx.lineTo(r*0.8, 0); ctx.stroke();
                break;
            case 'boss_ufo': 
                ctx.fillStyle = "#555";
                ctx.beginPath(); ctx.ellipse(0, 0, r, r*0.4, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "cyan";
                ctx.beginPath(); ctx.arc(0, -r*0.2, r*0.5, Math.PI, 0); ctx.fill();
                let lOffset = this.animFrame * 0.2;
                for(let i=0; i<3; i++) {
                    ctx.fillStyle = (Math.floor(this.animFrame/10 + i)%3===0) ? "red" : "#300";
                    ctx.beginPath(); ctx.arc(-r*0.6 + i*r*0.6, r*0.1, 5, 0, Math.PI*2); ctx.fill();
                }
                break;
            default: 
                ctx.fillStyle = this.col;
                ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
                break;
        }
        ctx.restore();
    }
}

class Projectile {
    constructor(x, y, angle, speed) {
        this.x = x; this.y = y; 
        this.vx = Math.cos(angle)*speed; this.vy = Math.sin(angle)*speed;
        this.pen = orbStats.pen;
        this.dmg = 40 * dragonAtk * orbStats.damageMult;
        this.explodes = (orbStats.damageMult >= 1.5 && UPGRADES.some(u => u.name === "Armageddon" && myUpgrades.includes(u)));
        this.ricochet = ricochetCount; 
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            if (Math.hypot(this.x - e.x, this.y - e.y) < e.radius + (15 * G_SCALE)) {
                e.takeDamage(this.dmg);
                if (this.explodes) {
                    ctx.fillStyle = "rgba(255, 100, 0, 0.5)";
                    ctx.beginPath(); ctx.arc(this.x, this.y, 100 * G_SCALE, 0, Math.PI*2); ctx.fill();
                    enemies.forEach(subE => {
                        if (Math.hypot(subE.x - this.x, subE.y - this.y) < 100 * G_SCALE) {
                             subE.takeDamage(this.dmg * 0.5);
                        }
                    });
                }
                
                if (this.ricochet > 0) {
                    this.ricochet--;
                    let nearest = enemies.find(n => n !== e && Math.hypot(n.x - this.x, n.y - this.y) < 400);
                    if (nearest) {
                        let ang = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                        this.vx = Math.cos(ang) * orbStats.speed;
                        this.vy = Math.sin(ang) * orbStats.speed;
                        return false;
                    }
                }

                this.pen--;
                ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(this.x,this.y, 5, 0, Math.PI*2); ctx.fill();
                if (this.pen <= 0) return true;
            }
        }
        return (this.x < -100 || this.x > width+100 || this.y < -100 || this.y > height+100);
    }
    draw() {
        ctx.fillStyle = COLORS.glow; ctx.shadowBlur = 10;
        ctx.shadowColor = COLORS.glow;
        ctx.beginPath(); ctx.arc(this.x, this.y, orbStats.size, 0, Math.PI*2); ctx.fill();
    }
}

// --- CORE LOGIC ---
function takeDamage(amount) {
    if (Math.random() < dodgeChance) {
        damageNumbers.push(new FloatingText(spine[0].x, spine[0].y, "DODGE", "#00ffcc", 20));
        return; 
    }
    // Phase Shift Logic
    if (ghostPhaseShift && Math.random() < 0.25) { 
        damageNumbers.push(new FloatingText(spine[0].x, spine[0].y, "PHASE", "#9900ff", 20));
        spine.forEach(s => { s.x += (Math.random()-0.5)*300; s.y += (Math.random()-0.5)*300; });
        return;
    }

    if (furyInvuln && furyActive) {
         damageNumbers.push(new FloatingText(spine[0].x, spine[0].y, "INVULN", "#ff0000", 20));
         return;
    }

    amount *= dmgTakenMult;
    if (hasBloodLust) amount *= 1.3;
    let mitigation = Math.min(CAP_DEF, dragonDefPct);
    amount *= (1 - mitigation);
    
    // Shield Logic
    if (dragonShield > 0) {
        if (dragonShield >= amount) { dragonShield -= amount; amount = 0; } 
        else { amount -= dragonShield; dragonShield = 0; 
            if (shieldExplode) {
                enemies.forEach(e => {
                    if (Math.hypot(e.x - spine[0].x, e.y - spine[0].y) < 300) {
                        e.takeDamage(100 * dragonAtk); e.x += (e.x - spine[0].x) * 2;
                    }
                });
                ctx.fillStyle = "rgba(0, 255, 255, 0.5)"; ctx.beginPath(); ctx.arc(spine[0].x, spine[0].y, 300, 0, Math.PI*2); ctx.fill();
            }
            if (shieldStunBreak) {
                enemies.forEach(e => {
                    if (Math.hypot(e.x - spine[0].x, e.y - spine[0].y) < 400) e.applyStun(120);
                });
            }
        }
        shieldCooldown = 180;
    }
    if (amount > 0) {
        dragonHP -= amount;
        ctx.fillStyle = "rgba(255,0,0,0.3)"; ctx.fillRect(0,0,width,height); 
        if (dragonHP <= 0 && reviveCount > 0) {
            reviveCount--;
            dragonHP = dragonMaxHP * 0.5;
            enemies.forEach(e => {
                let d = Math.hypot(spine[0].x - e.x, spine[0].y - e.y);
                if (d < 500) e.x += (e.x - spine[0].x) * 2; 
            });
            damageNumbers.push(new FloatingText(spine[0].x, spine[0].y, "REVIVED!", "#ffff00", 50));
            gameActive = true;
        }
    }
}

function checkLaserHit(enemy, head, count, angleOffset) {
    const spread = 0.15;
    const totalSpread = spread * (count - 1);
    const startAngle = (head.angle + angleOffset) - (totalSpread / 2);
    const range = Math.hypot(width, height) * 1.5; 
    const laserPhysWidth = (20 * VISUAL_SCALE * laserWidthBase) + enemy.radius;
    for(let i=0; i<count; i++) {
        const beamAngle = startAngle + (i * spread);
        const p1 = { x: head.x, y: head.y };
        const p2 = { x: head.x + Math.cos(beamAngle) * range, y: head.y + Math.sin(beamAngle) * range };
        const l2 = (p1.x - p2.x)**2 + (p1.y - p2.y)**2;
        let t = ((enemy.x - p1.x) * (p2.x - p1.x) + (enemy.y - p1.y) * (p2.y - p1.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        const distSq = (enemy.x - (p1.x + t * (p2.x - p1.x)))**2 + (enemy.y - (p1.y + t * (p2.y - p1.y)))**2;
        if (distSq < laserPhysWidth * laserPhysWidth) {
            let mult = 1.0;
            if (hasBloodLust) {
                let missingPct = (dragonMaxHP - dragonHP) / dragonMaxHP;
                mult += (missingPct * 100) * 0.015; 
            }
            if (laserType === 'void') enemy.takeDamage(enemy.maxHp * 0.02);
            
            let dmg = 6 * dragonAtk * mult * laserDmgMult;
            if (laserType === 'shotgun') dmg *= 2;
            if (discoMode) {
                 if (Math.random() < 0.1) enemy.applyBurn(dmg*2, 60);
                 else if (Math.random() < 0.1) enemy.speed *= 0.5;
            }

            enemy.takeDamage(dmg);
            if (poisonDmg > 0) enemy.poisonTimer = 300;
            break;
        }
    }
}

function levelUp(isReroll = false) {
    if (!isReroll) {
        isPaused = true;
        exp -= expNext;
        expNext = Math.floor(expNext * 1.2) + 500; 
        level++;
        healPct(0.3); 
        canReroll = true;
    }
    if (!isReroll) upgradeChoices = [];
    if (upgradeChoices.length === 0 || isReroll) upgradeChoices = generateChoices(4);
    updateCardBounds();
}

function generateChoices(count) {
    let choices = [];
    let pool = UPGRADES.filter(u => !u.req || u.req() === true);
    const weights = [60, 25, 10, 5, 1, 0.1];
    while(choices.length < count && pool.length > 0) {
        let rRoll = Math.random() * 100;
        let selectedRarity = 0;
        let cumulative = 0;
        for(let i=0; i<weights.length; i++) {
            cumulative += weights[i];
            if (rRoll <= cumulative) { selectedRarity = i; break; }
        }
        let rarityPool = pool.filter(u => u.r === selectedRarity);
        if (rarityPool.length === 0) rarityPool = pool; 
        let idx = Math.floor(Math.random() * rarityPool.length);
        let choice = rarityPool[idx];
        if (!choices.includes(choice)) { choices.push(choice); }
    }
    return choices;
}

function updateCardBounds() {
    const cardW = 280 * G_SCALE * 1.5;
    const cardH = 400 * G_SCALE * 1.5;
    const gap = 30 * G_SCALE;
    const totalW = (cardW * 4) + (gap * 3);
    const startX = (width - totalW) / 2;
    cardBounds = upgradeChoices.map((_, i) => ({
        x: startX + i * (cardW + gap), 
        y: height/2 - (200 * G_SCALE), 
        w: cardW, 
        h: cardH
    }));
}

function selectUpgrade(index) {
    let u = upgradeChoices[index];
    u.run();
    myUpgrades.push(u);
    upgradeChoices = [];
    isPaused = false;
}

function spawnWave() {
    wave++;
    const count = 10 + Math.floor(wave * 2.5);
    const types = [];
    
    if (wave <= 5) types.push('swarmer', 'fly', 'mite', 'wasp');
    if (wave >= 2) types.push('charger', 'drone', 'shooter'); 
    if (wave >= 3) types.push('splitter'); 
    if (wave > 5) types.push('drone', 'swarmer', 'wasp', 'splitter');
    if (wave > 8) types.push('grunt', 'shielded', 'lancer');
    if (wave > 12) types.push('shooter', 'sniper', 'hunter');
    if (wave > 15) types.push('zealot', 'dasher', 'webber');
    if (wave > 20) types.push('tank', 'phantom');
    if (wave > 25) types.push('glitch', 'tank');
    if (wave > 30) types.push('golem');
    if (wave > 40) types.push('mini_slayer', 'boss_ufo');
    
    if (wave % 5 === 0) {
        let bossType = 'mini_slayer';
        if (wave === 10) bossType = 'boss_hydra'; 
        else if (wave === 20) bossType = 'boss_titan';
        else if (wave === 30) bossType = 'boss_ufo';
        else if (wave === 40) bossType = 'mini_mecha';
        else if (wave >= 50 && wave % 10 === 0) bossType = 'boss_hydra'; 
        enemies.push(new Enemy(bossType, wave));
    }
    for (let i=0; i<count; i++) {
        let t = types[Math.floor(Math.random() * types.length)];
        enemies.push(new Enemy(t, wave));
    }
}

// --- VISUALS ---
function drawLaserFan(head, count, angleOffset, colorOverride) {
    const spread = 0.15;
    const totalSpread = spread * (count - 1);
    const startAngle = (head.angle + angleOffset) - (totalSpread / 2);
    let laserCol = furyActive ? COLORS.fury : (laserType === 'plasma' ? COLORS.plasma : COLORS.laser);
    if (discoMode) laserCol = `hsl(${frame * 5}, 100%, 50%)`;

    ctx.shadowBlur = furyActive ? 50 : 35; 
    ctx.shadowColor = laserCol;
    ctx.strokeStyle = colorOverride || laserCol;
    ctx.lineWidth = 10 * VISUAL_SCALE * laserWidthBase;

    for(let i=0; i<count; i++) {
        const a = startAngle + (i * spread);
        const startX = head.x + Math.cos(a)*45*VISUAL_SCALE;
        const startY = head.y + Math.sin(a)*45*VISUAL_SCALE;
        const range = Math.max(width, height) * 1.5;
        ctx.beginPath();
        ctx.moveTo(startX, startY); ctx.lineTo(startX+Math.cos(a)*range, startY+Math.sin(a)*range); ctx.stroke();
    }
}

function drawLasers(head) {
    if (!mouse.down && autoTurretCount === 0) return;
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    if (mouse.down) {
        drawLaserFan(head, laserCount, 0);
        if(laserRear > 0) drawLaserFan(head, laserRear, Math.PI); 
        if(laserSide > 0) {
            drawLaserFan(head, laserSide, Math.PI/2);
            drawLaserFan(head, laserSide, -Math.PI/2);
        }
    }
    if (tailTurret) {
         let tail = spine[spine.length-1];
         drawLaserFan(tail, 1, Math.PI);
         if (frame % 5 === 0) {
             let nearest = enemies[0];
             if(nearest) checkLaserHit(nearest, tail, 1, Math.PI);
         }
    }
    if (autoTurretCount > 0) {
        let nearest = null; let minD = Infinity;
        enemies.forEach(e => {
            let d = Math.hypot(e.x - head.x, e.y - head.y);
            if(d < minD) { minD = d; nearest = e; }
        });
        if (nearest && minD < 600 * G_SCALE) {
            ctx.shadowBlur = 10;
            ctx.strokeStyle = "#ff00ff"; ctx.lineWidth = 5 * VISUAL_SCALE;
            ctx.beginPath(); ctx.moveTo(head.x, head.y); ctx.lineTo(nearest.x, nearest.y); ctx.stroke();
        }
    }
    ctx.restore();
}

function drawShockwave(spine) {
    if(!shockwaveEnabled) return;
    if(shockwaveActiveFrame > 0) {
        const center = spine[Math.floor(spine.length/2)];
        ctx.save();
        ctx.strokeStyle = COLORS.shockwave;
        ctx.lineWidth = 5 + (shockwaveActiveFrame);
        ctx.globalAlpha = shockwaveActiveFrame / 10;
        ctx.beginPath(); ctx.arc(center.x, center.y, shockwaveRange, 0, Math.PI*2); ctx.stroke();
        ctx.fillStyle = "rgba(255, 255, 0, 0.2)"; ctx.fill();
        ctx.restore();
        shockwaveActiveFrame--;
    }
}

function drawShield(head) {
    if(dragonShield > 0) {
        ctx.save();
        ctx.strokeStyle = COLORS.shield;
        ctx.lineWidth = 3 + Math.sin(frame*0.1)*1;
        ctx.shadowBlur = 10; ctx.shadowColor = "cyan";
        ctx.beginPath(); ctx.arc(head.x, head.y, 60 * VISUAL_SCALE, 0, Math.PI*2);
        ctx.stroke();
        ctx.globalAlpha = 0.1; ctx.fillStyle = COLORS.shield; ctx.fill();
        ctx.restore();
    }
}

function drawDragonBone(x1, y1, x2, y2, thickness, isWing = false) {
    const dist = Math.hypot(x2 - x1, y2 - y1);
    const angle = Math.atan2(y2 - y1, x2 - x1);
    ctx.save();
    ctx.translate(x1, y1); ctx.rotate(angle);
    ctx.fillStyle = isWing ? "rgba(0, 150, 255, 0.25)" : (furyActive ? "#330000" : COLORS.bone);
    ctx.strokeStyle = furyActive ? "#ff3300" : COLORS.accent;
    ctx.shadowBlur = furyActive ? 15 : 0; ctx.shadowColor = "red";
    ctx.beginPath(); ctx.moveTo(0, -thickness * 0.7);
    ctx.quadraticCurveTo(dist / 2, -thickness * 0.2, dist, -thickness * 0.7);
    ctx.lineTo(dist, thickness * 0.7);
    ctx.quadraticCurveTo(dist / 2, thickness * 0.2, 0, thickness * 0.7);
    ctx.fill(); ctx.stroke();
    ctx.restore();
}

function drawWings(anchor) {
    const flap = Math.sin(frame * CONFIG.wingFlapSpeed);
    const drawSide = (isLeft) => {
        let side = isLeft ? -1 : 1;
        let a1 = anchor.angle + (side * 1.5) + (flap * 0.2 * side);
        let armLen = CONFIG.wingSpan * 0.35;
        let j1X = anchor.x + Math.cos(a1) * armLen, j1Y = anchor.y + Math.sin(a1) * armLen;
        let a2 = a1 + (0.6 * side) + (flap * 0.1 * side);
        let foreLen = CONFIG.wingSpan * 0.45;
        let j2X = j1X + Math.cos(a2) * foreLen, j2Y = j1Y + Math.sin(a2) * foreLen;
        let fingerPoints = [];
        for (let i = 0; i < 4; i++) {
            let fA = a2 + (0.4 + i * 0.5) * side + (flap * 0.05);
            let fLen = CONFIG.wingSpan * (0.9 - i * 0.15);
            fingerPoints.push({ x: j2X + Math.cos(fA) * fLen, y: j2Y + Math.sin(fA) * fLen });
        }
        ctx.fillStyle = furyActive ? "rgba(255, 0, 0, 0.15)" : "rgba(0, 120, 255, 0.15)";
        ctx.beginPath(); ctx.moveTo(anchor.x, anchor.y); ctx.lineTo(j1X, j1Y); ctx.lineTo(j2X, j2Y);
        fingerPoints.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.fill();
        drawDragonBone(anchor.x, anchor.y, j1X, j1Y, 9 * VISUAL_SCALE, true);
        drawDragonBone(j1X, j1Y, j2X, j2Y, 7 * VISUAL_SCALE, true);
        fingerPoints.forEach(p => drawDragonBone(j2X, j2Y, p.x, p.y, 3 * VISUAL_SCALE, true));
    };
    drawSide(true); drawSide(false);
}

function drawDragonHead(s) {
    ctx.save();
    ctx.translate(s.x, s.y); ctx.rotate(s.angle); ctx.scale(VISUAL_SCALE, VISUAL_SCALE);
    ctx.fillStyle = furyActive ? "#330000" : COLORS.bone; 
    ctx.strokeStyle = furyActive ? "#ff0000" : COLORS.accent;
    const drawHorn = (side) => {
        ctx.save(); ctx.beginPath(); ctx.moveTo(-12, side * 8);
        ctx.quadraticCurveTo(-35, side * 40, -75, side * 35);
        ctx.lineTo(-72, side * 34); ctx.quadraticCurveTo(-32, side * 32, -18, side * 12);
        ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();
    };
    drawHorn(1); drawHorn(-1);
    ctx.beginPath(); ctx.moveTo(-20, -12); ctx.lineTo(12, -18); ctx.lineTo(48, -4);
    ctx.lineTo(50, 0); ctx.lineTo(48, 4); ctx.lineTo(12, 18);
    ctx.lineTo(-20, 12);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle = furyActive ? "#ff0000" : COLORS.glow; 
    ctx.shadowBlur = 15; ctx.shadowColor = ctx.fillStyle;
    ctx.beginPath();
    ctx.arc(15, -8, 4, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(15, 8, 4, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
}

function drawUI() {
    canvas.style.cursor = isPaused ? "default" : "none";
    ctx.fillStyle = "#111"; ctx.fillRect(0, 0, width, 10);
    ctx.fillStyle = COLORS.glow; ctx.fillRect(0, 0, width * (exp/expNext), 10);
    
    ctx.textAlign = "left"; ctx.fillStyle = "white";
    ctx.font = `bold ${16 * G_SCALE * 1.5}px monospace`;
    ctx.fillText(`LVL ${level} | WAVE ${wave}`, 20, 35);
    // SHOW CAPS
    ctx.fillText(`ATK ${dragonAtk.toFixed(1)} | DEF ${(dragonDefPct*100).toFixed(0)}% (Cap 50%)`, 20, 55);
    ctx.fillText(`DODGE ${(dodgeChance*100).toFixed(0)}% (Cap 60%)`, 20, 75);
    
    if (furyEnabled) {
        ctx.fillText(`FURY`, 20, 100);
        ctx.fillStyle = "#330000"; ctx.fillRect(70, 88, 100, 12);
        ctx.fillStyle = furyActive ? "#ffff00" : "#ff0000"; ctx.fillRect(70, 88, furyMeter, 12);
        ctx.strokeRect(70, 88, 100, 12);
    }
    
    if (reviveCount > 0) ctx.fillText(`REVIVES: ${reviveCount}`, 20, 125);
    
    let bosses = enemies.filter(e => e.isBoss);
    if (bosses.length > 0) {
        let boss = bosses[0];
        let bw = 600 * G_SCALE; let bh = 20; let bx = width/2 - bw/2;
        ctx.fillStyle = "#330000";
        ctx.fillRect(bx, 50, bw, bh);
        ctx.fillStyle = boss.type.includes('mini') ? "#aa00aa" : "#ff0000"; ctx.fillRect(bx, 50, bw * (Math.max(0,boss.hp)/boss.maxHp), bh);
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.strokeRect(bx, 50, bw, bh);
        ctx.fillStyle = "#fff"; ctx.textAlign = "center";
        ctx.fillText(boss.type.toUpperCase(), width/2, 45);
    }

    const barW = 400 * G_SCALE * 1.5;
    const bx = width/2 - barW/2;
    ctx.fillStyle = "#222"; ctx.fillRect(bx, height - 30, barW, 20);
    const hpPct = Math.min(1, Math.max(0, dragonHP/dragonMaxHP));
    ctx.fillStyle = hpPct > 0.3 ? (furyActive ? "#ffaa00" : "lime") : "red";
    ctx.fillRect(bx, height - 30, barW * hpPct, 20);
    ctx.strokeStyle = "#fff"; ctx.strokeRect(bx, height-30, barW, 20);
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center"; ctx.fillText(`${Math.floor(dragonHP)}/${Math.floor(dragonMaxHP)}`, width/2, height - 15);
    
    if (dragonShield > 0) {
        const shPct = Math.min(1, dragonShield / dragonMaxShield);
        ctx.fillStyle = "cyan"; ctx.fillRect(bx, height - 35, barW * shPct, 5);
    }

    if (isPaused) {
        ctx.fillStyle = "rgba(0,0,0,0.9)"; ctx.fillRect(0,0,width,height);
        ctx.textAlign = "center"; 
        ctx.fillStyle = COLORS.glow; ctx.font = "bold 40px monospace";
        ctx.shadowBlur = 20; ctx.shadowColor = COLORS.glow;
        ctx.fillText("EVOLUTION", width/2, height/2 - 300);
        ctx.shadowBlur = 0;
        
        upgradeChoices.forEach((c, i) => {
            const b = cardBounds[i];
            let rColor = COLORS.common;
            if(c.r===1) rColor=COLORS.rare; if(c.r===2) rColor=COLORS.epic;
            if(c.r===3) rColor=COLORS.legendary; if(c.r===4) rColor=COLORS.cursed;
            if(c.r===5) rColor=COLORS.mythic;

            ctx.fillStyle = "#050a14"; ctx.fillRect(b.x, b.y, b.w, b.h);
            ctx.strokeStyle = rColor; ctx.lineWidth = 4; ctx.strokeRect(b.x, b.y, b.w, b.h);
            
            let grad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.h);
            grad.addColorStop(0, rColor); grad.addColorStop(1, "transparent");
            ctx.fillStyle = grad; ctx.globalAlpha = 0.2; ctx.fillRect(b.x, b.y, b.w, b.h);
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = rColor; ctx.font = `bold ${18 * G_SCALE * 1.5}px monospace`; 
            ctx.fillText(c.name, b.x + b.w/2, b.y + 60);
            
            let rText = ["COMMON", "RARE", "EPIC", "LEGENDARY", "CURSED", "MYTHIC"][c.r];
            ctx.font = `bold 14px monospace`; ctx.fillText(rText, b.x + b.w/2, b.y + 85);

            ctx.fillStyle = "white";
            ctx.font = `${14 * G_SCALE * 1.5}px monospace`;
            wrapText(ctx, c.desc, b.x + b.w/2, b.y + 140, b.w - 40, 24);
            ctx.fillStyle = rColor; ctx.font = `bold ${16 * G_SCALE * 1.5}px monospace`;
            ctx.fillText("[ CLICK TO SELECT ]", b.x + b.w/2, b.y + b.h - 40);
            
            if (canReroll) {
                let btnW = 80; let btnH = 30; let btnX = b.x + b.w/2 - btnW/2; let btnY = b.y + b.h + 10;
                ctx.fillStyle = "#333"; ctx.fillRect(btnX, btnY, btnW, btnH);
                ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.strokeRect(btnX, btnY, btnW, btnH);
                ctx.fillStyle = "#fff"; ctx.font = "bold 16px monospace";
                ctx.fillText("REROLL", btnX + btnW/2, btnY + 20);
            }
        });
        ctx.fillStyle = "white";
        ctx.font = "16px monospace"; ctx.textAlign = "left";
        ctx.fillText("STATS / UPGRADES:", 20, height - 150);
        let txt = myUpgrades.map(u => u.name).join(", ");
        wrapText(ctx, txt, 20, height - 120, width - 40, 20);
    }
}

function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    let words = text.split(' ');
    let line = '';
    for(let n = 0; n < words.length; n++) {
        let testLine = line + words[n] + ' ';
        let metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && n > 0) {
            ctx.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
        } else { line = testLine; }
    }
    ctx.fillText(line, x, y);
}

// --- MAIN LOOP ---
function update() {
    if (!gameActive || isPaused) return;
    frame++;
    if (enemies.length === 0) spawnWave();

    let head = spine[0];
    let speed = mouse.down ? CONFIG.headSpeed * 0.15 : CONFIG.headSpeed;
    if (furyActive) speed *= 1.5;
    
    if (webbedTimer > 0) {
        speed *= 0.4; webbedTimer--;
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(head.x, head.y, 40 * VISUAL_SCALE, 0, Math.PI*2); ctx.stroke();
    }

    head.x += (mouse.x - head.x) * speed;
    head.y += (mouse.y - head.y) * speed;
    head.angle = Math.atan2(mouse.y - head.y, mouse.x - head.x);

    for (let i=1; i<spine.length; i++) {
        let p = spine[i-1], c = spine[i];
        let a = Math.atan2(p.y - c.y, p.x - c.x);
        c.angle = a; c.x = p.x - Math.cos(a)*CONFIG.segmentDist;
        c.y = p.y - Math.sin(a)*CONFIG.segmentDist;
    }
    legs.forEach(leg => {
        let body = spine[leg.anchorIndex], side = leg.isLeft ? -1.6 : 1.6;
        let iX = body.x + Math.cos(body.angle + side) * (115 * VISUAL_SCALE), iY = body.y + Math.sin(body.angle + side) * (115 * VISUAL_SCALE);
        if (!leg.isStepping && Math.hypot(iX - leg.x, iY - leg.y) > 95 * VISUAL_SCALE) {
            leg.isStepping = true; leg.stepProgress = 0; leg.stepStartX = leg.x; leg.stepStartY = leg.y;
            leg.targetX = iX + Math.cos(body.angle) * (70 * VISUAL_SCALE); leg.targetY = iY + Math.sin(body.angle) * (70 * VISUAL_SCALE);
        }
        if (leg.isStepping) {
            leg.stepProgress += CONFIG.legSpeed;
            if (leg.stepProgress >= 1) { leg.isStepping = false; leg.x = leg.targetX; leg.y = leg.targetY; }
            else {
                let t = leg.stepProgress;
                leg.x = leg.stepStartX + (leg.targetX - leg.stepStartX) * t; leg.y = leg.stepStartY + (leg.targetY - leg.stepStartY) * t;
                leg.lift = Math.sin(t * Math.PI) * (45 * VISUAL_SCALE);
            }
        }
    });

    if(shieldCooldown > 0) shieldCooldown--;
    if(frame % 60 === 0) {
        if(dragonHP < dragonMaxHP && dragonRegen > 0) dragonHP = Math.min(dragonMaxHP, dragonHP + dragonRegen * 60);
        
        // Shield Regen Check
        if(shieldCooldown <= 0 && dragonShield < dragonMaxShield) {
            dragonShield = Math.min(dragonMaxShield, dragonShield + dragonShieldRegen * 60);
        }
    }
    
    if (furyEnabled && furyMeter >= 100 && !furyActive) {
        furyActive = true; furyTimer = furyDuration; shockwaveEnabled = true; 
        if (furyExplosion) {
             // Hellfire Effect
             enemies.forEach(e => {
                 if (Math.hypot(e.x - head.x, e.y - head.y) < 500) e.takeDamage(200 * dragonAtk);
             });
             ctx.fillStyle = "rgba(255, 0, 0, 0.5)"; ctx.beginPath(); ctx.arc(head.x, head.y, 500, 0, Math.PI*2); ctx.fill();
        }
    }
    if (furyActive) {
        furyTimer--;
        furyMeter = (furyTimer / furyDuration) * 100;
        if (furyTimer <= 0) { furyActive = false; furyMeter = 0; }
    }
    if (gamblerMode) {
        gamblerTimer++;
        if (gamblerTimer > 600) {
             gamblerTimer = 0;
             dragonAtk = dragonAtk * (0.8 + Math.random() * 0.4);
             damageNumbers.push(new FloatingText(head.x, head.y, "REROLL STATS", "#fff", 30));
        }
    }

    if (timeStopActive) {
        timeStopTimer--;
        if (timeStopTimer <= 0) timeStopActive = false;
        else return; 
    }
    if (timeStopChance > 0 && !timeStopActive && frame % 600 === 0 && Math.random() < timeStopChance) {
        timeStopActive = true; timeStopTimer = 120;
    }

    if(shockwaveEnabled) {
        shockwaveTimer++;
        if(shockwaveTimer > (furyActive ? 30 : shockwaveInterval)) { 
            shockwaveTimer = 0;
            shockwaveActiveFrame = 15;
            const center = spine[Math.floor(spine.length/2)];
            enemies.forEach(e => {
                let d = Math.hypot(center.x - e.x, center.y - e.y);
                if(d < shockwaveRange) {
                    e.takeDamage(shockwaveDmg * dragonAtk);
                    let a = Math.atan2(e.y - center.y, e.x - center.x);
                    let push = 150 * G_SCALE * knockbackStr;
                    e.x += Math.cos(a) * push; e.y += Math.sin(a) * push;
                }
            });
        }
    }
    
    if (mouse.down && orbLevel > 0) {
        let rateMod = fireRateMult;
        if (shieldAmpFire && dragonShield > 0) rateMod *= 1.15;

        // UPDATED FIRE RATE LOGIC
        const fireRate = Math.max(1, (20 - (orbLevel * 2)) / rateMod);
        if (frame % Math.floor(fireRate) === 0) {
            projectiles.push(new Projectile(head.x, head.y, head.angle, orbStats.speed));
            if (orbLevel >= 3) { 
                projectiles.push(new Projectile(head.x, head.y, head.angle + 0.3, orbStats.speed));
                projectiles.push(new Projectile(head.x, head.y, head.angle - 0.3, orbStats.speed));
            }
        }
    }
    
    let effectiveFireRate = fireRateMult;
    if (shieldAmpFire && dragonShield > 0) effectiveFireRate *= 1.15;

    if (unlockedMissiles && frame % Math.floor(60 / effectiveFireRate) === 0) {
        for(let m=0; m<missileCount; m++) summons.push(new Missile(head.x, head.y));
    }
    if (unlockedMines && frame % 120 === 0) summons.push(new Mine(head.x, head.y));
    
    if (unlockedStatic && frame % 30 === 0) {
        let nearest = enemies[0]; let minD = Infinity;
        enemies.forEach(e => {
            let d = Math.hypot(e.x - head.x, e.y - head.y);
            if(d < minD) { minD = d; nearest = e; }
        });
        if (nearest && minD < 300 * G_SCALE) {
             nearest.takeDamage(20 * dragonAtk);
             ctx.strokeStyle = "#ffff00"; ctx.beginPath(); ctx.moveTo(head.x, head.y); ctx.lineTo(nearest.x, nearest.y); ctx.stroke();
        }
    }

    if (!mouse.down && dragonHP < dragonMaxHP && frame % 60 === 0) {
        dragonHP = Math.min(dragonMaxHP, dragonHP + 5);
    }
    
    enemies.forEach((e, i) => {
        e.update();
        if (e.hp <= 0) { 
            score += 10; gems.push(new ExpGem(e.x, e.y, e.xp)); 
            if(furyEnabled && !furyActive) furyMeter = Math.min(100, furyMeter + (e.isBoss ? 20 : 2));
            enemies.splice(i, 1); 
        }
     });
    
    damageNumbers = damageNumbers.filter(d => d.update());
    lightningEffects = lightningEffects.filter(l => l.update()); 
    gems = gems.filter(g => !g.update());
    projectiles = projectiles.filter(p => !p.update());
    enemyProjectiles = enemyProjectiles.filter(p => !p.update());
    summons = summons.filter(s => !s.update());
    if (dragonHP <= 0) gameActive = false;
}

function draw() {
    ctx.fillStyle = timeStopActive ? "#111122" : "#00020a";
    ctx.fillRect(0, 0, width, height);
    
    drawLasers(spine[0]);
    drawShockwave(spine);
    if (reactorDmg > 0) {
        ctx.beginPath();
        ctx.arc(spine[0].x, spine[0].y, 200 * VISUAL_SCALE * reactorRadiusMult, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(255, 100, 0, 0.1)"; ctx.stroke();
    }
    if (auraIceSlow > 0) {
        ctx.beginPath();
        ctx.arc(spine[0].x, spine[0].y, 300 * VISUAL_SCALE, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(0, 255, 255, 0.1)"; ctx.stroke();
    }

    gems.forEach(g => g.draw());
    summons.forEach(s => s.draw());
    lightningEffects.forEach(l => l.draw()); 
    projectiles.forEach(p => p.draw());
    enemyProjectiles.forEach(p => p.draw());
    enemies.forEach(e => e.draw());
    damageNumbers.forEach(d => d.draw());
    
    ctx.strokeStyle = COLORS.accent; ctx.lineWidth = 1;
    // GHOST VISUAL
    if (ghostActive) ctx.globalAlpha = 0.5;

    drawWings(spine[CONFIG.wingAttachment]);
    spine.forEach((s, i) => {
        let ribStart = 10, ribEnd = 50, ribSpan = ribEnd - ribStart;
        let ribW = (i > ribStart && i < ribEnd) ? Math.sin((i-ribStart)/ribSpan*Math.PI)*CONFIG.maxRibWidth : 0;
        if (ribW > 0) {
            let p = s.angle + Math.PI/2;
            ctx.beginPath(); ctx.moveTo(s.x + Math.cos(p)*ribW, s.y + Math.sin(p)*ribW);
            ctx.quadraticCurveTo(s.x - Math.cos(s.angle)*15*VISUAL_SCALE, s.y - Math.sin(s.angle)*15*VISUAL_SCALE, s.x - Math.cos(p)*ribW, s.y - Math.sin(p)*ribW);
            ctx.stroke();
        }
        if (i > 0) {
            ctx.lineWidth = i < 40 ? 5 * VISUAL_SCALE : 2 * VISUAL_SCALE;
            ctx.strokeStyle = furyActive ? "#ff3300" : COLORS.accent;
            ctx.beginPath(); 
            ctx.moveTo(spine[i - 1].x, spine[i - 1].y); ctx.lineTo(s.x, s.y); ctx.stroke();
        }
    });
    drawShield(spine[0]); 
    
    legs.forEach(leg => {
        let body = spine[leg.anchorIndex], hSide = leg.isLeft ? -1.5 : 1.5;
        let hX = body.x + Math.cos(body.angle + hSide) * (25 * VISUAL_SCALE), hY = body.y + Math.sin(body.angle + hSide) * (25 * VISUAL_SCALE);
        let dx = leg.x - hX, dy = (leg.y - leg.lift) - hY;
        let dist = Math.min(Math.sqrt(dx * dx + dy * dy), CONFIG.upperLegLen + CONFIG.lowerLegLen - 2);
        let a = Math.atan2(dy, dx), cos = (CONFIG.upperLegLen**2 + dist**2 - CONFIG.lowerLegLen**2) / (2 * CONFIG.upperLegLen * dist);
        let kneeA = leg.isLeft ? a + Math.acos(Math.max(-1, Math.min(1, cos))) : a - Math.acos(Math.max(-1, Math.min(1, cos)));
        let kX = hX + Math.cos(kneeA) * CONFIG.upperLegLen, kY = hY + Math.sin(kneeA) * CONFIG.upperLegLen;
        drawDragonBone(hX, hY, kX, kY, 8 * VISUAL_SCALE); drawDragonBone(kX, kY, leg.x, leg.y - leg.lift, 6 * VISUAL_SCALE);
    });
    drawDragonHead(spine[0]);
    
    ctx.globalAlpha = 1.0; // Reset alpha for UI
    drawUI();
    if (!gameActive) {
        ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(0,0,width,height);
        ctx.fillStyle = "white";
        ctx.textAlign = "center"; ctx.font = "50px monospace";
        ctx.fillText("GAME OVER", width/2, height/2);
        ctx.font = "20px monospace";
        ctx.fillText(`Max Level: ${level} | Wave: ${wave}`, width/2, height/2 + 50);
        ctx.fillText("Refresh to restart", width/2, height/2 + 80);
    }
}

function init() {
    resize();
    spine = [];
    for (let i = 0; i < CONFIG.segmentCount; i++) spine.push({ x: mouse.x, y: mouse.y, angle: 0 });
    legs = [
        { anchorIndex: 18, isLeft: true, x: 0, y: 0 }, { anchorIndex: 18, isLeft: false, x: 0, y: 0 },
        { anchorIndex: 50, isLeft: true, x: 0, y: 0 }, { anchorIndex: 50, isLeft: false, x: 0, y: 0 }
    ];
    loop();
}

function resize() { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('mousedown', () => {
    if (isPaused) {
        if (canReroll) {
            let rerolled = false;
            cardBounds.forEach((b, i) => {
                let btnW = 80; let btnH = 30; let btnX = b.x + b.w/2 - btnW/2; let btnY = b.y + b.h + 10;
                if (mouse.x > btnX && mouse.x < btnX + btnW && mouse.y > btnY && mouse.y < btnY + btnH) {
                    canReroll = false; 
                    let pool = UPGRADES.filter(u => !u.req || u.req() === true);
                    let newChoice = pool[Math.floor(Math.random() * pool.length)];
                    upgradeChoices[i] = newChoice;
                    rerolled = true;
                }
            });
            if (rerolled) return;
        }

        cardBounds.forEach((b, i) => {
            if (mouse.x > b.x && mouse.x < b.x + b.w && mouse.y > b.y && mouse.y < b.y + b.h) selectUpgrade(i);
        });
    } else { mouse.down = true; }
});
window.addEventListener('mouseup', () => mouse.down = false);
function loop() { update(); draw(); requestAnimationFrame(loop); }
init();
