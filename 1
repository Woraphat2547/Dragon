const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let width, height;
let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2, down: false };
let frame = 0;

// --- GLOBAL SCALING ---
const G_SCALE = 0.5; 

// --- THEME ---
const COLORS = {
    bone: "#001a4d",
    accent: "#0066ff",
    glow: "#00ffff",
    laser: "#ccf2ff",
    plasma: "#ff00ff",
    enemyProj: "#ff3333",
    shield: "rgba(0, 255, 255, 0.3)",
    shockwave: "rgba(255, 255, 0, 0.4)",
    bossBar: "#ff0000",
    fury: "#ff3300",
    cursed: "#800080"
};

// --- GAME STATE ---
let dragonHP = 18000; 
let dragonMaxHP = 18000;
let dragonShield = 0;
let dragonMaxShield = 0;
let dragonShieldRegen = 0; 
let shieldCooldown = 0;

// Caps
const CAP_DEF = 0.50; // 50% Max
const CAP_DODGE = 0.30; // 30% Max
const CAP_CRIT = 1.0; // 100% Max

// Stats
let dragonDefPct = 0; 
let dragonAtk = 1;
let dragonRegen = 0.2; 
let xpMultiplier = 1.0;
let lifeSteal = 0; 
let dodgeChance = 0; 
let globalSlow = 1.0; 
let tailDmgMult = 1.0;
let critChance = 0.05; 
let critDmg = 1.5;     
let thornsDmg = 0;
let knockbackStr = 1.0;
let executeThreshold = 0; // % HP to instant kill

// Special Mechanics
let furyEnabled = false;
let furyMeter = 0;
let furyActive = false;
let furyTimer = 0;
let furyDuration = 600;
let autoTurretCount = 0;
let magnetRange = 1.0;

// Blood Lust Logic
let hasBloodLust = false; 

// Shockwave Stats
let shockwaveEnabled = false;
let shockwaveTimer = 0;
let shockwaveInterval = 180;
let shockwaveRange = 300 * G_SCALE; 
let shockwaveDmg = 50;
let shockwaveActiveFrame = 0;

let level = 1;
let exp = 0;
let expNext = 800; 
let wave = 0;
let score = 0;
let gameActive = true;
let isPaused = false;

// --- STACKABLE UPGRADE STATS ---
let laserCount = 1;
let laserWidthBase = 1;
let laserRear = 0;
let laserSide = 0;
let laserType = 'normal'; // normal, plasma (penetrate)
let orbLevel = 0;
let orbStats = { speed: 8 * G_SCALE, size: 10 * G_SCALE, pen: 1, damageMult: 1, count: 1 };
let reactorDmg = 0; 
let reactorRadiusMult = 1.0;

let enemies = [];
let projectiles = [];
let enemyProjectiles = [];
let gems = [];
let upgradeChoices = [];
let cardBounds = [];
let damageNumbers = []; 

// --- CONFIG (Dragon Specs) ---
let VISUAL_SCALE = 0.6 * G_SCALE; 

const CONFIG = {
    segmentCount: 85,
    segmentDist: 8 * VISUAL_SCALE, 
    headSpeed: 0.015, 
    maxRibWidth: 42 * VISUAL_SCALE, 
    legSpeed: 0.05,
    upperLegLen: 75 * VISUAL_SCALE, 
    lowerLegLen: 85 * VISUAL_SCALE, 
    wingSpan: 340 * VISUAL_SCALE,   
    wingFlapSpeed: 0.03,
    wingAttachment: 18
};

let spine = [];
let legs = [];

// --- UPGRADES DATABASE ---
const UPGRADES = [
    // --- DEFENSE (NEW CATEGORY) ---
    { type: 'def', name: "Obsidian Scales", desc: "Defense +5% (Max 50%)", run: () => dragonDefPct = Math.min(CAP_DEF, dragonDefPct + 0.05) },
    { type: 'def', name: "Iron Plating", desc: "Max HP +20%", run: () => { let add = dragonMaxHP*0.20; dragonMaxHP+=add; dragonHP+=add; } },
    { type: 'def', name: "Regeneration Field", desc: "Regen +2 HP/frame", run: () => dragonRegen += 2 },
    { type: 'def', name: "Spiked Carapace", desc: "Thorns +50 DMG", run: () => thornsDmg += 50 },
    { type: 'def', name: "Energy Shield", desc: "Unlock 500 Shield (Regens)", run: () => { dragonMaxShield += 500; dragonShieldRegen += 2; } },
    { type: 'def', name: "Shield Capacitor", desc: "Shield Cap +50%, Shield Regen +50%", run: () => { dragonMaxShield *= 1.5; dragonShieldRegen *= 1.5; } },
    { type: 'def', name: "Evasive Maneuvers", desc: "Dodge +5% (Max 30%)", run: () => dodgeChance = Math.min(CAP_DODGE, dodgeChance + 0.05) },
    { type: 'def', name: "Titan's Will", desc: "Knockback Resistance & Effect +30%", run: () => knockbackStr += 0.3 },
    { type: 'def', name: "Second Wind", desc: "Heal 30% HP Instantly", run: () => dragonHP = Math.min(dragonMaxHP, dragonHP + (dragonMaxHP * 0.3)) },
    { type: 'def', name: "Aegis", desc: "Defense +8% (Max 50%), Speed -5%", run: () => { dragonDefPct = Math.min(CAP_DEF, dragonDefPct + 0.08); CONFIG.headSpeed *= 0.95; } },

    // --- WEAPONS / DRAGON (20+ Items) ---
    { type: 'wep', name: "Binary Star", desc: "+1 Main Laser Beam", run: () => laserCount++ },
    { type: 'wep', name: "Trinary Star", desc: "+1 Main Laser Beam", run: () => laserCount++ },
    { type: 'wep', name: "Giga Beam", desc: "Lasers 30% Wider", run: () => laserWidthBase += 0.3 },
    { type: 'wep', name: "Rear Guard", desc: "+1 Rear Laser", run: () => laserRear++ },
    { type: 'wep', name: "Tail Gunner", desc: "+1 Rear Laser", run: () => laserRear++ },
    { type: 'wep', name: "Flank Cannons", desc: "+1 Side Laser Pair", run: () => laserSide++ },
    { type: 'wep', name: "Broadside", desc: "+1 Side Laser Pair", run: () => laserSide++ },
    { type: 'wep', name: "Tail Whip", desc: "Tail DMG x5", run: () => tailDmgMult += 5 },
    { type: 'wep', name: "Spiked Tail", desc: "Tail DMG x2, Thorns +20", run: () => { tailDmgMult += 2; thornsDmg += 20; } },
    { type: 'wep', name: "Auto Turret", desc: "Auto-fires at nearest enemy", run: () => autoTurretCount++ },
    { type: 'wep', name: "Twin Turrets", desc: "+1 Auto Turret", run: () => autoTurretCount++ },
    { type: 'wep', name: "Orb Satellite", desc: "+1 Orb / Unlock Orbs", run: () => { orbLevel++; orbStats.count++; } },
    { type: 'wep', name: "Orb Colossus", desc: "Orbs +50% Size & DMG", run: () => { orbStats.size *= 1.5; orbStats.damageMult *= 1.5; } },
    { type: 'wep', name: "Orb Velocity", desc: "Orbs spin 30% faster", run: () => orbStats.speed *= 1.3 },
    { type: 'wep', name: "Plasma Upgrade", desc: "Lasers turn Pink & Penetrate Armor", run: () => laserType = 'plasma' },
    { type: 'wep', name: "Reactor Core", desc: "Burn Aura +10 DMG", run: () => reactorDmg += 10 },
    { type: 'wep', name: "Fusion Core", desc: "Reactor Radius +25%, Dmg +5", run: () => { reactorRadiusMult *= 1.25; reactorDmg += 5; } },
    { type: 'wep', name: "Dragon Breath", desc: "ATK +15%, Laser Width +10%", run: () => { dragonAtk+=0.15; laserWidthBase+=0.1; } },
    { type: 'wep', name: "Sniper Lens", desc: "Crit Chance +5%, Range ++", run: () => critChance = Math.min(CAP_CRIT, critChance + 0.05) },
    { type: 'wep', name: "Hyper Metabolism", desc: "Move Speed +15%", run: () => CONFIG.headSpeed *= 1.15 },
    { type: 'wep', name: "Growth Hormone", desc: "Dragon Size +15%, HP +30%", run: () => { VISUAL_SCALE *= 1.15; updateDragonSize(); dragonMaxHP *= 1.3; dragonHP += dragonMaxHP*0.3; } },
    { type: 'wep', name: "Savage Claws", desc: "ATK +25%", run: () => dragonAtk += 0.25 },
    { type: 'wep', name: "Sharpened Fangs", desc: "Crit Chance +8%", run: () => critChance = Math.min(CAP_CRIT, critChance + 0.08) },


    // --- SPECIAL / UTILITY (10+ Items) ---
    { type: 'abil', name: "Draconic Fury", desc: "Unlock Fury Mode: Dbl DMG", run: () => furyEnabled = true },
    { type: 'abil', name: "Rage Builder", desc: "Fury charges 50% faster", run: () => furyDuration += 60 },
    { type: 'abil', name: "Extended Rage", desc: "Fury lasts 3s longer", run: () => furyDuration += 180 },
    { type: 'abil', name: "Static Field", desc: "Unlock Shockwave / +Dmg", run: () => { shockwaveEnabled = true; shockwaveDmg += 50; } },
    { type: 'abil', name: "Overcharge", desc: "Shockwave triggers 25% faster", run: () => shockwaveInterval *= 0.75 },
    { type: 'abil', name: "Thunderstruck", desc: "Shockwave Stun/Pushback ++", run: () => shockwaveDmg *= 1.3 },
    { type: 'abil', name: "Executioner", desc: "Instantly kill enemies under 5% HP", run: () => executeThreshold = 0.05 },
    { type: 'abil', name: "Grim Reaper", desc: "Execution Threshold -> 10%", run: () => executeThreshold = 0.1 },
    { type: 'abil', name: "Magnetic Soul", desc: "XP Pickup Range +50% XP Gain +10%", run: () => { magnetRange *= 1.5; xpMultiplier += 0.1; } },
    { type: 'abil', name: "Greed", desc: "XP Gain +30%", run: () => xpMultiplier += 0.3 },
    { type: 'abil', name: "Chronos", desc: "Enemies are 10% Slower Globally", run: () => globalSlow *= 0.9 },
    { type: 'abil', name: "Vampirism", desc: "Life Steal +100 HP/Kill", run: () => lifeSteal += 100 },

    // --- CURSED (10+ Items) ---
    { type: 'cursed', name: "Blood Contract", desc: "DMG +80%, Max HP -30%", run: () => { dragonAtk += 0.8; dragonMaxHP *= 0.7; dragonHP = Math.min(dragonHP, dragonMaxHP); } },
   { 
    type: 'cursed', 
    name: "Glass Cannon", 
    desc: "SPD +10%, ATK +100%, Max HP -20%, Take +15% DMG", 
    run: () => { 
        CONFIG.headSpeed *= 1.1;         // +10% move speed
        dragonAtk += 1.0;              // +100% damage
        dragonMaxHP *= 0.8;             // -20% max HP
        dragonHP = Math.min(dragonHP, dragonMaxHP);
        dmgTakenMult *= 1.15;           // take 15% more damage
    } 
},

    { type: 'cursed', name: "Titan's Burden", desc: "HP x2, Speed -40%", run: () => { dragonMaxHP *= 2; dragonHP += dragonMaxHP; CONFIG.headSpeed *= 0.6; } },
    { type: 'cursed', name: "Berserker", desc: "Crit Dmg +100%, Take +20% Dmg", run: () => { critDmg += 1.0; hasBloodLust = true; } },
    { type: 'cursed', name: "Tiny Terror", desc: "Size +10%, Dodge +7%", run: () => { VISUAL_SCALE *= 1.1; updateDragonSize(); dodgeChance = Math.min(CAP_DODGE, dodgeChance + 0.7); } },
    { type: 'cursed', name: "Void Walker", desc: "Global Slow 30%, Decay 5 HP/frame", run: () => { globalSlow *= 0.7; dragonRegen -= 5; } },
    { type: 'cursed', name: "Overload", desc: "Shockwave Instant, HP -40%", run: () => { shockwaveInterval = 40; dragonMaxHP *= 0.6; dragonHP = Math.min(dragonHP, dragonMaxHP); } },
    { type: 'cursed', name: "Chaos Prism", desc: "+5 Random Lasers, Accuracy -80%", run: () => { laserCount += 5; /* Visual spread logic handles accuracy */ } },
    { type: 'cursed', name: "Death Wish", desc: "XP +100%, Enemies +50% HP", run: () => { xpMultiplier += 1.0; /* Logic in enemy spawn */ } },
    { type: 'cursed', name: "Lead Boots", desc: "Knockback +200%, Move Speed -20%", run: () => { knockbackStr += 2.0; CONFIG.headSpeed *= 0.8; } },
    { type: 'cursed', name: "Sacrificial Lamb", desc: "Heal to Full, Max HP -20%", run: () => { dragonHP = dragonMaxHP; dragonMaxHP *= 0.8; dragonHP = Math.min(dragonHP, dragonMaxHP); } }
];

function updateDragonSize() {
    CONFIG.segmentDist = 8 * VISUAL_SCALE;
    CONFIG.maxRibWidth = 42 * VISUAL_SCALE;
    CONFIG.upperLegLen = 75 * VISUAL_SCALE;
    CONFIG.lowerLegLen = 85 * VISUAL_SCALE;
    CONFIG.wingSpan = 340 * VISUAL_SCALE;
}

// --- CLASSES ---

class FloatingText {
    constructor(x, y, text, color, size) {
        this.x = x + (Math.random()-0.5)*20;
        this.y = y;
        this.text = text;
        this.color = color;
        this.life = 60;
        this.size = size;
        this.vy = -1;
    }
    update() {
        this.y += this.vy;
        this.life--;
        return this.life > 0;
    }
    draw() {
        ctx.globalAlpha = Math.max(0, this.life / 20);
        ctx.fillStyle = this.color;
        ctx.font = `bold ${this.size}px monospace`;
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1.0;
    }
}

class ExpGem {
    constructor(x, y, val) { this.x = x; this.y = y; this.val = val; }
    update() {
        const head = spine[0];
        const d = Math.hypot(head.x - this.x, head.y - this.y);
        // Magnetic range
        if (d < 400 * G_SCALE * magnetRange) { 
            const a = Math.atan2(head.y - this.y, head.x - this.x);
            this.x += Math.cos(a) * (25 * G_SCALE); this.y += Math.sin(a) * (25 * G_SCALE);
        }
        if (d < 60 * G_SCALE) {
            exp += this.val * xpMultiplier;
            if (furyEnabled && !furyActive) furyMeter = Math.min(100, furyMeter + 1);
            if (exp >= expNext) levelUp();
            return true;
        }
        return false;
    }
    draw() {
        ctx.fillStyle = COLORS.glow; ctx.shadowBlur = 10; ctx.shadowColor = COLORS.glow;
        ctx.beginPath(); ctx.arc(this.x, this.y, 6 * G_SCALE, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
    }
}

class EnemyProjectile {
    constructor(x, y, angle, type = 'normal') {
        this.x = x; this.y = y;
        this.vx = Math.cos(angle) * (6 * G_SCALE); 
        this.vy = Math.sin(angle) * (6 * G_SCALE);
        this.radius = 8 * G_SCALE;
        this.type = type;
        this.dmg = type === 'sniper' ? 100 : 30;
        if(type === 'boss') { this.radius = 20 * G_SCALE; this.dmg = 150; }
        if(type === 'web') { this.radius = 12 * G_SCALE; this.dmg = 20; }
    }
    update() {
        this.x += this.vx * globalSlow; this.y += this.vy * globalSlow;
        
        const head = spine[0];
        const center = spine[Math.floor(spine.length/2)];
        
        const hitHead = Math.hypot(this.x - head.x, this.y - head.y) < (40 * VISUAL_SCALE);
        const hitBody = Math.hypot(this.x - center.x, this.y - center.y) < (50 * VISUAL_SCALE);
        
        if (hitHead || hitBody) {
            takeDamage(this.dmg); 
            // Web effect?
            return true; 
        }
        return (this.x < -100 || this.x > width+100 || this.y < -100 || this.y > height+100);
    }
    draw() {
        ctx.fillStyle = this.type === 'boss' ? "#ff00ff" : "#ff3300"; 
        if(this.type === 'web') ctx.fillStyle = "#fff";
        ctx.shadowBlur = 10; ctx.shadowColor = "red";
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
    }
}

class Enemy {
    constructor(type, waveNum) {
        const side = Math.random() > 0.5;
        this.x = side ? -100 : width + 100;
        this.y = Math.random() * height;
        this.type = type;
        this.angle = 0;
        this.timer = Math.random() * 100;
        this.state = 0; 
        
        const scale = 1 + (waveNum * 0.25); 
        const xpScale = 1 + (waveNum * 0.1);

        // Base Defaults
        let h = 100, s = 1.0, r = 20, x = 10, boss = false;

        switch(type) {
            // -- TIER 1: FODDER --
            case 'swarmer': h=50; s=3.0; r=12; x=15; break;
            case 'fly': h=30; s=4.0; r=10; x=10; break;
            case 'blob': h=150; s=0.8; r=25; x=20; break;
            case 'mite': h=60; s=2.5; r=15; x=15; break;
            // New T1
            case 'spore': h=40; s=1.5; r=12; x=15; break; // Floating, slow
            case 'wasp': h=25; s=5.0; r=8; x=15; break; // Super fast, low hp
            
            // -- TIER 2: SOLDIERS --
            case 'grunt': h=300; s=1.2; r=22; x=40; break;
            case 'soldier': h=400; s=1.1; r=25; x=50; break;
            case 'shielded': h=800; s=0.9; r=30; x=70; break; 
            case 'lancer': h=250; s=2.0; r=18; x=55; break; 
            // New T2
            case 'brute': h=600; s=0.8; r=28; x=60; break;
            case 'zealot': h=200; s=3.5; r=20; x=60; break; // Suicide runner

            // -- TIER 3: RANGED --
            case 'shooter': h=350; s=0.9; r=25; x=80; break;
            case 'sniper': h=250; s=0.7; r=20; x=120; break; 
            case 'gunner': h=400; s=0.8; r=28; x=90; break;
            case 'mortar': h=500; s=0.5; r=35; x=100; break;
            // New T3
            case 'hunter': h=300; s=1.2; r=22; x=90; break; // Moves and shoots
            case 'webber': h=400; s=0.8; r=30; x=100; break; // Shoots slowing webs

            // -- TIER 4: SPECIALIST --
            case 'dasher': h=200; s=1.5; r=18; x=60; break; 
            case 'weaver': h=220; s=2.2; r=18; x=65; break; 
            case 'glitch': h=450; s=1.6; r=22; x=110; break; 
            case 'phantom': h=350; s=1.4; r=25; x=110; break; 
            case 'healer': h=600; s=1.0; r=30; x=150; break; 
            case 'summoner': h=500; s=0.6; r=35; x=160; break; 
            // New T4
            case 'stalker': h=400; s=2.0; r=20; x=120; break; // Invisible until close
            case 'engineer': h=500; s=0.8; r=25; x=140; break; // Builds turrets (simulated)
            
            // -- TIER 5: HEAVY --
            case 'tank': h=2000; s=0.6; r=45; x=250; break;
            case 'golem': h=5000; s=0.3; r=60; x=600; break;
            case 'construct': h=3000; s=0.4; r=55; x=400; break;
            case 'barrier': h=2500; s=0.5; r=50; x=300; break;
            // New T5
            case 'monolith': h=6000; s=0.2; r=70; x=500; break;
            case 'fortress': h=4000; s=0.4; r=60; x=450; break;

            // -- MINI BOSSES (New) --
            case 'mini_slayer': h=12000; s=1.3; r=40; x=2000; boss=true; break;
            case 'mini_beholder': h=10000; s=0.8; r=50; x=2000; boss=true; break;

            // -- TIER 6: ELITE/BOSSES --
            case 'elite_knight': h=15000; s=1.2; r=45; x=3000; boss=true; break;
            case 'elite_mage': h=12000; s=0.8; r=40; x=3000; boss=true; break;
            case 'boss_hydra': h=25000; s=0.5; r=90; x=5000; boss=true; break;
            case 'boss_titan': h=60000; s=0.3; r=120; x=8000; boss=true; break;
            case 'boss_ufo': h=30000; s=1.5; r=60; x=6000; boss=true; break;
            
            // -- WEIRD TYPES --
            case 'nova': h=150; s=5.5; r=15; x=50; break; 
            case 'splitter': h=600; s=1.0; r=30; x=100; break; 
            case 'vampire': h=700; s=2.0; r=20; x=200; break; 
            case 'reflector': h=1500; s=0.8; r=40; x=300; break; 
            case 'assassin': h=400; s=3.5; r=20; x=250; break; 
            case 'pulsar': h=1200; s=1.1; r=35; x=300; break; 
            case 'crystal': h=1000; s=0.0; r=30; x=180; break; 
            case 'spiker': h=300; s=4.0; r=15; x=70; break;
        }

        // Apply Death Wish Curse Scaling
        let curseHP = UPGRADES.find(u => u.name === "Death Wish" && hasBloodLust); 
        // Simple check if user picked it? No, checking logic inside update
        // We will just scale base stats here
        
        this.hp = h * scale;
        this.maxHp = this.hp;
        this.speed = s * G_SCALE; 
        this.radius = r * G_SCALE; 
        this.xp = Math.floor(x * xpScale);
        this.isBoss = boss;
        this.maxSpeed = this.speed;
    }

    update() {
        const head = spine[0];
        let targetX = head.x;
        let targetY = head.y;

        const dist = Math.hypot(targetX - this.x, targetY - this.y);
        const angleToPlayer = Math.atan2(targetY - this.y, targetX - this.x);
        this.angle += 0.05;
        this.timer++;

        let moveSpeed = this.speed * globalSlow;
        let mx = Math.cos(angleToPlayer);
        let my = Math.sin(angleToPlayer);

        // --- UNIQUE BEHAVIORS ---
        if (this.type === 'dasher' || this.type === 'assassin' || this.type === 'zealot') {
            if (this.state === 0) { // Moving
                if (this.timer > 100) { this.state = 1; this.timer = 0; }
            } else if (this.state === 1) { // Charging
                moveSpeed = 0;
                this.x += (Math.random()-0.5)*2; 
                this.y += (Math.random()-0.5)*2;
                if (this.timer > 40) { this.state = 2; this.timer = 0; }
            } else if (this.state === 2) { // DASH
                moveSpeed *= 8;
                if (this.timer > 15) { this.state = 0; this.timer = 0; }
            }
        }
        else if (this.type === 'healer') {
            if (this.timer % 60 === 0) {
                enemies.forEach(e => {
                    if (e !== this && Math.hypot(e.x - this.x, e.y - this.y) < 300 * G_SCALE) {
                        e.hp = Math.min(e.maxHp, e.hp + 100);
                        ctx.strokeStyle = "#0f0"; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(e.x, e.y); ctx.stroke();
                    }
                });
            }
        }
        else if (this.type === 'summoner') {
            if (dist > 400 * G_SCALE) moveSpeed *= 1; 
            else moveSpeed = -0.5 * G_SCALE; // Back away
            if (this.timer > 200) {
                this.timer = 0;
                enemies.push(new Enemy('swarmer', wave));
            }
        }
        else if (['shooter', 'sniper', 'boss_ufo', 'webber', 'hunter'].includes(this.type)) {
            let keepDist = (this.type === 'sniper' ? 600 : 350) * G_SCALE;
            if (dist > keepDist + 50) { /* move forward */ } 
            else if (dist < keepDist - 50) { mx *= -1; my *= -1; } 
            else { mx = 0; my = 0; }
            
            let fireRate = this.type === 'sniper' ? 220 : 120;
            if (this.timer > fireRate) {
                let pType = this.type === 'boss_ufo' ? 'boss' : (this.type==='sniper'?'sniper': (this.type==='webber'?'web':'normal'));
                enemyProjectiles.push(new EnemyProjectile(this.x, this.y, angleToPlayer, pType));
                this.timer = 0;
            }
        }

        this.x += mx * moveSpeed;
        this.y += my * moveSpeed;

        // Player Collision Damage
        let hit = false;
        let points = [0, Math.floor(spine.length/2), spine.length-1];
        
        for(let idx of points) {
            let seg = spine[idx];
            if (Math.hypot(this.x - seg.x, this.y - seg.y) < this.radius + (20 * VISUAL_SCALE)) {
                hit = true;
                // Tail Whip Logic
                if (idx === spine.length-1 && tailDmgMult > 1.0) {
                    this.takeDamage(20 * dragonAtk * tailDmgMult, false);
                    // Knockback
                    let push = 50 * knockbackStr;
                    this.x -= mx * push; this.y -= my * push;
                }
                break;
            }
        }

        if (hit) {
            let baseDmg = 5;
            if(this.type.includes('boss') || this.type === 'golem') baseDmg = 50;
            if(this.type === 'zealot' || this.type === 'nova') { 
                baseDmg = 80; 
                this.hp = 0; // Suicide
                if (this.type === 'nova') {
                     for(let k=0; k<8; k++) enemyProjectiles.push(new EnemyProjectile(this.x, this.y, k * (Math.PI/4)));
                }
            }
            
            takeDamage(baseDmg);
            if(thornsDmg > 0) this.takeDamage(thornsDmg, false);
        }
        
        // Reactor Core Passive
        if (reactorDmg > 0) {
            if (dist < 200 * VISUAL_SCALE * reactorRadiusMult) { 
                this.takeDamage(reactorDmg * dragonAtk * 0.1, true); 
            }
        }

        // Mouse Lasers
        if (mouse.down || autoTurretCount > 0) {
            if (mouse.down) {
                checkLaserHit(this, head, laserCount, 0); 
                if(laserRear > 0) checkLaserHit(this, head, laserRear, Math.PI); 
                if(laserSide > 0) {
                    checkLaserHit(this, head, laserSide, Math.PI/2); 
                    checkLaserHit(this, head, laserSide, -Math.PI/2);
                }
            }
            // Auto Turret hits are checked via logic in Main Loop usually, but here:
            if (autoTurretCount > 0) {
                 // Simplification: Check distance, if close enough, apply DoT
                 if (dist < 600 * G_SCALE) {
                     this.takeDamage(3 * dragonAtk * autoTurretCount * 0.1, true); // DoT style for turret
                 }
            }
        }
    }

    takeDamage(amount, isDoT = false) {
        if (furyActive) amount *= 2;
        
        let isCrit = false;
        if (!isDoT && Math.random() < critChance) {
            amount *= critDmg;
            isCrit = true;
        }

        this.hp -= amount;

        // Execute Logic
        if (executeThreshold > 0 && this.hp < this.maxHp * executeThreshold && !this.isBoss) {
            this.hp = -1;
            damageNumbers.push(new FloatingText(this.x, this.y, "EXECUTE", "#ff0000", 30));
        }

        if (!isDoT || frame % 10 === 0) {
            let color = isCrit ? "#ffcc00" : "#fff";
            let size = isCrit ? 24 : 14;
            if (amount > 1) damageNumbers.push(new FloatingText(this.x, this.y, Math.floor(amount), color, size));
        }
        
        if (this.type === 'splitter' && this.hp <= 0 && this.radius > 10 * G_SCALE) {
             for(let k=0; k<2; k++) {
                 let baby = new Enemy('swarmer', wave);
                 baby.x = this.x + (Math.random()-0.5)*20;
                 baby.y = this.y + (Math.random()-0.5)*20;
                 enemies.push(baby);
             }
        }
    }

    draw() {
        if (this.x < -200 || this.x > width+200 || this.y < -200 || this.y > height+200) return; 

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(G_SCALE, G_SCALE); 

        // HP Bar
        const barW = this.isBoss ? 100 : 40;
        if (!this.isBoss) { 
            ctx.fillStyle = "red"; ctx.fillRect(-barW/2, -this.radius/G_SCALE - 15, barW, 4);
            ctx.fillStyle = "#0f0"; ctx.fillRect(-barW/2, -this.radius/G_SCALE - 15, barW * (Math.max(0, this.hp)/this.maxHp), 4);
        }

        let col = "#ff5500";
        if(this.type.includes('boss')) col = "#ff0000";
        if(this.type.includes('mini')) col = "#aa00aa";
        if(this.type === 'healer') col = "#00ff00";
        if(this.type === 'tank' || this.type === 'monolith') col = "#444";
        if(this.type === 'glitch') col = Math.random()>0.5 ? "#fff" : "#000";
        if(this.type === 'webber') col = "#ccc";

        ctx.rotate(this.angle);
        
        ctx.fillStyle = col;
        // Shape Variation
        if (['swarmer', 'fly', 'mite', 'nova', 'wasp'].includes(this.type)) {
            ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(-10, 10); ctx.lineTo(-10, -10); ctx.fill();
        } else if (['tank', 'golem', 'construct', 'monolith', 'fortress'].includes(this.type)) {
            ctx.fillRect(-25, -25, 50, 50);
            ctx.strokeStyle = "white"; ctx.strokeRect(-25,-25,50,50);
        } else if (this.isBoss) {
            ctx.beginPath(); 
            for(let i=0; i<8; i++) { ctx.rotate(Math.PI/4); ctx.rect(-40, -40, 80, 80); }
            ctx.fill();
            ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(0,0,30,0,Math.PI*2); ctx.fill();
        } else if (['spore', 'pulsar'].includes(this.type)) {
             ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.fill();
             ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.fill();
        } else {
            ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.fill();
            ctx.strokeStyle = "black"; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(15,0); ctx.stroke();
        }

        ctx.restore();
    }
}

class Projectile {
    constructor(x, y, angle, speed) {
        this.x = x; this.y = y; 
        this.vx = Math.cos(angle)*speed; 
        this.vy = Math.sin(angle)*speed;
        this.pen = orbStats.pen;
        this.dmg = 40 * dragonAtk * orbStats.damageMult;
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            if (Math.hypot(this.x - e.x, this.y - e.y) < e.radius + (15 * G_SCALE)) {
                e.takeDamage(this.dmg);
                this.pen--;
                ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(this.x,this.y, 5, 0, Math.PI*2); ctx.fill();
                if (this.pen <= 0) return true; 
            }
        }
        return (this.x < -100 || this.x > width+100 || this.y < -100 || this.y > height+100);
    }
    draw() {
        ctx.fillStyle = COLORS.glow; ctx.shadowBlur = 10; ctx.shadowColor = COLORS.glow;
        ctx.beginPath(); ctx.arc(this.x, this.y, orbStats.size, 0, Math.PI*2); ctx.fill();
    }
}

// --- CORE LOGIC ---
function takeDamage(amount) {
    if (Math.random() < dodgeChance) {
        damageNumbers.push(new FloatingText(spine[0].x, spine[0].y, "DODGE", "#00ffcc", 20));
        return; 
    }
    
    if (hasBloodLust) amount *= 1.3;

    // Defense Cap 50%
    let mitigation = Math.min(CAP_DEF, dragonDefPct);
    amount *= (1 - mitigation);
    
    if (dragonShield > 0) {
        if (dragonShield >= amount) { dragonShield -= amount; amount = 0; } 
        else { amount -= dragonShield; dragonShield = 0; }
        shieldCooldown = 180;
    }
    
    if (amount > 0) {
        dragonHP -= amount;
        ctx.fillStyle = "rgba(255,0,0,0.3)"; ctx.fillRect(0,0,width,height); 
    }
}

function checkLaserHit(enemy, head, count, angleOffset) {
    const spread = 0.15;
    const totalSpread = spread * (count - 1);
    const startAngle = (head.angle + angleOffset) - (totalSpread / 2);

    const range = Math.hypot(width, height) * 1.5; 
    const laserPhysWidth = (20 * VISUAL_SCALE * laserWidthBase) + enemy.radius; 

    for(let i=0; i<count; i++) {
        const beamAngle = startAngle + (i * spread);
        const p1 = { x: head.x, y: head.y };
        const p2 = { x: head.x + Math.cos(beamAngle) * range, y: head.y + Math.sin(beamAngle) * range };

        const l2 = (p1.x - p2.x)**2 + (p1.y - p2.y)**2;
        let t = ((enemy.x - p1.x) * (p2.x - p1.x) + (enemy.y - p1.y) * (p2.y - p1.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        const distSq = (enemy.x - (p1.x + t * (p2.x - p1.x)))**2 + (enemy.y - (p1.y + t * (p2.y - p1.y)))**2;
        
        if (distSq < laserPhysWidth * laserPhysWidth) {
            let mult = 1.0;
            if (hasBloodLust) {
                let missingPct = (dragonMaxHP - dragonHP) / dragonMaxHP; 
                mult += (missingPct * 100) * 0.015; 
            }

            enemy.takeDamage(6 * dragonAtk * mult);
            break; 
        }
    }
}

function levelUp() {
    isPaused = true;
    exp -= expNext;
    expNext = Math.floor(expNext * 1.2) + 500; 
    level++;
    dragonHP = Math.min(dragonMaxHP, dragonHP + (dragonMaxHP * 0.3));
    
    upgradeChoices = [];
    let pool = [...UPGRADES];
    while(upgradeChoices.length < 3 && pool.length > 0) {
        let idx = Math.floor(Math.random() * pool.length);
        upgradeChoices.push(pool[idx]);
        pool.splice(idx, 1);
    }
    
    const cardW = 300 * G_SCALE * 1.5; 
    const cardH = 400 * G_SCALE * 1.5; 
    const gap = 40 * G_SCALE;
    const totalW = (cardW * 3) + (gap * 2);
    const startX = (width - totalW) / 2;
    
    cardBounds = upgradeChoices.map((_, i) => ({
        x: startX + i * (cardW + gap), 
        y: height/2 - (200 * G_SCALE), 
        w: cardW, 
        h: cardH
    }));
}

function selectUpgrade(index) {
    upgradeChoices[index].run();
    isPaused = false;
}

function spawnWave() {
    wave++;
    const count = 10 + Math.floor(wave * 3);
    
    const types = [];
    types.push('swarmer', 'fly', 'mite', 'spore', 'wasp');
    
    if (wave > 2) types.push('nova', 'spiker', 'blob', 'brute');
    if (wave > 4) types.push('grunt', 'lancer', 'dasher', 'zealot');
    if (wave > 6) types.push('shooter', 'weaver', 'splitter', 'hunter');
    if (wave > 8) types.push('sniper', 'shielded', 'healer', 'webber');
    if (wave > 10) types.push('tank', 'phantom', 'summoner', 'stalker');
    if (wave > 15) types.push('assassin', 'vampire', 'reflector', 'engineer');
    if (wave > 20) types.push('golem', 'construct', 'pulsar', 'monolith');

    // Mini Bosses
    if (wave % 3 === 0 && wave % 5 !== 0) enemies.push(new Enemy(Math.random()>0.5?'mini_slayer':'mini_beholder', wave));

    // Major Bosses
    if (wave % 5 === 0) enemies.push(new Enemy(wave % 10 === 0 ? 'boss_titan' : 'boss_hydra', wave));
    if (wave % 8 === 0) enemies.push(new Enemy('boss_ufo', wave));
    if (wave > 12 && wave % 4 === 0) enemies.push(new Enemy('elite_knight', wave));

    for (let i=0; i<count; i++) {
        let t = types[Math.floor(Math.random() * types.length)];
        enemies.push(new Enemy(t, wave));
    }
}

// --- VISUALS ---
function drawLaserFan(head, count, angleOffset, colorOverride) {
    const spread = 0.15;
    const totalSpread = spread * (count - 1);
    const startAngle = (head.angle + angleOffset) - (totalSpread / 2);
    
    ctx.shadowBlur = furyActive ? 50 : 35; 
    ctx.shadowColor = furyActive ? COLORS.fury : (laserType === 'plasma' ? COLORS.plasma : COLORS.laser);
    ctx.strokeStyle = colorOverride || (furyActive ? COLORS.fury : (laserType === 'plasma' ? COLORS.plasma : COLORS.laser));
    ctx.lineWidth = 10 * VISUAL_SCALE * laserWidthBase;

    for(let i=0; i<count; i++) {
        const a = startAngle + (i * spread);
        const startX = head.x + Math.cos(a)*45*VISUAL_SCALE;
        const startY = head.y + Math.sin(a)*45*VISUAL_SCALE;
        const range = Math.max(width, height) * 1.5;
        ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX+Math.cos(a)*range, startY+Math.sin(a)*range); ctx.stroke();
    }
}

function drawLasers(head) {
    if (!mouse.down && autoTurretCount === 0) return;
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    
    if (mouse.down) {
        drawLaserFan(head, laserCount, 0); 
        if(laserRear > 0) drawLaserFan(head, laserRear, Math.PI); 
        if(laserSide > 0) {
            drawLaserFan(head, laserSide, Math.PI/2); 
            drawLaserFan(head, laserSide, -Math.PI/2);
        }
    }
    
    if (autoTurretCount > 0) {
        let nearest = null;
        let minD = Infinity;
        enemies.forEach(e => {
            let d = Math.hypot(e.x - head.x, e.y - head.y);
            if(d < minD) { minD = d; nearest = e; }
        });
        
        if (nearest && minD < 600 * G_SCALE) {
            ctx.shadowBlur = 10; ctx.strokeStyle = "#ff00ff"; ctx.lineWidth = 5 * VISUAL_SCALE;
            ctx.beginPath(); ctx.moveTo(head.x, head.y); ctx.lineTo(nearest.x, nearest.y); ctx.stroke();
        }
    }

    ctx.restore();
}

function drawShockwave(spine) {
    if(!shockwaveEnabled) return;
    if(shockwaveActiveFrame > 0) {
        const center = spine[Math.floor(spine.length/2)];
        ctx.save();
        ctx.strokeStyle = COLORS.shockwave;
        ctx.lineWidth = 5 + (shockwaveActiveFrame);
        ctx.globalAlpha = shockwaveActiveFrame / 10;
        ctx.beginPath();
        ctx.arc(center.x, center.y, shockwaveRange, 0, Math.PI*2);
        ctx.stroke();
        ctx.fillStyle = "rgba(255, 255, 0, 0.2)";
        ctx.fill();
        ctx.restore();
        shockwaveActiveFrame--;
    }
}

function drawShield(head) {
    if(dragonShield > 0) {
        ctx.save();
        ctx.strokeStyle = COLORS.shield;
        ctx.lineWidth = 3;
        ctx.shadowBlur = 10; ctx.shadowColor = "cyan";
        ctx.beginPath();
        ctx.arc(head.x, head.y, 60 * VISUAL_SCALE, 0, Math.PI*2);
        ctx.stroke();
        ctx.globalAlpha = 0.1;
        ctx.fillStyle = COLORS.shield;
        ctx.fill();
        ctx.restore();
    }
}

function drawDragonBone(x1, y1, x2, y2, thickness, isWing = false) {
    const dist = Math.hypot(x2 - x1, y2 - y1);
    const angle = Math.atan2(y2 - y1, x2 - x1);
    ctx.save();
    ctx.translate(x1, y1); ctx.rotate(angle);
    ctx.fillStyle = isWing ? "rgba(0, 150, 255, 0.25)" : (furyActive ? "#330000" : COLORS.bone);
    ctx.strokeStyle = furyActive ? "#ff3300" : COLORS.accent;
    ctx.shadowBlur = furyActive ? 15 : 0;
    ctx.shadowColor = "red";
    
    ctx.beginPath();
    ctx.moveTo(0, -thickness * 0.7);
    ctx.quadraticCurveTo(dist / 2, -thickness * 0.2, dist, -thickness * 0.7);
    ctx.lineTo(dist, thickness * 0.7);
    ctx.quadraticCurveTo(dist / 2, thickness * 0.2, 0, thickness * 0.7);
    ctx.fill(); ctx.stroke();
    ctx.restore();
}

function drawWings(anchor) {
    const flap = Math.sin(frame * CONFIG.wingFlapSpeed);
    const drawSide = (isLeft) => {
        let side = isLeft ? -1 : 1;
        let a1 = anchor.angle + (side * 1.5) + (flap * 0.2 * side);
        let armLen = CONFIG.wingSpan * 0.35;
        let j1X = anchor.x + Math.cos(a1) * armLen, j1Y = anchor.y + Math.sin(a1) * armLen;
        let a2 = a1 + (0.6 * side) + (flap * 0.1 * side);
        let foreLen = CONFIG.wingSpan * 0.45;
        let j2X = j1X + Math.cos(a2) * foreLen, j2Y = j1Y + Math.sin(a2) * foreLen;
        let fingerPoints = [];
        for (let i = 0; i < 4; i++) {
            let fA = a2 + (0.4 + i * 0.5) * side + (flap * 0.05);
            let fLen = CONFIG.wingSpan * (0.9 - i * 0.15);
            fingerPoints.push({ x: j2X + Math.cos(fA) * fLen, y: j2Y + Math.sin(fA) * fLen });
        }
        ctx.fillStyle = furyActive ? "rgba(255, 0, 0, 0.15)" : "rgba(0, 120, 255, 0.15)";
        ctx.beginPath(); ctx.moveTo(anchor.x, anchor.y); ctx.lineTo(j1X, j1Y); ctx.lineTo(j2X, j2Y);
        fingerPoints.forEach(p => ctx.lineTo(p.x, p.y)); ctx.fill();
        drawDragonBone(anchor.x, anchor.y, j1X, j1Y, 9 * VISUAL_SCALE, true);
        drawDragonBone(j1X, j1Y, j2X, j2Y, 7 * VISUAL_SCALE, true);
        fingerPoints.forEach(p => drawDragonBone(j2X, j2Y, p.x, p.y, 3 * VISUAL_SCALE, true));
    };
    drawSide(true); drawSide(false);
}

function drawDragonHead(s) {
    ctx.save();
    ctx.translate(s.x, s.y); ctx.rotate(s.angle); ctx.scale(VISUAL_SCALE, VISUAL_SCALE);
    ctx.fillStyle = furyActive ? "#330000" : COLORS.bone; 
    ctx.strokeStyle = furyActive ? "#ff0000" : COLORS.accent;
    const drawHorn = (side) => {
        ctx.save(); ctx.beginPath(); ctx.moveTo(-12, side * 8); ctx.quadraticCurveTo(-35, side * 40, -75, side * 35);
        ctx.lineTo(-72, side * 34); ctx.quadraticCurveTo(-32, side * 32, -18, side * 12);
        ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();
    };
    drawHorn(1); drawHorn(-1);
    ctx.beginPath(); ctx.moveTo(-20, -12); ctx.lineTo(12, -18); ctx.lineTo(48, -4);
    ctx.lineTo(50, 0); ctx.lineTo(48, 4); ctx.lineTo(12, 18); ctx.lineTo(-20, 12);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle = furyActive ? "#ff0000" : COLORS.glow; 
    ctx.shadowBlur = 15; ctx.shadowColor = ctx.fillStyle;
    ctx.beginPath(); ctx.arc(15, -8, 4, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(15, 8, 4, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
}

// --- UI ---
function drawUI() {
    canvas.style.cursor = isPaused ? "default" : "none";
    
    // XP Bar (Top)
    ctx.fillStyle = "#111"; ctx.fillRect(0, 0, width, 10);
    ctx.fillStyle = COLORS.glow; ctx.fillRect(0, 0, width * (exp/expNext), 10);
    
    // Stats (Top Left)
    ctx.textAlign = "left";
    ctx.fillStyle = "white"; ctx.font = `bold ${16 * G_SCALE * 1.5}px monospace`;
    ctx.fillText(`LVL ${level} | WAVE ${wave}`, 20, 35);
    ctx.fillText(`ATK ${dragonAtk.toFixed(1)} | DEF ${(dragonDefPct*100).toFixed(0)}%`, 20, 55);
    
    if (furyEnabled) {
        ctx.fillText(`FURY`, 20, 80);
        ctx.fillStyle = "#330000"; ctx.fillRect(70, 68, 100, 12);
        ctx.fillStyle = furyActive ? "#ffff00" : "#ff0000"; ctx.fillRect(70, 68, furyMeter, 12);
        ctx.strokeRect(70, 68, 100, 12);
    }

    // Boss Bar
    let bosses = enemies.filter(e => e.isBoss);
    if (bosses.length > 0) {
        let boss = bosses[0];
        let bw = 600 * G_SCALE;
        let bh = 20;
        let bx = width/2 - bw/2;
        ctx.fillStyle = "#330000"; ctx.fillRect(bx, 50, bw, bh);
        ctx.fillStyle = boss.type.includes('mini') ? "#aa00aa" : "#ff0000"; ctx.fillRect(bx, 50, bw * (boss.hp/boss.maxHp), bh);
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.strokeRect(bx, 50, bw, bh);
        ctx.fillStyle = "#fff"; ctx.textAlign = "center";
        ctx.fillText(boss.type.toUpperCase(), width/2, 45);
    }

    // Player HP Bar
    const barW = 400 * G_SCALE * 1.5; 
    const bx = width/2 - barW/2;
    ctx.fillStyle = "#222"; ctx.fillRect(bx, height - 30, barW, 20);
    const hpPct = Math.max(0, dragonHP/dragonMaxHP);
    ctx.fillStyle = hpPct > 0.3 ? (furyActive ? "#ffaa00" : "lime") : "red";
    ctx.fillRect(bx, height - 30, barW * hpPct, 20);
    ctx.strokeStyle = "#fff"; ctx.strokeRect(bx, height-30, barW, 20);
    ctx.fillStyle = "#fff"; ctx.textAlign = "center"; ctx.fillText(`${Math.floor(dragonHP)}/${Math.floor(dragonMaxHP)}`, width/2, height - 15);
    
    if (dragonShield > 0) {
        const shPct = Math.min(1, dragonShield / dragonMaxShield);
        ctx.fillStyle = "cyan";
        ctx.fillRect(bx, height - 35, barW * shPct, 5);
    }

    if (isPaused) {
        ctx.fillStyle = "rgba(0,0,0,0.85)"; ctx.fillRect(0,0,width,height);
        ctx.textAlign = "center"; 
        
        ctx.fillStyle = COLORS.glow; ctx.font = "bold 40px monospace";
        ctx.shadowBlur = 20; ctx.shadowColor = COLORS.glow;
        ctx.fillText("EVOLUTION", width/2, height/2 - 250);
        ctx.shadowBlur = 0;
        
        upgradeChoices.forEach((c, i) => {
            const b = cardBounds[i];
            let borderColor = COLORS.glow;
            if (c.type === 'cursed') borderColor = COLORS.cursed;
            if (c.type === 'wep') borderColor = COLORS.plasma;
            if (c.type === 'def') borderColor = "#00ff00";
            if (c.type === 'abil') borderColor = "#ffff00";
            
            ctx.fillStyle = "#050a14"; ctx.fillRect(b.x, b.y, b.w, b.h);
            ctx.strokeStyle = borderColor; ctx.lineWidth = 4; ctx.strokeRect(b.x, b.y, b.w, b.h);
            
            let grad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.h);
            grad.addColorStop(0, borderColor);
            grad.addColorStop(1, "transparent");
            ctx.fillStyle = grad; ctx.globalAlpha = 0.1; ctx.fillRect(b.x, b.y, b.w, b.h);
            ctx.globalAlpha = 1.0;

            ctx.fillStyle = borderColor; ctx.font = `bold ${22 * G_SCALE * 1.5}px monospace`; 
            ctx.fillText(c.name, b.x + b.w/2, b.y + 60);
            
            ctx.fillStyle = "white"; ctx.font = `${16 * G_SCALE * 1.5}px monospace`; 
            wrapText(ctx, c.desc, b.x + b.w/2, b.y + 140, b.w - 40, 24);
            
            ctx.fillStyle = borderColor; ctx.font = `bold ${18 * G_SCALE * 1.5}px monospace`;
            ctx.fillText("[ CLICK TO SELECT ]", b.x + b.w/2, b.y + b.h - 40);
        });
    }
}

function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    let words = text.split(' ');
    let line = '';
    for(let n = 0; n < words.length; n++) {
        let testLine = line + words[n] + ' ';
        let metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && n > 0) {
            ctx.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
        } else {
            line = testLine;
        }
    }
    ctx.fillText(line, x, y);
}

// --- MAIN LOOP ---
function update() {
    if (!gameActive || isPaused) return;
    frame++;
    if (enemies.length === 0) spawnWave();
    
    let head = spine[0];
    let speed = mouse.down ? CONFIG.headSpeed * 0.15 : CONFIG.headSpeed;
    if (furyActive) speed *= 1.5;

    head.x += (mouse.x - head.x) * speed;
    head.y += (mouse.y - head.y) * speed;
    head.angle = Math.atan2(mouse.y - head.y, mouse.x - head.x);
    
    // REGEN
    if(frame % 60 === 0) {
        if(dragonHP < dragonMaxHP && dragonRegen > 0) dragonHP += dragonRegen * 60;
        if(shieldCooldown > 0) shieldCooldown--;
        else if(dragonShield < dragonMaxShield) dragonShield += dragonShieldRegen * 60;
    }
    
    // FURY LOGIC
    if (furyEnabled && furyMeter >= 100 && !furyActive) {
        furyActive = true;
        furyTimer = furyDuration;
        shockwaveEnabled = true; 
    }
    if (furyActive) {
        furyTimer--;
        furyMeter = (furyTimer / furyDuration) * 100;
        if (furyTimer <= 0) {
            furyActive = false;
            furyMeter = 0;
        }
    }

    // SHOCKWAVE
    if(shockwaveEnabled) {
        shockwaveTimer++;
        if(shockwaveTimer > (furyActive ? 30 : shockwaveInterval)) { 
            shockwaveTimer = 0;
            shockwaveActiveFrame = 15;
            const midIndex = Math.floor(spine.length/2);
            const center = spine[midIndex];

            enemies.forEach(e => {
                let d = Math.hypot(center.x - e.x, center.y - e.y);
                if(d < shockwaveRange) {
                    e.takeDamage(shockwaveDmg * dragonAtk);
                    let a = Math.atan2(e.y - center.y, e.x - center.x);
                    // Pushback
                    let push = 150 * G_SCALE * knockbackStr;
                    e.x += Math.cos(a) * push; 
                    e.y += Math.sin(a) * push;
                }
            });
        }
    }
    
    // ORBS
    if (mouse.down && orbLevel > 0) {
        const fireRate = Math.max(5, 20 - (orbLevel * 2)); 
        if (frame % fireRate === 0) {
            projectiles.push(new Projectile(head.x, head.y, head.angle, orbStats.speed));
            if (orbLevel >= 3) { 
                projectiles.push(new Projectile(head.x, head.y, head.angle + 0.3, orbStats.speed));
                projectiles.push(new Projectile(head.x, head.y, head.angle - 0.3, orbStats.speed));
            }
        }
    }

    for (let i=1; i<spine.length; i++) {
        let p = spine[i-1], c = spine[i];
        let a = Math.atan2(p.y - c.y, p.x - c.x);
        c.angle = a; c.x = p.x - Math.cos(a)*CONFIG.segmentDist; c.y = p.y - Math.sin(a)*CONFIG.segmentDist;
    }
    
    enemies.forEach((e, i) => {
        e.update();
        if (e.hp <= 0) { 
            score += 10; 
            gems.push(new ExpGem(e.x, e.y, e.xp)); 
            if(lifeSteal > 0) dragonHP = Math.min(dragonMaxHP, dragonHP + lifeSteal);
            if(furyEnabled && !furyActive) furyMeter = Math.min(100, furyMeter + (e.isBoss ? 20 : 2));
            enemies.splice(i, 1); 
        }
    });
    
    damageNumbers = damageNumbers.filter(d => d.update());
    gems = gems.filter(g => !g.update());
    projectiles = projectiles.filter(p => !p.update());
    enemyProjectiles = enemyProjectiles.filter(p => !p.update());
    
    // LEG ANIMATION
    legs.forEach(leg => {
        let body = spine[leg.anchorIndex], side = leg.isLeft ? -1.6 : 1.6;
        let iX = body.x + Math.cos(body.angle + side) * (115 * VISUAL_SCALE), iY = body.y + Math.sin(body.angle + side) * (115 * VISUAL_SCALE);
        if (!leg.isStepping && Math.hypot(iX - leg.x, iY - leg.y) > 95 * VISUAL_SCALE) {
            leg.isStepping = true; leg.stepProgress = 0; leg.stepStartX = leg.x; leg.stepStartY = leg.y;
            leg.targetX = iX + Math.cos(body.angle) * (70 * VISUAL_SCALE); leg.targetY = iY + Math.sin(body.angle) * (70 * VISUAL_SCALE);
        }
        if (leg.isStepping) {
            leg.stepProgress += CONFIG.legSpeed;
            if (leg.stepProgress >= 1) { leg.isStepping = false; leg.x = leg.targetX; leg.y = leg.targetY; }
            else {
                let t = leg.stepProgress;
                leg.x = leg.stepStartX + (leg.targetX - leg.stepStartX) * t; leg.y = leg.stepStartY + (leg.targetY - leg.stepStartY) * t;
                leg.lift = Math.sin(t * Math.PI) * (45 * VISUAL_SCALE);
            }
        }
    });
    
    if (dragonHP <= 0) gameActive = false;
}

function draw() {
    ctx.fillStyle = "#00020a"; ctx.fillRect(0, 0, width, height);
    
    drawLasers(spine[0]);
    drawShockwave(spine);
    
    if (reactorDmg > 0) {
        ctx.beginPath();
        ctx.arc(spine[0].x, spine[0].y, 200 * VISUAL_SCALE * reactorRadiusMult, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(255, 100, 0, 0.1)"; ctx.stroke();
    }

    gems.forEach(g => g.draw());
    projectiles.forEach(p => p.draw());
    enemyProjectiles.forEach(p => p.draw());
    enemies.forEach(e => e.draw());
    damageNumbers.forEach(d => d.draw());
    
    ctx.strokeStyle = COLORS.accent; ctx.lineWidth = 1;
    drawWings(spine[CONFIG.wingAttachment]);
    spine.forEach((s, i) => {
        let ribStart = 10, ribEnd = 50, ribSpan = ribEnd - ribStart;
        let ribW = (i > ribStart && i < ribEnd) ? Math.sin((i-ribStart)/ribSpan*Math.PI)*CONFIG.maxRibWidth : 0;
        if (ribW > 0) {
            let p = s.angle + Math.PI/2;
            ctx.beginPath(); ctx.moveTo(s.x + Math.cos(p)*ribW, s.y + Math.sin(p)*ribW);
            ctx.quadraticCurveTo(s.x - Math.cos(s.angle)*15*VISUAL_SCALE, s.y - Math.sin(s.angle)*15*VISUAL_SCALE, s.x - Math.cos(p)*ribW, s.y - Math.sin(p)*ribW);
            ctx.stroke();
        }
        if (i > 0) {
            ctx.lineWidth = i < 40 ? 5 * VISUAL_SCALE : 2 * VISUAL_SCALE;
            ctx.strokeStyle = furyActive ? "#ff3300" : COLORS.accent;
            ctx.beginPath(); ctx.moveTo(spine[i - 1].x, spine[i - 1].y); ctx.lineTo(s.x, s.y); ctx.stroke();
        }
    });
    
    drawShield(spine[0]); 
    
    legs.forEach(leg => {
        let body = spine[leg.anchorIndex], hSide = leg.isLeft ? -1.5 : 1.5;
        let hX = body.x + Math.cos(body.angle + hSide) * (25 * VISUAL_SCALE), hY = body.y + Math.sin(body.angle + hSide) * (25 * VISUAL_SCALE);
        let dx = leg.x - hX, dy = (leg.y - leg.lift) - hY;
        let dist = Math.min(Math.sqrt(dx * dx + dy * dy), CONFIG.upperLegLen + CONFIG.lowerLegLen - 2);
        let a = Math.atan2(dy, dx), cos = (CONFIG.upperLegLen**2 + dist**2 - CONFIG.lowerLegLen**2) / (2 * CONFIG.upperLegLen * dist);
        let kneeA = leg.isLeft ? a + Math.acos(Math.max(-1, Math.min(1, cos))) : a - Math.acos(Math.max(-1, Math.min(1, cos)));
        let kX = hX + Math.cos(kneeA) * CONFIG.upperLegLen, kY = hY + Math.sin(kneeA) * CONFIG.upperLegLen;
        drawDragonBone(hX, hY, kX, kY, 8 * VISUAL_SCALE); drawDragonBone(kX, kY, leg.x, leg.y - leg.lift, 6 * VISUAL_SCALE);
    });
    drawDragonHead(spine[0]);
    
    drawUI();
    
    if (!gameActive) {
        ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(0,0,width,height);
        ctx.fillStyle = "white"; ctx.textAlign = "center"; ctx.font = "50px monospace";
        ctx.fillText("GAME OVER", width/2, height/2);
        ctx.font = "20px monospace";
        ctx.fillText(`Max Level: ${level} | Wave: ${wave}`, width/2, height/2 + 50);
        ctx.fillText("Refresh to restart", width/2, height/2 + 80);
    }
}

function init() {
    resize();
    spine = [];
    for (let i = 0; i < CONFIG.segmentCount; i++) spine.push({ x: mouse.x, y: mouse.y, angle: 0 });
    legs = [
        { anchorIndex: 18, isLeft: true, x: 0, y: 0 }, { anchorIndex: 18, isLeft: false, x: 0, y: 0 },
        { anchorIndex: 50, isLeft: true, x: 0, y: 0 }, { anchorIndex: 50, isLeft: false, x: 0, y: 0 }
    ];
    loop();
}

function resize() { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('mousedown', () => {
    if (isPaused) {
        cardBounds.forEach((b, i) => {
            if (mouse.x > b.x && mouse.x < b.x + b.w && mouse.y > b.y && mouse.y < b.y + b.h) {
                selectUpgrade(i);
            }
        });
    } else { mouse.down = true; }
});
window.addEventListener('mouseup', () => mouse.down = false);
function loop() { update(); draw(); requestAnimationFrame(loop); }
init();
