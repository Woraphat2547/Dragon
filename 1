const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let width, height;
let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2, down: false };
let frame = 0;

// --- GLOBAL SCALING ---
const G_SCALE = 0.5;

// --- THEME & COLORS ---
const COLORS = {
    bone: "#001a4d", accent: "#0066ff", glow: "#00ffff", laser: "#ccf2ff",
    plasma: "#ff00ff", void: "#5500aa", holy: "#ffdd00", enemyProj: "#ff3333", 
    shield: "rgba(0, 255, 255, 0.3)", shockwave: "rgba(255, 255, 0, 0.4)", 
    bossBar: "#ff0000", fury: "#ff3300", cursed: "#800080",
    common: "#b0b0b0", rare: "#0088ff", epic: "#9900ff", legendary: "#ffaa00", mythic: "#00ffcc"
};

// --- GAME STATE ---
let dragonHP = 22000;
let dragonMaxHP = 22000;
let dragonShield = 0;
let dragonMaxShield = 0;
let dragonShieldRegen = 0;
let shieldCooldown = 0;

// --- CAPS & CONFIG ---
const CAP_DEF = 0.5; 
const CAP_DODGE = 0.30; 
const CAP_CRIT_DMG = 4.0;
const CAP_CRIT_CHANCE = 1.0;
const BASE_VISUAL_SCALE = 0.6 * G_SCALE;

const MAX_LASER_MAIN = 12;
const MAX_LASER_SIDE = 8;
const MAX_LASER_REAR = 6;

// --- STATS ---
let dragonDefPct = 0;
let dragonBaseAtk = 1; 
let dragonAtk = 1;
let dragonRegen = 0.2;
let xpMultiplier = 1.0;
let lifeSteal = 0;
let dodgeChance = 0;
let globalSlow = 1.0;
let tailDmgMult = 1.0;
let critChance = 0.05;
let critDmg = 1.5;
let thornsDmg = 0;
let knockbackStr = 1.0;
let executeThreshold = 0;
let dmgTakenMult = 1.0;
let laserDmgMult = 1.0;
let fireRateMult = 1.0;
let moveSpeedMult = 1.0; // New movement speed multiplier

// --- METERS & SPECIAL MECHANICS ---
// 1. SHIELD
let unlockedShield = false;
let shieldExplode = false;
let shieldAmpDmg = false;
let shieldAmpFire = false;
let shieldStunBreak = false;

// 2. FURY
let unlockedFury = false;
let furyEnabled = false;
let furyMeter = 0;
let furyActive = false;
let furyTimer = 0;
let furyDuration = 600;
let furyExplosion = false;
let furyInvuln = false;
let furyRegenPassive = 0; 
let furyIgnition = false;
let furyEndExplosion = false;

// 3. GHOST
let unlockedGhost = false;
let ghostActive = false; 
let ghostMeter = 0; 
let ghostMaxMeter = 100;
let ghostRegen = 0;
let ghostDmg = 0;
let ghostPhaseShift = false;
let ghostEcto = false;

// 4. VOID (New)
let unlockedVoid = false;
let voidEnabled = false;
let voidMeter = 0;
let voidActive = false;
let voidTimer = 0;
let voidDuration = 400; // shorter duration
let voidPullStrength = 0;
let voidDmgAura = 0;

// 5. HOLY (New)
let unlockedHoly = false;
let holyEnabled = false;
let holyMeter = 0;
let holyActive = false;
let holyTimer = 0;
let holyDuration = 500;
let holyHealTick = 0;
let holySmiteChance = 0;

// OVERLOAD BUFF (Active when any meter triggers)
let overloadActive = false;
let overloadTimer = 0;

// WEAPONS
let unlockedOrbs = false; // "Orb" (Long Range)
let unlockedShort = false; // "Spark" (Short Range, High Dmg)
let unlockedMid = false; // "Bolt" (Mid Range)

let unlockedMissiles = false;
let unlockedMines = false;
let unlockedSaw = false;
let sawCount = 0;
let unlockedBoomerang = false; 
let boomerangCount = 0;
let unlockedGrenade = false;
let grenadeCount = 0;
let grenadeCluster = false;
let grenadeNapalm = false;

// Utils
let autoTurretCount = 0;
let magnetRange = 1.0;
let hasBloodLust = false;
let reviveCount = 0;
let revivePenaltyStacks = 0; // For Phoenix Soul penalty
let timeStopChance = 0;
let timeStopActive = false;
let timeStopTimer = 0;
let chainLightningChance = 0;
let missileCount = 0;

// Status Effect Chances
let poisonChance = 0;
let burnChance = 0;
let freezeChance = 0;
let weakChance = 0; 
let vulnChance = 0;

// Special Toggles
let tailTurret = false;
let discoMode = false;
let gamblerMode = false;
let gamblerTimer = 0;

// Shockwave
let shockwaveEnabled = false;
let shockwaveTimer = 0;
let shockwaveInterval = 180;
let shockwaveRange = 300 * G_SCALE;
let shockwaveDmg = 50;
let shockwaveActiveFrame = 0;

// Progression
let level = 1;
let exp = 0;
let expNext = 550;
let wave = 0;
let score = 0;
let gameActive = true;
let isPaused = false;
let canReroll = false;

// Weapons Config
let laserCount = 1;
let laserWidthBase = 1;
let laserRear = 0;
let laserSide = 0;
let laserType = 'normal'; // normal, plasma, void, shotgun

// Projectile Stats
let orbLevel = 0;
let orbStats = { speed: 8 * G_SCALE, size: 10 * G_SCALE, pen: 1, damageMult: 1, count: 1 };
let shortLevel = 0;
let shortStats = { speed: 12 * G_SCALE, size: 6 * G_SCALE, pen: 0, damageMult: 2.5, count: 0, range: 250 * G_SCALE }; // High dmg, low range
let midLevel = 0;
let midStats = { speed: 10 * G_SCALE, size: 8 * G_SCALE, pen: 2, damageMult: 1.5, count: 0, range: 500 * G_SCALE };

let reactorDmg = 0;
let reactorRadiusMult = 1.0;

// Entities
let enemies = [];
let projectiles = [];
let saws = []; 
let enemyProjectiles = [];
let gems = [];
let upgradeChoices = [];
let cardBounds = [];
let damageNumbers = [];
let summons = []; 
let lightningEffects = [];
let myUpgrades = [];

// --- DRAGON SPECS ---
let VISUAL_SCALE = BASE_VISUAL_SCALE;
const CONFIG = {
    segmentCount: 85,
    segmentDist: 8 * VISUAL_SCALE,
    headSpeed: 0.015,
    maxRibWidth: 42 * VISUAL_SCALE,
    legSpeed: 0.05,
    upperLegLen: 75 * VISUAL_SCALE,
    lowerLegLen: 85 * VISUAL_SCALE,
    wingSpan: 340 * VISUAL_SCALE,
    wingFlapSpeed: 0.03,
    wingAttachment: 18
};
let spine = [];
let legs = [];

// --- HELPER FUNCTIONS ---
function healPct(pct) {
    let amt = dragonMaxHP * pct;
    dragonHP = Math.min(dragonMaxHP, dragonHP + amt);
    damageNumbers.push(new FloatingText(spine[0].x, spine[0].y, "+" + Math.floor(amt), "#0f0", 25));
}
function addMaxHP(pct) {
    let oldMax = dragonMaxHP;
    dragonMaxHP *= (1 + pct);
    dragonHP += (dragonMaxHP - oldMax);
}
function romanize(num) {
    if (num === 1) return "I"; if (num === 2) return "II";
    if (num === 3) return "III"; if (num === 4) return "IV";
    if (num === 5) return "V"; return "X";
}
function updateStatsBySize() {
    let sizeRatio = VISUAL_SCALE / BASE_VISUAL_SCALE;
    dragonAtk = dragonBaseAtk * Math.max(0.2, sizeRatio);
}

function updateDragonSize() {
    CONFIG.segmentDist = 8 * VISUAL_SCALE;
    CONFIG.maxRibWidth = 42 * VISUAL_SCALE;
    CONFIG.upperLegLen = 75 * VISUAL_SCALE;
    CONFIG.lowerLegLen = 85 * VISUAL_SCALE;
    CONFIG.wingSpan = 340 * VISUAL_SCALE;
    let sizeRatio = VISUAL_SCALE / BASE_VISUAL_SCALE;
    CONFIG.headSpeed = 0.015 * (1 / Math.max(0.5, sizeRatio));
    updateStatsBySize();
}

function getNearestEnemy(x, y, maxDist = Infinity) {
    let nearest = null;
    let minD = Infinity;
    for (let e of enemies) {
        let d = Math.hypot(e.x - x, e.y - y);
        if (d < minD && d < maxDist) {
            minD = d;
            nearest = e;
        }
    }
    return nearest;
}

// --- UPGRADES DATABASE ---
const UPGRADES = [
    // --- COMMON (Tier 1) ---
    { r: 0, type: 'def', name: "Thick Skin", desc: "Max Health +10%", run: () => addMaxHP(0.1) },
    { r: 0, type: 'def', name: "Regen Cell", desc: "Regen +1 HP/frame", run: () => dragonRegen += 1 },
    { r: 0, type: 'def', name: "Hard Scales", desc: "Defense +5% (Caps at 50%)", run: () => dragonDefPct = Math.min(CAP_DEF, dragonDefPct + 0.05) },
    { r: 0, type: 'def', name: "Spikes", desc: "Thorns +20 DMG", run: () => thornsDmg += 20 },
    { r: 0, type: 'wep', name: "Extra Barrel", desc: "+1 Main Beam (-10% Dmg)", req: () => laserCount < MAX_LASER_MAIN, run: () => { laserCount++; laserDmgMult *= 0.90; } },
    { r: 0, type: 'wep', name: "Focus Lens", desc: "Beams are 10% wider", run: () => laserWidthBase += 0.1 },
    { r: 0, type: 'wep', name: "Sharpen", desc: "Base Attack +10%", run: () => dragonBaseAtk += 0.1 },
    { r: 0, type: 'util', name: "Magnetism", desc: "Pickup Range +25%", run: () => magnetRange *= 1.25 },
    { r: 0, type: 'util', name: "Learning", desc: "XP Gain +10%", run: () => xpMultiplier += 0.1 },
    { r: 0, type: 'wep', name: "Sniper", desc: "Crit Chance +5%", run: () => critChance = Math.min(CAP_CRIT_CHANCE, critChance + 0.05) },

    // --- NEW PROJECTILES ---
    { r: 0, type: 'wep', name: "Spark (Short)", desc: "Add 2 Short Range High DMG Projectiles", req: () => !unlockedShort, run: () => { unlockedShort = true; shortStats.count += 2; } },
    { r: 0, type: 'wep', name: "More Sparks", desc: "+2 Short Range Projectiles", req: () => unlockedShort, run: () => shortStats.count += 2 },
    { r: 0, type: 'wep', name: "Intense Spark", desc: "Spark DMG +25%", req: () => unlockedShort, run: () => shortStats.damageMult += 0.25 },
    
    { r: 0, type: 'wep', name: "Bolt (Mid)", desc: "Add 1 Mid Range Piercing Projectile", req: () => !unlockedMid, run: () => { unlockedMid = true; midStats.count += 1; } },
    { r: 0, type: 'wep', name: "More Bolts", desc: "+1 Mid Range Projectile", req: () => unlockedMid, run: () => midStats.count += 1 },
    { r: 0, type: 'wep', name: "Heavy Bolt", desc: "Bolt Pierce +1", req: () => unlockedMid, run: () => midStats.pen += 1 },

    // --- SIZE TREE ---
    { r: 0, type: 'size', name: "Growth Hormone", desc: "Size +10% (Gain HP/ATK, Lose Spd)", run: () => { VISUAL_SCALE *= 1.1; updateDragonSize(); addMaxHP(0.1); } },
    { r: 0, type: 'size', name: "Compact Form", desc: "Size -10% (Gain Spd/FireRate, Lose HP)", run: () => { VISUAL_SCALE *= 0.9; updateDragonSize(); dragonMaxHP *= 0.95; } },
    
    // --- RARE (Tier 2) ---
    { r: 1, type: 'def', name: "Reinforced Plating", desc: "Max HP +25%", run: () => addMaxHP(0.25) },
    { r: 1, type: 'def', name: "Shield Generator", desc: "Unlock 500 Shield", req: () => !unlockedShield, run: () => { unlockedShield = true; dragonMaxShield += 500; dragonShieldRegen += 2; } },
    { r: 1, type: 'wep', name: "Dual Beam", desc: "+1 Beam, +10% DMG", req: () => laserCount < MAX_LASER_MAIN, run: () => { laserCount++; dragonBaseAtk += 0.1; } },
    
    // PROJECTILES (ORBS)
    { r: 1, type: 'wep', name: "Orbiter", desc: "Unlock Long Range Projectile", req: () => !unlockedOrbs, run: () => { unlockedOrbs = true; orbLevel++; orbStats.count++; } },
    { r: 1, type: 'wep', name: "Orb Upgrade", desc: "+1 Orb, +Speed", req: () => unlockedOrbs, run: () => { orbLevel++; orbStats.count++; orbStats.speed += 2; } },
    
    // BOOMERANG
    { r: 1, type: 'wep', name: "Bone Boomerang", desc: "Auto-Targeting Returning Bone", req: () => !unlockedBoomerang, run: () => { unlockedBoomerang = true; boomerangCount++; } },
    { r: 1, type: 'wep', name: "Multi-Rang", desc: "+1 Boomerang", req: () => unlockedBoomerang, run: () => boomerangCount++ },
    
    // OTHER WEAPONS
    { r: 1, type: 'wep', name: "Sawblade", desc: "Spinning melee protection", req: () => !unlockedSaw, run: () => { unlockedSaw = true; sawCount++; saws.push(new SawBlade(0)); } },
    { r: 1, type: 'wep', name: "Double Saw", desc: "Add another Sawblade", req: () => unlockedSaw, run: () => { sawCount++; saws.push(new SawBlade((Math.PI*2)/sawCount)); rearrangeSaws(); } },
    { r: 1, type: 'wep', name: "Plasma Grenade", desc: "Lob explosive plasma", req: () => !unlockedGrenade, run: () => { unlockedGrenade = true; grenadeCount++; } },
    { r: 2, type: 'wep', name: "Cluster Bomb", desc: "Grenades split on boom", req: () => unlockedGrenade, run: () => grenadeCluster = true },
    { r: 2, type: 'wep', name: "Napalm", desc: "Grenades leave fire", req: () => unlockedGrenade, run: () => grenadeNapalm = true },

    // STATUS
    { r: 1, type: 'wep', name: "Poison Tip", desc: "10% Chance to Poison (3s)", run: () => poisonChance += 0.1 },
    { r: 1, type: 'wep', name: "Flame Tip", desc: "10% Chance to Burn (3s)", run: () => burnChance += 0.1 },
    { r: 1, type: 'wep', name: "Crit Master", desc: "Crit Dmg +50%", run: () => critDmg = Math.min(CAP_CRIT_DMG, critDmg + 0.5) },
    { r: 1, type: 'def', name: "Dodge Roll", desc: "Dodge +10% (Caps 30%)", run: () => dodgeChance = Math.min(CAP_DODGE, dodgeChance + 0.1) },
    { r: 1, type: 'wep', name: "Reactor", desc: "Burn nearby enemies", run: () => reactorDmg += 40 },

    // --- EPIC (Tier 3) ---
    // FURY TREE
    { r: 2, type: 'abil', name: "Draconic Fury", desc: "Unlock FURY meter (Dmg Boost)", req: () => !unlockedFury, run: () => { unlockedFury = true; furyEnabled = true; } },
    { r: 2, type: 'abil', name: "Meditation", desc: "Fury regens passively", req: () => unlockedFury, run: () => furyRegenPassive += 0.05 },
    { r: 2, type: 'abil', name: "Ignition", desc: "Burn enemies near you in Fury", req: () => unlockedFury, run: () => furyIgnition = true },
    { r: 3, type: 'abil', name: "Rage Quit", desc: "Explode when Fury ends", req: () => unlockedFury, run: () => furyEndExplosion = true },

    // GHOST TREE
    { r: 2, type: 'abil', name: "Spectral Form", desc: "Unlock Ghost Meter (Dodge)", req: () => !unlockedGhost, run: () => { unlockedGhost = true; dodgeChance += 0.1; } },
    { r: 2, type: 'abil', name: "Ethereal Flow", desc: "Ghost Meter Regen", req: () => unlockedGhost, run: () => ghostRegen += 0.05 },
    { r: 2, type: 'abil', name: "Ectoplasm", desc: "Slow enemies you pass thru", req: () => unlockedGhost, run: () => ghostEcto = true },
    { r: 2, type: 'abil', name: "Poltergeist", desc: "Dealing DMG charges Ghost Meter", req: () => unlockedGhost, run: () => ghostDmg += 0.5 },

    // VOID TREE (New)
    { r: 2, type: 'abil', name: "Void Essence", desc: "Unlock Void Meter (Suck + Dmg)", req: () => !unlockedVoid, run: () => { unlockedVoid = true; voidEnabled = true; } },
    { r: 2, type: 'abil', name: "Event Horizon", desc: "Void Pull Strength ++", req: () => unlockedVoid, run: () => voidPullStrength += 0.05 },
    { r: 2, type: 'abil', name: "Null Zone", desc: "Void deals constant Aura Dmg", req: () => unlockedVoid, run: () => voidDmgAura += 50 },

    // HOLY TREE (New)
    { r: 2, type: 'abil', name: "Divine Light", desc: "Unlock Holy Meter (Heal + Smite)", req: () => !unlockedHoly, run: () => { unlockedHoly = true; holyEnabled = true; } },
    { r: 2, type: 'abil', name: "Purification", desc: "Holy active cleanses debuffs", req: () => unlockedHoly, run: () => holyHealTick += 2 },
    { r: 2, type: 'abil', name: "Wrath", desc: "Holy Active Smites Random Foes", req: () => unlockedHoly, run: () => holySmiteChance += 0.1 },

    // SIZE TREE EPIC
    { r: 2, type: 'size', name: "Leviathan", desc: "Size +25%, HP +50%", run: () => { VISUAL_SCALE *= 1.25; updateDragonSize(); addMaxHP(0.5); } },
    { r: 2, type: 'size', name: "Micro Dragon", desc: "Size -25%, Spd +30%", run: () => { VISUAL_SCALE *= 0.75; updateDragonSize(); } },

    { r: 2, type: 'wep', name: "Missile Silo", desc: "Unlock Homing Missiles", req: () => !unlockedMissiles, run: () => { unlockedMissiles = true; missileCount++; } },
    { r: 2, type: 'wep', name: "Plasma Beam", desc: "Lasers Pierce Armor", run: () => laserType = 'plasma' },
    
    // NEW STATUS UPGRADES
    { r: 2, type: 'wep', name: "Cryo Round", desc: "10% Chance to Freeze (1s)", run: () => freezeChance += 0.1 },
    { r: 2, type: 'wep', name: "Corrosion", desc: "10% Chance to Weaken (3s)", run: () => weakChance += 0.1 },
    { r: 2, type: 'wep', name: "Shatter", desc: "10% Chance to Vulnerable (3s)", run: () => vulnChance += 0.1 },

    { r: 2, type: 'wep', name: "Tesla Coil", desc: "15% Chance to Chain Zap", run: () => chainLightningChance = Math.min(0.8, chainLightningChance + 0.15) },
    { r: 2, type: 'wep', name: "Vampiric Touch", desc: "Crit Heals +2 HP", run: () => lifeSteal += 2 },
    { r: 2, type: 'wep', name: "Mine Layer", desc: "Drop Mines", req: () => !unlockedMines, run: () => { unlockedMines = true; } },

    // --- CRAZY / FUN UPGRADES ---
    { r: 3, type: 'util', name: "Size Matters", desc: "Size +60%, HP x2.5", run: () => { VISUAL_SCALE *= 1.6; updateDragonSize(); addMaxHP(1.5); } },
    { r: 3, type: 'wep', name: "Disco Inferno", desc: "Lasers do Random Status FX", req: () => !discoMode, run: () => { discoMode = true; } },
    
    // --- LEGENDARY (Tier 4) ---
    { r: 3, type: 'wep', name: "Void Cannon", desc: "0.05% MaxHP + Flat Dmg (Bosses take 90% less %HP Dmg)", run: () => laserType = 'void' },
    { r: 3, type: 'util', name: "Time Stop", desc: "5% Chance to Freeze Time", run: () => timeStopChance += 0.05 },
    { r: 3, type: 'def', name: "Titan Scales", desc: "Defense Cap increased to 75% & +10% Def", run: () => dragonDefPct = Math.min(0.75, dragonDefPct + 0.1) },
    { r: 3, type: 'wep', name: "Armageddon", desc: "Projectiles Explode", req: () => unlockedOrbs, run: () => orbStats.damageMult *= 1.5 },
    
    // PHOENIX SOUL REWORK
    { r: 3, type: 'def', name: "Phoenix Soul", desc: "+4 Revives, but +25% Dmg Taken (Stacks at 40%)", run: () => { 
        reviveCount += 4; 
        let penalty = 0.25;
        if (revivePenaltyStacks > 0) penalty *= 0.4;
        dmgTakenMult += penalty;
        revivePenaltyStacks++;
    }},

    { r: 3, type: 'abil', name: "Perma-Fury", desc: "Fury charges 2x faster", req: () => unlockedFury, run: () => furyDuration -= 100 },
    
    // --- MYTHIC (Tier 5) ---
    { r: 5, type: 'god', name: "God Mode", desc: "All Stats +50%", run: () => { dragonBaseAtk*=1.5; addMaxHP(0.5); dragonDefPct+=0.1; } },
    { r: 5, type: 'god', name: "Evolution", desc: "Grow larger, HP x2", run: () => { VISUAL_SCALE *= 1.2; updateDragonSize(); addMaxHP(1.0); } },
    { r: 5, type: 'god', name: "Black Hole Sun", desc: "Reactor pulls with infinite mass force", run: () => reactorRadiusMult *= 2.5 },

    // --- CURSED ---
    { r: 4, type: 'cursed', name: "Blood Contract", desc: "DMG +100%, Max HP -40%", run: () => { dragonBaseAtk += 1.0; dragonMaxHP *= 0.6; dragonHP = Math.min(dragonHP, dragonMaxHP); } },
    { r: 4, type: 'cursed', name: "Glass Cannon", desc: "DMG +150%, Take +50% DMG", run: () => { dragonBaseAtk += 1.5; dmgTakenMult += 0.5; } }
];

// Procedural Upgrades
const STAT_TYPES = [
    { name: "Vitality", stat: () => addMaxHP(0.15), desc: "HP +15%", type: 'def' },
    { name: "Strength", stat: () => dragonBaseAtk += 0.15, desc: "ATK +15%", type: 'wep' },
    { name: "Fortitude", stat: () => dragonDefPct = Math.min(CAP_DEF, dragonDefPct + 0.03), desc: "Def +3%", type: 'def' }
];
for (let i = 0; i < 40; i++) {
    let t = STAT_TYPES[i % STAT_TYPES.length];
    UPGRADES.push({ r: 0, type: t.type, name: `${t.name} ${romanize(Math.floor(i/4)+1)}`, desc: t.desc, run: t.stat });
}

function rearrangeSaws() {
    saws = [];
    for(let i=0; i<sawCount; i++) {
        saws.push(new SawBlade((Math.PI*2 / sawCount) * i));
    }
}

// --- CLASSES ---
class FloatingText {
    constructor(x, y, text, color, size) {
        this.x = x + (Math.random()-0.5)*20;
        this.y = y;
        this.text = text; this.color = color; this.life = 60;
        this.size = size; this.vy = -1;
    }
    update() { this.y += this.vy; this.life--; return this.life > 0; }
    draw() {
        ctx.globalAlpha = Math.max(0, this.life / 20);
        ctx.fillStyle = this.color; ctx.font = `bold ${this.size}px monospace`;
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1.0;
    }
}

class LightningEffect {
    constructor(x1, y1, x2, y2) {
        this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2;
        this.life = 10; 
    }
    update() { this.life--; return this.life > 0; }
    draw() {
        ctx.save();
        ctx.globalAlpha = this.life / 10;
        ctx.strokeStyle = "#00ffff";
        ctx.lineWidth = 3;
        ctx.shadowBlur = 10; ctx.shadowColor = "cyan";
        ctx.beginPath();
        ctx.moveTo(this.x1, this.y1);
        let midX = (this.x1 + this.x2) / 2 + (Math.random()-0.5) * 50;
        let midY = (this.y1 + this.y2) / 2 + (Math.random()-0.5) * 50;
        ctx.lineTo(midX, midY);
        ctx.lineTo(this.x2, this.y2);
        ctx.stroke();
        ctx.restore();
    }
}

class ExpGem {
    constructor(x, y, val) { this.x = x; this.y = y; this.val = val; }
    update() {
        const head = spine[0];
        const d = Math.hypot(head.x - this.x, head.y - this.y);
        if (d < 400 * G_SCALE * magnetRange) { 
            const a = Math.atan2(head.y - this.y, head.x - this.x);
            this.x += Math.cos(a) * (25 * G_SCALE); this.y += Math.sin(a) * (25 * G_SCALE);
        }
        if (d < 60 * G_SCALE) {
            exp += this.val * xpMultiplier;
            // Meter Gain on Kill
            if (furyEnabled && !furyActive) furyMeter = Math.min(100, furyMeter + 0.5);
            if (unlockedVoid && !voidActive) voidMeter = Math.min(200, voidMeter + 1);
            if (unlockedHoly && !holyActive) holyMeter = Math.min(50, holyMeter + 0.25); // Slower holy charge
            
            if (exp >= expNext) levelUp();
            return true;
        }
        return false;
    }
    draw() {
        ctx.fillStyle = COLORS.glow; ctx.shadowBlur = 10;
        ctx.shadowColor = COLORS.glow;
        ctx.beginPath(); ctx.arc(this.x, this.y, 6 * G_SCALE, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
    }
}

class SawBlade {
    constructor(offset) {
        this.offset = offset;
        this.angle = 0;
        this.dist = 150 * VISUAL_SCALE;
    }
    update(head) {
        this.angle += 0.1;
        this.dist = 120 * VISUAL_SCALE + (80 * G_SCALE);
        let cx = head.x + Math.cos(this.angle + this.offset) * this.dist;
        let cy = head.y + Math.sin(this.angle + this.offset) * this.dist;
        enemies.forEach(e => {
            if (Math.hypot(e.x - cx, e.y - cy) < 60 * G_SCALE) {
                e.takeDamage(10 * dragonAtk); 
                if(frame % 10 === 0) {
                     ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(cx, cy, 70*G_SCALE, 0, Math.PI*2); ctx.fill();
                }
            }
        });
        // Draw
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(this.angle * 3);
        ctx.fillStyle = "#888";
        ctx.beginPath();
        ctx.arc(0,0, 20*G_SCALE, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 3;
        for(let i=0; i<4; i++) {
            ctx.rotate(Math.PI/2);
            ctx.beginPath(); ctx.moveTo(0, -30*G_SCALE);
            ctx.lineTo(10*G_SCALE, 0); ctx.lineTo(-10*G_SCALE, 0); ctx.fill();
        }
        ctx.restore();
    }
}

class Boomerang {
    constructor(x, y, angleOffset) {
        this.x = x; this.y = y;
        this.originX = x; this.originY = y;
        
        // Auto-Target Nearest
        let nearest = getNearestEnemy(x, y, 2000 * G_SCALE);
        let baseAngle = nearest ? Math.atan2(nearest.y - y, nearest.x - x) : spine[0].angle;
        this.angle = baseAngle + angleOffset;
        
        this.speed = 12 * G_SCALE;
        this.dist = 0;
        this.maxDist = 1200 * G_SCALE; // 2.5x Range boost (was ~600)
        this.returning = false;
        this.life = 300;
    }
    update() {
        this.life--;
        if(this.life <= 0) return true;
        let head = spine[0];
        if(!this.returning) {
            this.x += Math.cos(this.angle) * this.speed;
            this.y += Math.sin(this.angle) * this.speed;
            this.dist += this.speed;
            if(this.dist >= this.maxDist) this.returning = true;
        } else {
            let a = Math.atan2(head.y - this.y, head.x - this.x);
            this.x += Math.cos(a) * (this.speed * 1.5);
            this.y += Math.sin(a) * (this.speed * 1.5);
            if(Math.hypot(head.x - this.x, head.y - this.y) < 50) return true; // Caught
        }
        
        this.rot = (this.rot || 0) + 0.5;
        enemies.forEach(e => {
            if(Math.hypot(e.x - this.x, e.y - this.y) < 40 * G_SCALE) {
                e.takeDamage(15 * dragonAtk);
                if(frame % 5 === 0) {
                    ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(e.x, e.y, 20, 0, Math.PI*2); ctx.fill();
                }
            }
        });
        return false;
    }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rot);
        ctx.fillStyle = "#ddccaa";
        ctx.beginPath(); ctx.moveTo(-20,-5); ctx.quadraticCurveTo(0, -20, 20, -5); 
        ctx.quadraticCurveTo(0, 10, -20, -5); ctx.fill();
        ctx.restore();
    }
}

class Grenade {
    constructor(x, y, targetX, targetY) {
        this.x = x; this.y = y;
        this.targetX = targetX; this.targetY = targetY;
        this.timer = 60;
        this.totalTime = 60;
        this.startX = x; this.startY = y;
    }
    update() {
        this.timer--;
        let t = 1 - (this.timer / this.totalTime);
        this.x = this.startX + (this.targetX - this.startX) * t;
        this.y = this.startY + (this.targetY - this.startY) * t;
        let height = Math.sin(t * Math.PI) * 100 * G_SCALE;
        this.visualY = this.y - height;
        
        if(this.timer <= 0) {
            let radius = 200 * G_SCALE;
            enemies.forEach(e => {
                if(Math.hypot(e.x - this.x, e.y - this.y) < radius) {
                    e.takeDamage(50 * dragonAtk);
                    if(grenadeNapalm) e.applyStatus('burn', 180, 10 * dragonAtk);
                }
            });
            ctx.fillStyle = "rgba(255, 100, 255, 0.6)";
            ctx.beginPath(); ctx.arc(this.x, this.y, radius, 0, Math.PI*2); ctx.fill();
            
            if(grenadeCluster) {
                enemies.forEach(e => {
                   if(Math.hypot(e.x - this.x, e.y - this.y) < radius * 1.5) {
                        e.takeDamage(20 * dragonAtk);
                   }
                });
                ctx.strokeStyle = "orange"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x, this.y, radius*1.5, 0, Math.PI*2); ctx.stroke();
            }
            return true;
        }
        return false;
    }
    draw() {
        ctx.fillStyle = "#ff00ff";
        ctx.beginPath();
        ctx.arc(this.x, this.visualY, 8*G_SCALE, 0, Math.PI*2); ctx.fill();
    }
}

class Missile {
    constructor(x, y) {
        this.x = x; this.y = y; this.life = 120;
        this.target = enemies.length > 0 ? enemies[Math.floor(Math.random()*enemies.length)] : null;
        this.vx = (Math.random()-0.5)*10;
        this.vy = (Math.random()-0.5)*10;
    }
    update() {
        this.life--;
        if (this.target && this.target.hp > 0) {
            let a = Math.atan2(this.target.y - this.y, this.target.x - this.x);
            this.vx += Math.cos(a) * 1.5; this.vy += Math.sin(a) * 1.5;
            this.vx *= 0.9; this.vy *= 0.9;
        }
        this.x += this.vx; this.y += this.vy;
        for (let e of enemies) {
            if (Math.hypot(e.x - this.x, e.y - this.y) < e.radius + 10) {
                e.takeDamage(100 * dragonAtk);
                ctx.fillStyle = "orange"; ctx.beginPath(); ctx.arc(this.x, this.y, 50, 0, Math.PI*2); ctx.fill();
                return true;
            }
        }
        return this.life <= 0;
    }
    draw() {
        ctx.fillStyle = "yellow"; ctx.fillRect(this.x-2, this.y-2, 4, 4);
        ctx.strokeStyle = "orange"; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x-this.vx*2, this.y-this.vy*2); ctx.stroke();
    }
}

class Mine {
    constructor(x, y) { this.x = x; this.y = y; this.timer = 600; }
    update() {
        this.timer--;
        for (let e of enemies) {
            if (Math.hypot(e.x - this.x, e.y - this.y) < e.radius + 60) { 
                e.takeDamage(200 * dragonAtk);
                ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(this.x, this.y, 120, 0, Math.PI*2); ctx.fill();
                enemies.forEach(subE => {
                    if (Math.hypot(subE.x - this.x, subE.y - this.y) < 120) {
                        subE.takeDamage(200 * dragonAtk);
                    }
                });
                return true; 
            }
        }
        ctx.fillStyle = (frame%20<10)?"red":"#500";
        ctx.beginPath();
        ctx.arc(this.x, this.y, 10, 0, Math.PI*2); ctx.fill();
        return this.timer <= 0;
    }
    draw() {}
}

class EnemyProjectile {
    constructor(x, y, angle, type = 'normal') {
        this.x = x; this.y = y;
        this.vx = Math.cos(angle) * (6 * G_SCALE); 
        this.vy = Math.sin(angle) * (6 * G_SCALE);
        this.radius = 8 * G_SCALE; this.type = type;
        this.dmg = 30;
        
        if(type === 'sniper') { this.dmg = 100; this.vx *= 1.5; this.vy *= 1.5; }
        if(type === 'boss') { this.radius = 20 * G_SCALE; this.dmg = 150; }
        if(type === 'web') { this.radius = 12 * G_SCALE; this.dmg = 20; }
        if(type === 'titan') { this.radius = 50 * G_SCALE; this.dmg = 300; }
        if(type === 'spawner') { this.radius = 15 * G_SCALE; this.dmg = 0; } 
    }
    update() {
        if (timeStopActive) return false;
        this.x += this.vx * globalSlow; this.y += this.vy * globalSlow;
        const head = spine[0];
        const center = spine[Math.floor(spine.length/2)];
        const hitHead = Math.hypot(this.x - head.x, this.y - head.y) < (40 * VISUAL_SCALE);
        const hitBody = Math.hypot(this.x - center.x, this.y - center.y) < (50 * VISUAL_SCALE);
        if (this.type === 'spawner' && frame % 5 === 0 && Math.random() < 0.05) {
             let e = new Enemy('swarmer', wave);
             e.x = this.x; e.y = this.y; enemies.push(e);
             return true;
        }

        if (hitHead || hitBody) {
            if (this.type === 'spawner') {
                let e = new Enemy('brute', wave);
                e.x = this.x; e.y = this.y; enemies.push(e);
                return true;
            }
            takeDamage(this.dmg);
            return true; 
        }
        return (this.x < -200 || this.x > width+200 || this.y < -200 || this.y > height+200);
    }
    draw() {
        ctx.fillStyle = this.type === 'boss' ? "#ff00ff" : "#ff3300"; 
        if(this.type === 'web') ctx.fillStyle = "#fff";
        if(this.type === 'titan') ctx.fillStyle = "#ffff00";
        if(this.type === 'spawner') ctx.fillStyle = "#00ff00";
        ctx.shadowBlur = 10; ctx.shadowColor = "red";
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
    }
}

// --- ENEMY DATA ---
// REDUCED BODY DAMAGE (crashDmg) FOR SMALLER ENEMIES
const ENEMY_DEFS = {
    'swarmer': { hp: 50, spd: 3.0, xp: 10, col: '#ff5500', r: 12, visual: 'insect', ai: 'swarm', crashDmg: 5 },
    'fly': { hp: 30, spd: 3.5, xp: 8, col: '#ccaa00', r: 10, visual: 'insect', ai: 'strafe', crashDmg: 5 },
    'mite': { hp: 60, spd: 2.5, xp: 12, col: '#aa5500', r: 15, visual: 'bug', ai: 'zigzag', crashDmg: 8 },
    'spore': { hp: 40, spd: 1.8, xp: 15, col: '#00aa00', r: 12, visual: 'bio', ai: 'drift', crashDmg: 5 },
    'splitter': { hp: 40, spd: 2.0, xp: 15, col: '#885500', r: 18, visual: 'blob', ai: 'basic', crashDmg: 8 },
    'charger': { hp: 80, spd: 4.0, xp: 25, col: '#ff8800', r: 15, visual: 'beetle', ai: 'charge', crashDmg: 30 },
    'wasp': { hp: 25, spd: 3.5, xp: 20, col: '#ffff00', r: 8, visual: 'insect', ai: 'range_normal', crashDmg: 5 }, 
    'blob': { hp: 150, spd: 0.8, xp: 25, col: '#0055aa', r: 25, visual: 'blob', crashDmg: 15 },
    'drone': { hp: 60, spd: 3.0, xp: 18, col: '#aaaaaa', r: 14, visual: 'mech', ai: 'range_normal', crashDmg: 5 }, 
    'grunt': { hp: 300, spd: 1.2, xp: 40, col: '#aa0000', r: 22, visual: 'mech', crashDmg: 20 },
    'soldier': { hp: 400, spd: 1.1, xp: 50, col: '#cc0000', r: 25, visual: 'mech', crashDmg: 25 },
    'shielded': { hp: 800, spd: 1.0, xp: 70, col: '#00ffff', r: 30, visual: 'shield_mech', crashDmg: 30 },
    'lancer': { hp: 250, spd: 2.2, xp: 55, col: '#ff8800', r: 18, visual: 'spike', crashDmg: 40 },
    'zealot': { hp: 200, spd: 3.5, xp: 60, col: '#ff00ff', r: 20, visual: 'star', ai: 'kamikaze', crashDmg: 80 },
    'dasher': { hp: 200, spd: 1.8, xp: 60, col: '#00ff00', r: 18, visual: 'triangle', ai: 'dash', crashDmg: 40 },
    'shooter': { hp: 350, spd: 1.0, xp: 80, col: '#8800ff', r: 25, visual: 'turret', ai: 'range_normal', crashDmg: 5 },
    'sniper': { hp: 250, spd: 0.8, xp: 120, col: '#ff0088', r: 20, visual: 'cross', ai: 'range_snipe', crashDmg: 5 },
    'mortar': { hp: 500, spd: 0.7, xp: 100, col: '#444444', r: 35, visual: 'heavy_mech', ai: 'range_heavy', crashDmg: 10 },
    'hunter': { hp: 300, spd: 1.4, xp: 90, col: '#00aa44', r: 22, visual: 'stealth', ai: 'range_move', crashDmg: 15 },
    'webber': { hp: 400, spd: 1.0, xp: 100, col: '#cccccc', r: 30, visual: 'spider', ai: 'range_web', crashDmg: 10 },
    'glitch': { hp: 450, spd: 1.8, xp: 110, col: '#ffffff', r: 22, visual: 'glitch', ai: 'teleport', crashDmg: 20 },
    'phantom': { hp: 350, spd: 1.6, xp: 110, col: '#88aaff', r: 25, visual: 'ghost', ai: 'fade', crashDmg: 15 },
    // HEAVY HITTERS
    'tank': { hp: 2000, spd: 0.6, xp: 250, col: '#222222', r: 45, visual: 'heavy_tank', crashDmg: 100 },
    'golem': { hp: 5000, spd: 0.4, xp: 600, col: '#554433', r: 60, visual: 'block', crashDmg: 150 },
    // BOSSES
    'mini_slayer': { hp: 12000, spd: 1.2, xp: 2000, col: '#aa00aa', r: 40, visual: 'boss_slayer', isBoss: true, ai: 'pounce', crashDmg: 200 },
    'boss_hydra': { hp: 25000, spd: 0.5, xp: 5000, col: '#00aa00', r: 90, visual: 'boss_hydra', isBoss: true, ai: 'range_heavy', crashDmg: 300 },
    'boss_titan': { hp: 60000, spd: 0.3, xp: 8000, col: '#aa5500', r: 120, visual: 'boss_titan', isBoss: true, ai: 'swarm', crashDmg: 400 },
    'boss_ufo': { hp: 30000, spd: 1.5, xp: 6000, col: '#8888ff', r: 60, visual: 'boss_ufo', isBoss: true, ai: 'range_move', crashDmg: 100 },
    'mini_mecha': { hp: 15000, spd: 1.0, xp: 3000, col: '#555555', r: 50, visual: 'mini_mecha', isBoss: true, ai: 'range_normal', crashDmg: 150 }
};

class Enemy {
    constructor(type, waveNum) {
        let def = ENEMY_DEFS[type] || ENEMY_DEFS['swarmer'];
        const side = Math.random() > 0.5;
        this.x = side ? -100 : width + 100;
        this.y = Math.random() * height;
        this.type = type;
        this.angle = 0;
        this.timer = Math.random() * 100;
        this.state = 0;
        let scale = 1 + (waveNum * 0.25);
        if (def.isBoss && waveNum < 10) scale *= 0.5;
        if (hasBloodLust) scale *= 2; 

        this.hp = def.hp * scale;
        this.maxHp = this.hp;
        this.speed = def.spd * G_SCALE;
        this.radius = def.r * G_SCALE; 
        this.xp = Math.floor(def.xp * scale);
        this.isBoss = def.isBoss || false;
        this.col = def.col;
        this.visual = def.visual;
        this.ai = def.ai || (def.isBoss && def.ai ? def.ai : 'basic'); 
        this.crashDmg = def.crashDmg || 20;
        
        // STATUS TIMERS (Frames)
        this.poisonTimer = 0;
        this.burnTimer = 0;
        this.freezeTimer = 0;
        this.weakTimer = 0; 
        this.vulnTimer = 0;
        this.burnDmgPerTick = 0;
        this.animFrame = Math.random() * 100;
        this.legs = [];
        if (this.visual === 'spider' || this.visual === 'heavy_tank' || this.visual === 'beetle') {
            for(let i=0; i<6; i++) this.legs.push({x:0, y:0, tX:0, tY:0, step:0});
        }

        this.eliteMod = null;
        if (!this.isBoss && Math.random() < 0.15 + (wave * 0.01)) { 
            const mods = ['AEGIS', 'WARP', 'REGEN', 'VOLATILE', 'GIANT'];
            this.eliteMod = mods[Math.floor(Math.random() * mods.length)];
            this.xp *= 3;
        }
        if (this.eliteMod === 'GIANT') { this.hp *= 2; this.radius *= 1.5; this.maxHp = this.hp; }
        if (this.eliteMod === 'AEGIS') { this.shield = this.hp * 0.5; }
    }

    applyStatus(type, duration, strength) {
        if (this.isBoss && (type === 'freeze' || type === 'stun')) return;
        if (type === 'poison') this.poisonTimer = duration;
        if (type === 'burn') { this.burnTimer = duration; this.burnDmgPerTick = strength; }
        if (type === 'freeze') this.freezeTimer = duration;
        if (type === 'weak') this.weakTimer = duration;
        if (type === 'vuln') this.vulnTimer = duration;
    }

    update() {
        this.animFrame++;
        if (timeStopActive) return;
        if (this.freezeTimer > 0) {
            this.freezeTimer--;
            if (frame % 20 === 0) ctx.fillStyle="cyan";
            return;
        }

        // DoT Handling
        if (this.poisonTimer > 0) {
            if (this.poisonTimer % 60 === 0) this.takeDamage(Math.max(5, dragonAtk), true, 'poison');
            this.poisonTimer--;
        }
        if (this.burnTimer > 0) {
            if (this.burnTimer % 30 === 0) this.takeDamage(this.burnDmgPerTick, true, 'burn');
            this.burnTimer--;
        }
        if (this.weakTimer > 0) this.weakTimer--;
        if (this.vulnTimer > 0) this.vulnTimer--;

        if (this.eliteMod === 'REGEN' && frame % 60 === 0) this.hp = Math.min(this.maxHp, this.hp + this.maxHp*0.05);

        const head = spine[0];
        let targetX = head.x; let targetY = head.y;
        const dist = Math.hypot(targetX - this.x, targetY - this.y);
        
        // Collision push
        enemies.forEach(other => {
            if (other === this) return;
            let dx = this.x - other.x, dy = this.y - other.y;
            let d = Math.hypot(dx, dy);
            let minDist = this.radius + other.radius + 10;
            if (d < minDist && d > 0) {
                let push = (minDist - d) * 0.05;
                this.x += (dx / d) * push; this.y += (dy / d) * push;
            }
        });

        // Reactor Pull & Void Pull
        let pullForce = 0;
        if (reactorDmg > 0 && reactorRadiusMult > 1.0) pullForce += 0.02 * reactorRadiusMult;
        if (voidEnabled && voidActive) pullForce += (0.05 + voidPullStrength);

        if (pullForce > 0) {
            let pullRange = 500 * G_SCALE * (voidActive ? 1.5 : reactorRadiusMult);
            if (dist < pullRange) {
                this.x += (targetX - this.x) * pullForce;
                this.y += (targetY - this.y) * pullForce;
            }
        }
        // Void Damage
        if (voidEnabled && voidActive && dist < 400 * G_SCALE) {
            if (frame % 10 === 0) this.takeDamage(10 + voidDmgAura);
        }

        const angleToPlayer = Math.atan2(targetY - this.y, targetX - this.x);
        let angleDiff = angleToPlayer - this.angle;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        this.angle += angleDiff * 0.1;

        this.timer++;
        let moveSpeed = this.speed * globalSlow;
        if (this.isStunned) { moveSpeed = 0; this.stunTimer--; if(this.stunTimer <= 0) this.isStunned = false; }
        if (ghostEcto && ghostActive && dist < 100) moveSpeed *= 0.5;
        
        let mx = Math.cos(angleToPlayer);
        let my = Math.sin(angleToPlayer);

        if (this.eliteMod === 'WARP' && frame % 120 === 0 && Math.random() < 0.3) {
            this.x += (Math.random()-0.5)*300; this.y += (Math.random()-0.5)*300;
        }

        // BOSS ENRAGE
        if (this.isBoss && this.hp < this.maxHp * 0.5) {
            moveSpeed *= 1.3;
            if (frame % 30 === 0) {
                ctx.fillStyle = "red"; ctx.font = "20px monospace"; ctx.fillText("!", this.x, this.y - 50);
            }
        }

        // AI LOGIC SWITCH
        switch(this.ai) {
            case 'swarm':
                if (dist < 300 * G_SCALE) moveSpeed *= 1.5;
                if (this.isBoss && this.timer > 100) { 
                    moveSpeed = 0;
                    if (this.timer > 160) {
                        for(let i=0; i<12; i++) enemyProjectiles.push(new EnemyProjectile(this.x, this.y, i*(Math.PI/6), 'titan'));
                        this.timer = 0;
                    }
                }
                break;
            case 'strafe':
                mx = Math.cos(angleToPlayer + Math.sin(frame * 0.1) * 0.5);
                my = Math.sin(angleToPlayer + Math.sin(frame * 0.1) * 0.5);
                break;
            case 'zigzag':
                let zig = (frame % 30 < 15) ? 0.5 : -0.5;
                mx = Math.cos(angleToPlayer + zig); my = Math.sin(angleToPlayer + zig);
                break;
            case 'drift':
                if (dist > 800 * G_SCALE) { mx = Math.cos(angleToPlayer); my = Math.sin(angleToPlayer); } 
                else { mx = Math.cos(this.angle + Math.sin(frame*0.05)); my = Math.sin(this.angle + Math.sin(frame*0.05)); }
                break;
            case 'charge': 
                if (this.state === 0) { 
                    mx = Math.cos(angleToPlayer); my = Math.sin(angleToPlayer); moveSpeed *= 0.5;
                    if (this.timer > 60) { this.state = 1; this.timer = 0; }
                } else { 
                    moveSpeed *= 4.0;
                    if (this.timer > 30) { this.state = 0; this.timer = 0; }
                }
                break;
            case 'pounce': 
                if (this.state === 0) { 
                    moveSpeed *= 0.8;
                    if (this.timer > 120) { this.state = 1; this.timer = 0; }
                } else if (this.state === 1) { 
                    moveSpeed = 0;
                    if (this.timer > 40) { this.state = 2; this.timer = 0; }
                } else if (this.state === 2) { 
                    moveSpeed *= 6;
                    if (this.timer > 15) { this.state = 0; this.timer = 0; }
                }
                break;
            case 'dash':
                if (this.state === 0) { if (this.timer > 100) { this.state = 1; this.timer = 0; } } 
                else if (this.state === 1) { moveSpeed = 0; this.x += (Math.random()-0.5)*2; if (this.timer > 40) { this.state = 2; this.timer = 0; } } 
                else if (this.state === 2) { moveSpeed *= 8; if (this.timer > 15) { this.state = 0; this.timer = 0; } }
                break;
            case 'range_normal':
            case 'range_snipe':
            case 'range_heavy':
            case 'range_web':
            case 'range_move':
                let keepDist = (this.ai === 'range_snipe' ? 600 : 350) * G_SCALE;
                let retreatDist = keepDist - 100 * G_SCALE;
                if (dist < retreatDist) { mx = Math.cos(angleToPlayer + Math.PI); my = Math.sin(angleToPlayer + Math.PI); moveSpeed *= 1.2; } 
                else if (dist > keepDist + 100) { mx = Math.cos(angleToPlayer); my = Math.sin(angleToPlayer); } 
                else {
                    let strafeDir = (frame % 200 < 100) ? 1 : -1;
                    mx = Math.cos(angleToPlayer + (Math.PI/2 * strafeDir));
                    my = Math.sin(angleToPlayer + (Math.PI/2 * strafeDir));
                }
                
                let fireRate = this.ai === 'range_snipe' ? 220 : 120;
                if (this.type === 'boss_ufo') fireRate = 180;
                if (this.type === 'boss_hydra' && this.timer > 90) {
                    for(let k=-1; k<=1; k++) enemyProjectiles.push(new EnemyProjectile(this.x, this.y, angleToPlayer + k*0.3, 'normal'));
                    this.timer = 0;
                }
                else if (this.type === 'boss_ufo' && this.timer > 60 && this.hp < this.maxHp*0.5) {
                     for(let k=0; k<4; k++) enemyProjectiles.push(new EnemyProjectile(this.x, this.y, frame*0.1 + k*(Math.PI/2), 'boss'));
                }
                else if (this.timer > fireRate) {
                    let pType = this.ai === 'range_snipe' ? 'sniper' : (this.ai === 'range_web' ? 'web' : 'normal');
                    if (this.type === 'boss_ufo') pType = 'boss';
                    let aimAngle = angleToPlayer;
                    if (this.ai === 'range_snipe' || this.isBoss) aimAngle += (Math.random()-0.5) * 0.1;
                    enemyProjectiles.push(new EnemyProjectile(this.x, this.y, aimAngle, pType));
                    this.timer = 0;
                }
                break;
            case 'teleport':
                if (this.timer > 120) {
                    this.x = head.x + (Math.random()-0.5)*400; this.y = head.y + (Math.random()-0.5)*400;
                    this.timer = 0;
                }
                break;
        }

        this.x += mx * moveSpeed;
        this.y += my * moveSpeed;
        if (dist > 2500 * G_SCALE) {
            this.x += (targetX - this.x) * 0.05; this.y += (targetY - this.y) * 0.05;
        }

        // Leg IK Animation
        if (this.legs.length > 0) {
            this.legs.forEach((leg, i) => {
                let offset = (i % 2 === 0 ? 1 : -1) * (i < 2 ? 0.5 : 1.0);
                let legAngle = this.angle + (i%2===0 ? 1.5 : -1.5) + (i > 1 ? (i%2===0?0.5:-0.5) : 0);
                let idealX = this.x + Math.cos(legAngle) * (this.radius * 2);
                let idealY = this.y + Math.sin(legAngle) * (this.radius * 2);
                if (Math.hypot(idealX - leg.x, idealY - leg.y) > this.radius * 1.5 && leg.step <= 0) {
                    leg.step = 1; leg.tX = idealX; leg.tY = idealY;
                }
                if (leg.step > 0) {
                     leg.x += (leg.tX - leg.x) * 0.2; leg.y += (leg.tY - leg.y) * 0.2; leg.step -= 0.1;
                } else { leg.x = idealX; leg.y = idealY; }
            });
        }

        // COLLISION WITH PLAYER
        let hit = false;
        let points = [0, Math.floor(spine.length/2), spine.length-1];
        for(let idx of points) {
            let seg = spine[idx];
            if (Math.hypot(this.x - seg.x, this.y - seg.y) < this.radius + (20 * VISUAL_SCALE)) {
                hit = true;
                if (idx === spine.length-1 && tailDmgMult > 1.0) {
                    this.takeDamage(20 * dragonAtk * tailDmgMult, false);
                    if (!this.isBoss) {
                        let push = 50 * knockbackStr;
                        this.x -= mx * push; this.y -= my * push;
                    }
                }
                break;
            }
        }

        if (hit) {
            let collisionDamage = this.crashDmg;
            if (this.weakTimer > 0) collisionDamage *= 0.5;

            if(this.ai === 'kamikaze' || this.eliteMod === 'VOLATILE') { 
                collisionDamage = 80;
                this.hp = 0; 
                for(let k=0; k<8; k++) enemyProjectiles.push(new EnemyProjectile(this.x, this.y, k * (Math.PI/4)));
            }
            takeDamage(collisionDamage); 
            if(thornsDmg > 0) this.takeDamage(thornsDmg, false);
            if(ghostActive && ghostDmg > 0) this.takeDamage(ghostDmg * dragonAtk, false);
        }
        
        // REACTOR BURN
        if (reactorDmg > 0 && dist < 200 * VISUAL_SCALE * reactorRadiusMult) {
             if (frame % 20 === 0) this.applyStatus('burn', 60, reactorDmg * 2);
        }
        
        // FURY IGNITION
        if (furyIgnition && furyActive && dist < 300 * G_SCALE) {
             if (frame % 15 === 0) this.takeDamage(dragonAtk * 0.5, true, 'burn');
        }

        // AUTO TURRET
        if (mouse.down || autoTurretCount > 0) {
            if (mouse.down) {
                checkLaserHit(this, head, laserCount, 0);
                if(laserRear > 0) checkLaserHit(this, head, laserRear, Math.PI); 
                if(laserSide > 0) {
                    checkLaserHit(this, head, laserSide, Math.PI/2);
                    checkLaserHit(this, head, laserSide, -Math.PI/2);
                }
            }
            if (autoTurretCount > 0 && dist < 600 * G_SCALE) {
                 this.takeDamage(3 * dragonAtk * autoTurretCount * 0.1, true);
            }
        }
    }

    applyStun(duration) {
        if(this.isBoss) return;
        this.isStunned = true;
        this.stunTimer = duration;
        damageNumbers.push(new FloatingText(this.x, this.y, "STUN", "#ffff00", 25));
    }

    takeDamage(amount, isDoT = false, type = 'normal') {
        if (this.eliteMod === 'AEGIS' && Math.random() < 0.5 && laserType !== 'plasma') {
             damageNumbers.push(new FloatingText(this.x, this.y, "BLOCK", "#fff", 20));
             return;
        }

        if (furyActive) amount *= 2;
        if (shieldAmpDmg && dragonShield > 0) amount *= 1.2;
        if (this.vulnTimer > 0) amount *= 1.3;

        let isCrit = false;
        if (!isDoT && Math.random() < critChance) {
            amount *= critDmg;
            isCrit = true;
            if (lifeSteal > 0) dragonHP = Math.min(dragonMaxHP, dragonHP + lifeSteal);
            // Poltergeist Upgrade
            if (unlockedGhost && ghostDmg > 0 && !ghostActive) ghostMeter = Math.min(ghostMaxMeter, ghostMeter + 1);
        }
        
        if (!isDoT && chainLightningChance > 0 && Math.random() < chainLightningChance) {
             let neighbor = enemies.find(e => e !== this && Math.hypot(e.x-this.x, e.y-this.y) < 300);
             if (neighbor) {
                 lightningEffects.push(new LightningEffect(this.x, this.y, neighbor.x, neighbor.y));
                 neighbor.takeDamage(amount * 0.5);
             }
        }

        this.hp -= amount;

        // EXECUTE
        if (executeThreshold > 0 && this.hp < this.maxHp * executeThreshold && !this.isBoss) {
            this.hp = -1;
            damageNumbers.push(new FloatingText(this.x, this.y, "EXECUTE", "#ff0000", 30));
        }

        if (!isDoT || frame % 30 === 0) {
            let color = isCrit ? "#ffcc00" : "#fff";
            let size = isCrit ? 24 : 14;
            if (isDoT) { size = 12; color = (type === 'poison') ? "#00ff00" : "#ff5500"; } 
            
            if (amount > 1 && (isCrit || frame % 5 === 0)) {
                damageNumbers.push(new FloatingText(this.x, this.y, Math.floor(amount), color, size));
            }
        }
        
        if (this.type === 'splitter' && this.hp <= 0) {
             for(let k=0; k<2; k++) {
                 let e = new Enemy('swarmer', wave);
                 e.x = this.x + (Math.random()-0.5)*20; e.y = this.y + (Math.random()-0.5)*20;
                 enemies.push(e);
             }
        }
    }

    draw() {
        if (this.x < -200 || this.x > width+200 || this.y < -200 || this.y > height+200) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(G_SCALE, G_SCALE); 

        const barW = this.isBoss ? 100 : 40;
        if (!this.isBoss) { 
            ctx.fillStyle = "red";
            ctx.fillRect(-barW/2, -this.radius/G_SCALE - 15, barW, 4);
            ctx.fillStyle = "#0f0"; ctx.fillRect(-barW/2, -this.radius/G_SCALE - 15, barW * (Math.max(0, this.hp)/this.maxHp), 4);
        }
        if (this.eliteMod) {
            ctx.strokeStyle = "#ff00ff";
            ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0,0,this.radius/G_SCALE + 5, 0, Math.PI*2); ctx.stroke();
        }

        ctx.rotate(this.angle);
        // Status Visuals
        if (this.isStunned || this.freezeTimer > 0) ctx.fillStyle = "cyan";
        else if (this.poisonTimer > 0) ctx.fillStyle = "#00ff00";
        else if (this.burnTimer > 0) ctx.fillStyle = "#ffaa00";
        else if (this.vulnTimer > 0) ctx.fillStyle = "#ff88ff";
        else ctx.fillStyle = this.col;

        let r = this.radius / G_SCALE;
        // Draw Legs
        if (this.legs.length > 0) {
            ctx.strokeStyle = "#444";
            ctx.lineWidth = 4;
            this.legs.forEach(l => {
                let dx = l.x - this.x; let dy = l.y - this.y;
                let lx = dx * Math.cos(-this.angle) - dy * Math.sin(-this.angle);
                let ly = dx * Math.sin(-this.angle) + dy * Math.cos(-this.angle);
                lx /= G_SCALE; ly /= G_SCALE;
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(lx/2, ly/2); ctx.lineTo(lx, ly); ctx.stroke();
            });
        }
        
        ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
        if(this.visual === 'insect') { ctx.fillStyle="#000"; ctx.beginPath(); ctx.arc(r*0.5,0,r*0.3,0,Math.PI*2); ctx.fill(); }
        
        ctx.restore();
    }
}

class Projectile {
    constructor(x, y, angle, stats, type = 'orb') {
        this.x = x; this.y = y; 
        this.vx = Math.cos(angle)*stats.speed; this.vy = Math.sin(angle)*stats.speed;
        this.pen = stats.pen;
        this.dmg = 40 * dragonAtk * stats.damageMult;
        this.size = stats.size;
        this.explodes = (stats.damageMult >= 1.5 && UPGRADES.some(u => u.name === "Armageddon" && myUpgrades.includes(u)));
        this.range = stats.range || 2000;
        this.traveled = 0;
        this.type = type; // 'orb', 'short', 'mid'
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        this.traveled += Math.hypot(this.vx, this.vy);
        if (this.traveled > this.range) return true;

        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            if (Math.hypot(this.x - e.x, this.y - e.y) < e.radius + (this.size + 5)) {
                e.takeDamage(this.dmg);
                // Apply random status if Disco
                if (discoMode && Math.random() < 0.2) e.applyStatus(['burn','poison','freeze','vuln'][Math.floor(Math.random()*4)], 180, this.dmg);
                
                if (this.explodes) {
                    ctx.fillStyle = "rgba(255, 100, 0, 0.5)";
                    ctx.beginPath(); ctx.arc(this.x, this.y, 100 * G_SCALE, 0, Math.PI*2); ctx.fill();
                    enemies.forEach(subE => {
                        if (Math.hypot(subE.x - this.x, subE.y - this.y) < 100 * G_SCALE) {
                             subE.takeDamage(this.dmg * 0.5);
                        }
                    });
                }
                this.pen--;
                ctx.fillStyle = "white";
                ctx.beginPath(); ctx.arc(this.x,this.y, 5, 0, Math.PI*2); ctx.fill();
                if (this.pen <= 0) return true;
            }
        }
        return (this.x < -100 || this.x > width+100 || this.y < -100 || this.y > height+100);
    }
    draw() {
        ctx.fillStyle = this.type === 'short' ? "#ff5500" : (this.type === 'mid' ? "#00ffaa" : COLORS.glow);
        ctx.shadowBlur = 10;
        ctx.shadowColor = ctx.fillStyle;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
    }
}

// --- CORE LOGIC ---
function takeDamage(amount) {
    if (Math.random() < dodgeChance) {
        damageNumbers.push(new FloatingText(spine[0].x, spine[0].y, "DODGE", "#00ffcc", 20));
        if (unlockedGhost && !ghostActive) ghostMeter = Math.min(ghostMaxMeter, ghostMeter + 10);
        return; 
    }
    if (ghostPhaseShift && Math.random() < 0.25) { 
        damageNumbers.push(new FloatingText(spine[0].x, spine[0].y, "PHASE", "#9900ff", 20));
        spine.forEach(s => { s.x += (Math.random()-0.5)*300; s.y += (Math.random()-0.5)*300; });
        return;
    }
    if ((furyInvuln && furyActive) || (unlockedGhost && ghostActive)) {
         damageNumbers.push(new FloatingText(spine[0].x, spine[0].y, "INVULN", "#ff0000", 20));
         return;
    }

    // Protection from One-Shot
    // Max damage taken per hit is 30% of max HP unless it's a specific mechanic
    let maxHit = dragonMaxHP * 0.3;
    if (amount > maxHit) amount = maxHit;

    amount *= dmgTakenMult;
    // Overload Buff Reduction
    if (overloadActive) amount *= 0.5;

    if (hasBloodLust) amount *= 1.3;
    let mitigation = Math.min(dragonDefPct, 0.85); 
    amount *= (1 - mitigation);
    
    // Shield Logic
    if (dragonShield > 0) {
        if (dragonShield >= amount) { dragonShield -= amount; amount = 0; } 
        else { 
            amount -= dragonShield; dragonShield = 0;
            if (shieldExplode) {
                enemies.forEach(e => {
                    if (Math.hypot(e.x - spine[0].x, e.y - spine[0].y) < 300) {
                        e.takeDamage(100 * dragonAtk); e.x += (e.x - spine[0].x) * 2;
                    }
                });
                ctx.fillStyle = "rgba(0, 255, 255, 0.5)"; ctx.beginPath(); ctx.arc(spine[0].x, spine[0].y, 300, 0, Math.PI*2); ctx.fill();
            }
            if (shieldStunBreak) {
                enemies.forEach(e => {
                    if (Math.hypot(e.x - spine[0].x, e.y - spine[0].y) < 400) e.applyStun(120);
                });
            }
        }
        shieldCooldown = 180;
    }
    if (amount > 0) {
        dragonHP -= amount;
        ctx.fillStyle = "rgba(255,0,0,0.3)"; ctx.fillRect(0,0,width,height); 
        if (dragonHP <= 0 && reviveCount > 0) {
            reviveCount--;
            dragonHP = dragonMaxHP * 0.5;
            enemies.forEach(e => {
                let d = Math.hypot(spine[0].x - e.x, spine[0].y - e.y);
                if (d < 500) e.x += (e.x - spine[0].x) * 2; 
            });
            damageNumbers.push(new FloatingText(spine[0].x, spine[0].y, "REVIVED!", "#ffff00", 50));
            gameActive = true;
        }
    }
}

function checkLaserHit(enemy, head, count, angleOffset) {
    const spread = 0.15;
    const totalSpread = spread * (count - 1);
    const startAngle = (head.angle + angleOffset) - (totalSpread / 2);
    const range = Math.hypot(width, height) * 1.5; 
    const laserPhysWidth = (20 * VISUAL_SCALE * laserWidthBase) + enemy.radius;
    for(let i=0; i<count; i++) {
        const beamAngle = startAngle + (i * spread);
        const p1 = { x: head.x, y: head.y };
        const p2 = { x: head.x + Math.cos(beamAngle) * range, y: head.y + Math.sin(beamAngle) * range };
        const l2 = (p1.x - p2.x)**2 + (p1.y - p2.y)**2;
        let t = ((enemy.x - p1.x) * (p2.x - p1.x) + (enemy.y - p1.y) * (p2.y - p1.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        const distSq = (enemy.x - (p1.x + t * (p2.x - p1.x)))**2 + (enemy.y - (p1.y + t * (p2.y - p1.y)))**2;
        if (distSq < laserPhysWidth * laserPhysWidth) {
            
            // VOID CANNON LOGIC
            if (laserType === 'void') {
                // 0.05% Max HP + Flat damage based on Attack.
                let pctDmg = 0.0005; 
                
                if (enemy.isBoss) pctDmg *= 0.1;

                let flatDmg = 3 * dragonAtk;
                enemy.takeDamage((enemy.maxHp * pctDmg) + flatDmg);
            }
            
            let dmg = 6 * dragonAtk * laserDmgMult;
            if (laserType === 'shotgun') dmg *= 2;
            
            if (discoMode) {
                 if (Math.random() < 0.05) enemy.applyStatus('burn', 180, dmg*0.5);
                 else if (Math.random() < 0.05) enemy.applyStatus('freeze', 60, 0);
            }
            
            // Apply Chance Statuses
            if (Math.random() < poisonChance) enemy.applyStatus('poison', 180, 0);
            if (Math.random() < burnChance) enemy.applyStatus('burn', 180, dmg * 0.5);
            if (Math.random() < freezeChance) enemy.applyStatus('freeze', 60, 0);
            if (Math.random() < weakChance) enemy.applyStatus('weak', 180, 0);
            if (Math.random() < vulnChance) enemy.applyStatus('vuln', 180, 0);

            enemy.takeDamage(dmg);
            break;
        }
    }
}

function levelUp(isReroll = false) {
    if (!isReroll) {
        isPaused = true;
        exp -= expNext;
        expNext = Math.floor(expNext * 1.2) + 500; 
        level++;
        healPct(0.3); 
        canReroll = true;
    }
    if (!isReroll) upgradeChoices = [];
    if (upgradeChoices.length === 0 || isReroll) upgradeChoices = generateChoices(4);
    updateCardBounds();
}

function generateChoices(count) {
    let choices = [];
    let pool = UPGRADES.filter(u => !u.req || u.req() === true);
    const weights = [60, 25, 10, 5, 1, 0.1];
    while(choices.length < count && pool.length > 0) {
        let rRoll = Math.random() * 100;
        let selectedRarity = 0;
        let cumulative = 0;
        for(let i=0; i<weights.length; i++) {
            cumulative += weights[i];
            if (rRoll <= cumulative) { selectedRarity = i; break; }
        }
        let rarityPool = pool.filter(u => u.r === selectedRarity);
        if (rarityPool.length === 0) rarityPool = pool; 
        let idx = Math.floor(Math.random() * rarityPool.length);
        let choice = rarityPool[idx];
        if (!choices.includes(choice)) { choices.push(choice); }
    }
    return choices;
}

function updateCardBounds() {
    const cardW = 280 * G_SCALE * 1.5;
    const cardH = 400 * G_SCALE * 1.5;
    const gap = 30 * G_SCALE;
    const totalW = (cardW * 4) + (gap * 3);
    const startX = (width - totalW) / 2;
    cardBounds = upgradeChoices.map((_, i) => ({
        x: startX + i * (cardW + gap), y: height/2 - (200 * G_SCALE), w: cardW, h: cardH
    }));
}

function selectUpgrade(index) {
    let u = upgradeChoices[index];
    u.run();
    myUpgrades.push(u);
    upgradeChoices = [];
    isPaused = false;
}

function spawnWave() {
    wave++;
    const count = 10 + Math.floor(wave * 2.5);
    const types = [];
    if (wave <= 5) types.push('swarmer', 'fly', 'mite', 'wasp');
    if (wave >= 2) types.push('charger', 'drone', 'shooter'); 
    if (wave >= 3) types.push('splitter');
    if (wave > 5) types.push('drone', 'swarmer', 'wasp', 'splitter');
    if (wave > 8) types.push('grunt', 'shielded', 'lancer');
    if (wave > 12) types.push('shooter', 'sniper', 'hunter');
    if (wave > 15) types.push('zealot', 'dasher', 'webber');
    if (wave > 20) types.push('tank', 'phantom');
    if (wave > 25) types.push('glitch', 'tank');
    if (wave > 30) types.push('golem');
    if (wave > 40) types.push('mini_slayer', 'boss_ufo');
    if (wave % 5 === 0) {
        let bossType = 'mini_slayer';
        if (wave === 10) bossType = 'boss_hydra'; 
        else if (wave === 20) bossType = 'boss_titan';
        else if (wave === 30) bossType = 'boss_ufo';
        else if (wave === 40) bossType = 'mini_mecha';
        else if (wave >= 50 && wave % 10 === 0) bossType = 'boss_hydra'; 
        enemies.push(new Enemy(bossType, wave));
    }
    for (let i=0; i<count; i++) {
        let t = types[Math.floor(Math.random() * types.length)];
        enemies.push(new Enemy(t, wave));
    }
}

// --- VISUALS ---
function drawLaserFan(head, count, angleOffset, colorOverride) {
    const spread = 0.15;
    const totalSpread = spread * (count - 1);
    const startAngle = (head.angle + angleOffset) - (totalSpread / 2);
    let laserCol = furyActive ? COLORS.fury : (laserType === 'plasma' ? COLORS.plasma : (laserType === 'void' ? COLORS.void : COLORS.laser));
    if (discoMode) laserCol = `hsl(${frame * 5}, 100%, 50%)`;

    ctx.shadowBlur = furyActive ? 50 : 35; 
    ctx.shadowColor = laserCol;
    ctx.strokeStyle = colorOverride || laserCol;
    ctx.lineWidth = 10 * VISUAL_SCALE * laserWidthBase;
    for(let i=0; i<count; i++) {
        const a = startAngle + (i * spread);
        const startX = head.x + Math.cos(a)*45*VISUAL_SCALE;
        const startY = head.y + Math.sin(a)*45*VISUAL_SCALE;
        const range = Math.max(width, height) * 1.5;
        ctx.beginPath();
        ctx.moveTo(startX, startY); ctx.lineTo(startX+Math.cos(a)*range, startY+Math.sin(a)*range); ctx.stroke();
    }
}

function drawLasers(head) {
    if (!mouse.down && autoTurretCount === 0) return;
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    if (mouse.down) {
        drawLaserFan(head, laserCount, 0);
        if(laserRear > 0) drawLaserFan(head, laserRear, Math.PI); 
        if(laserSide > 0) {
            drawLaserFan(head, laserSide, Math.PI/2);
            drawLaserFan(head, laserSide, -Math.PI/2);
        }
    }
    if (tailTurret) {
         let tail = spine[spine.length-1];
         drawLaserFan(tail, 1, Math.PI);
         if (frame % 5 === 0) {
             let nearest = enemies[0];
             if(nearest) checkLaserHit(nearest, tail, 1, Math.PI);
         }
    }
    if (autoTurretCount > 0) {
        let nearest = null;
        let minD = Infinity;
        enemies.forEach(e => {
            let d = Math.hypot(e.x - head.x, e.y - head.y);
            if(d < minD) { minD = d; nearest = e; }
        });
        if (nearest && minD < 600 * G_SCALE) {
            ctx.shadowBlur = 10;
            ctx.strokeStyle = "#ff00ff"; ctx.lineWidth = 5 * VISUAL_SCALE;
            ctx.beginPath(); ctx.moveTo(head.x, head.y); ctx.lineTo(nearest.x, nearest.y); ctx.stroke();
        }
    }
    ctx.restore();
}

function drawShockwave(spine) {
    if(!shockwaveEnabled) return;
    if(shockwaveActiveFrame > 0) {
        const center = spine[Math.floor(spine.length/2)];
        ctx.save();
        ctx.strokeStyle = COLORS.shockwave;
        ctx.lineWidth = 5 + (shockwaveActiveFrame);
        ctx.globalAlpha = shockwaveActiveFrame / 10;
        ctx.beginPath(); ctx.arc(center.x, center.y, shockwaveRange, 0, Math.PI*2); ctx.stroke();
        ctx.fillStyle = "rgba(255, 255, 0, 0.2)"; ctx.fill();
        ctx.restore();
        shockwaveActiveFrame--;
    }
}

function drawShield(head) {
    if(dragonShield > 0) {
        ctx.save();
        ctx.strokeStyle = COLORS.shield;
        ctx.lineWidth = 3 + Math.sin(frame*0.1)*1;
        ctx.shadowBlur = 10; ctx.shadowColor = "cyan";
        ctx.beginPath();
        ctx.arc(head.x, head.y, 60 * VISUAL_SCALE, 0, Math.PI*2);
        ctx.stroke();
        ctx.globalAlpha = 0.1; ctx.fillStyle = COLORS.shield; ctx.fill();
        ctx.restore();
    }
}

function drawDragonBone(x1, y1, x2, y2, thickness, isWing = false) {
    const dist = Math.hypot(x2 - x1, y2 - y1);
    const angle = Math.atan2(y2 - y1, x2 - x1);
    ctx.save();
    ctx.translate(x1, y1); ctx.rotate(angle);
    ctx.fillStyle = isWing ? "rgba(0, 150, 255, 0.25)" : (furyActive ? "#330000" : (ghostActive ? "#222" : (voidActive ? "#100020" : (holyActive ? "#fff8e0" : COLORS.bone))));
    ctx.strokeStyle = furyActive ? "#ff3300" : (ghostActive ? "#888" : (voidActive ? "#a0a" : (holyActive ? "#ffd700" : COLORS.accent)));
    ctx.shadowBlur = (furyActive || voidActive || holyActive) ? 15 : 0; 
    ctx.shadowColor = furyActive ? "red" : (voidActive ? "purple" : (holyActive ? "gold" : "cyan"));
    ctx.beginPath();
    ctx.moveTo(0, -thickness * 0.7);
    ctx.quadraticCurveTo(dist / 2, -thickness * 0.2, dist, -thickness * 0.7);
    ctx.lineTo(dist, thickness * 0.7);
    ctx.quadraticCurveTo(dist / 2, thickness * 0.2, 0, thickness * 0.7);
    ctx.fill(); ctx.stroke();
    ctx.restore();
}

function drawWings(anchor) {
    const flap = Math.sin(frame * CONFIG.wingFlapSpeed);
    const drawSide = (isLeft) => {
        let side = isLeft ? -1 : 1;
        let a1 = anchor.angle + (side * 1.5) + (flap * 0.2 * side);
        let armLen = CONFIG.wingSpan * 0.35;
        let j1X = anchor.x + Math.cos(a1) * armLen, j1Y = anchor.y + Math.sin(a1) * armLen;
        let a2 = a1 + (0.6 * side) + (flap * 0.1 * side);
        let foreLen = CONFIG.wingSpan * 0.45;
        let j2X = j1X + Math.cos(a2) * foreLen, j2Y = j1Y + Math.sin(a2) * foreLen;
        let fingerPoints = [];
        for (let i = 0; i < 4; i++) {
            let fA = a2 + (0.4 + i * 0.5) * side + (flap * 0.05);
            let fLen = CONFIG.wingSpan * (0.9 - i * 0.15);
            fingerPoints.push({ x: j2X + Math.cos(fA) * fLen, y: j2Y + Math.sin(fA) * fLen });
        }
        ctx.fillStyle = furyActive ? "rgba(255, 0, 0, 0.15)" : "rgba(0, 120, 255, 0.15)";
        ctx.beginPath(); ctx.moveTo(anchor.x, anchor.y); ctx.lineTo(j1X, j1Y); ctx.lineTo(j2X, j2Y);
        fingerPoints.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.fill();
        drawDragonBone(anchor.x, anchor.y, j1X, j1Y, 9 * VISUAL_SCALE, true);
        drawDragonBone(j1X, j1Y, j2X, j2Y, 7 * VISUAL_SCALE, true);
        fingerPoints.forEach(p => drawDragonBone(j2X, j2Y, p.x, p.y, 3 * VISUAL_SCALE, true));
    };
    drawSide(true); drawSide(false);
}

function drawDragonHead(s) {
    ctx.save();
    ctx.translate(s.x, s.y); ctx.rotate(s.angle); ctx.scale(VISUAL_SCALE, VISUAL_SCALE);
    ctx.fillStyle = furyActive ? "#330000" : (ghostActive ? "#111" : (voidActive ? "#100020" : (holyActive ? "#fff8e0" : COLORS.bone))); 
    ctx.strokeStyle = furyActive ? "#ff0000" : (ghostActive ? "#fff" : (voidActive ? "#a0a" : (holyActive ? "#ffd700" : COLORS.accent)));
    const drawHorn = (side) => {
        ctx.save();
        ctx.beginPath(); ctx.moveTo(-12, side * 8);
        ctx.quadraticCurveTo(-35, side * 40, -75, side * 35);
        ctx.lineTo(-72, side * 34);
        ctx.quadraticCurveTo(-32, side * 32, -18, side * 12);
        ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();
    };
    drawHorn(1); drawHorn(-1);
    ctx.beginPath(); ctx.moveTo(-20, -12); ctx.lineTo(12, -18);
    ctx.lineTo(48, -4);
    ctx.lineTo(50, 0); ctx.lineTo(48, 4); ctx.lineTo(12, 18);
    ctx.lineTo(-20, 12);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle = furyActive ? "#ff0000" : COLORS.glow;
    ctx.shadowBlur = 15; ctx.shadowColor = ctx.fillStyle;
    ctx.beginPath();
    ctx.arc(15, -8, 4, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath();
    ctx.arc(15, 8, 4, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
}

function drawUI() {
    canvas.style.cursor = isPaused ? "default" : "none";
    ctx.fillStyle = "#111"; ctx.fillRect(0, 0, width, 10);
    ctx.fillStyle = COLORS.glow; ctx.fillRect(0, 0, width * (exp/expNext), 10);
    ctx.textAlign = "left"; ctx.fillStyle = "white";
    ctx.font = `bold ${16 * G_SCALE * 1.5}px monospace`;
    ctx.fillText(`LVL ${level} | WAVE ${wave}`, 20, 35);
    ctx.fillText(`ATK ${dragonAtk.toFixed(1)} | DEF ${(dragonDefPct*100).toFixed(0)}% (Cap 75%)`, 20, 55);
    ctx.fillText(`CRIT ${(critChance*100).toFixed(0)}% (Cap 100%)`, 20, 75);
    
    let yPos = 100;
    const drawMeter = (name, val, color, active, activeColor) => {
        ctx.fillStyle = active ? activeColor : "#fff";
        ctx.fillText(name, 20, yPos);
        ctx.fillStyle = "#111"; ctx.fillRect(80, yPos-12, 100, 12);
        ctx.fillStyle = active ? activeColor : color; ctx.fillRect(80, yPos-12, val, 12);
        ctx.strokeStyle = "#fff"; ctx.strokeRect(80, yPos-12, 100, 12);
        yPos += 20;
    };

    if (furyEnabled) drawMeter("FURY", furyMeter, "#800", furyActive, "#f00");
    if (unlockedGhost) drawMeter("GHOST", ghostMeter, "#444", ghostActive, "#ccc");
    if (unlockedVoid) drawMeter("VOID", voidMeter, "#305", voidActive, "#a0a");
    if (unlockedHoly) drawMeter("HOLY", holyMeter, "#860", holyActive, "#fd0");

    if (overloadActive) {
        ctx.fillStyle = "#ff00ff"; ctx.fillText(">> OVERLOAD <<", 200, 100);
    }
    
    if (reviveCount > 0) ctx.fillText(`REVIVES: ${reviveCount}`, 20, yPos + 20);

    let bosses = enemies.filter(e => e.isBoss);
    if (bosses.length > 0) {
        let boss = bosses[0];
        let bw = 600 * G_SCALE; let bh = 20; let bx = width/2 - bw/2;
        ctx.fillStyle = "#330000";
        ctx.fillRect(bx, 50, bw, bh);
        ctx.fillStyle = boss.type.includes('mini') ? "#aa00aa" : "#ff0000"; ctx.fillRect(bx, 50, bw * (Math.max(0,boss.hp)/boss.maxHp), bh);
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2; ctx.strokeRect(bx, 50, bw, bh);
        ctx.fillStyle = "#fff"; ctx.textAlign = "center";
        ctx.fillText(boss.type.toUpperCase(), width/2, 45);
    }

    const barW = 400 * G_SCALE * 1.5;
    const bx = width/2 - barW/2;
    ctx.fillStyle = "#222"; ctx.fillRect(bx, height - 30, barW, 20);
    const hpPct = Math.min(1, Math.max(0, dragonHP/dragonMaxHP));
    ctx.fillStyle = hpPct > 0.3 ? (furyActive ? "#ffaa00" : "lime") : "red";
    ctx.fillRect(bx, height - 30, barW * hpPct, 20);
    ctx.strokeStyle = "#fff"; ctx.strokeRect(bx, height-30, barW, 20);
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center"; ctx.fillText(`${Math.floor(dragonHP)}/${Math.floor(dragonMaxHP)}`, width/2, height - 15);
    
    if (dragonShield > 0) {
        const shPct = Math.min(1, dragonShield / dragonMaxShield);
        ctx.fillStyle = "cyan"; ctx.fillRect(bx, height - 35, barW * shPct, 5);
    }

    if (isPaused) {
        ctx.fillStyle = "rgba(0,0,0,0.9)"; ctx.fillRect(0,0,width,height);
        ctx.textAlign = "center"; 
        ctx.fillStyle = COLORS.glow; ctx.font = "bold 40px monospace";
        ctx.shadowBlur = 20; ctx.shadowColor = COLORS.glow;
        ctx.fillText("EVOLUTION", width/2, height/2 - 300);
        ctx.shadowBlur = 0;
        
        upgradeChoices.forEach((c, i) => {
            const b = cardBounds[i];
            let rColor = COLORS.common;
            if(c.r===1) rColor=COLORS.rare; if(c.r===2) rColor=COLORS.epic;
            if(c.r===3) rColor=COLORS.legendary; if(c.r===4) rColor=COLORS.cursed;
            if(c.r===5) rColor=COLORS.mythic;

            ctx.fillStyle = "#050a14"; ctx.fillRect(b.x, b.y, b.w, b.h);
            ctx.strokeStyle = rColor; ctx.lineWidth = 4; ctx.strokeRect(b.x, b.y, b.w, b.h);
            
            let grad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.h);
            grad.addColorStop(0, rColor); grad.addColorStop(1, "transparent");
            ctx.fillStyle = grad; ctx.globalAlpha = 0.2; ctx.fillRect(b.x, b.y, b.w, b.h);
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = rColor; ctx.font = `bold ${18 * G_SCALE * 1.5}px monospace`; 
            ctx.fillText(c.name, b.x + b.w/2, b.y + 60);
            
            let rText = ["COMMON", "RARE", "EPIC", "LEGENDARY", "CURSED", "MYTHIC"][c.r];
            ctx.font = `bold 14px monospace`; ctx.fillText(rText, b.x + b.w/2, b.y + 85);

            ctx.fillStyle = "white";
            ctx.font = `${14 * G_SCALE * 1.5}px monospace`;
            wrapText(ctx, c.desc, b.x + b.w/2, b.y + 140, b.w - 40, 24);
            ctx.fillStyle = rColor; ctx.font = `bold ${16 * G_SCALE * 1.5}px monospace`;
            ctx.fillText("[ CLICK TO SELECT ]", b.x + b.w/2, b.y + b.h - 40);
            if (canReroll) {
                let btnW = 80;
                let btnH = 30; let btnX = b.x + b.w/2 - btnW/2; let btnY = b.y + b.h + 10;
                ctx.fillStyle = "#333"; ctx.fillRect(btnX, btnY, btnW, btnH);
                ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.strokeRect(btnX, btnY, btnW, btnH);
                ctx.fillStyle = "#fff";
                ctx.font = "bold 16px monospace";
                ctx.fillText("REROLL", btnX + btnW/2, btnY + 20);
            }
        });
        ctx.fillStyle = "white";
        ctx.font = "16px monospace"; ctx.textAlign = "left";
        ctx.fillText("STATS / UPGRADES:", 20, height - 150);
        let txt = myUpgrades.map(u => u.name).join(", ");
        wrapText(ctx, txt, 20, height - 120, width - 40, 20);
    }
}

function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    let words = text.split(' ');
    let line = '';
    for(let n = 0; n < words.length; n++) {
        let testLine = line + words[n] + ' ';
        let metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && n > 0) {
            ctx.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
        } else { line = testLine; }
    }
    ctx.fillText(line, x, y);
}

// --- MAIN LOOP ---
function update() {
    if (!gameActive || isPaused) return;
    frame++;
    if (enemies.length === 0) spawnWave();

    let head = spine[0];
    let speed = mouse.down ? CONFIG.headSpeed * 0.15 : CONFIG.headSpeed;
    if (furyActive) speed *= 1.5;
    if (overloadActive) speed *= 2.0; // Overload speed buff
    speed *= moveSpeedMult;

    head.x += (mouse.x - head.x) * speed;
    head.y += (mouse.y - head.y) * speed;
    head.angle = Math.atan2(mouse.y - head.y, mouse.x - head.x);
    for (let i=1; i<spine.length; i++) {
        let p = spine[i-1], c = spine[i];
        let a = Math.atan2(p.y - c.y, p.x - c.x);
        c.angle = a; c.x = p.x - Math.cos(a)*CONFIG.segmentDist;
        c.y = p.y - Math.sin(a)*CONFIG.segmentDist;
    }
    legs.forEach(leg => {
        let body = spine[leg.anchorIndex], side = leg.isLeft ? -1.6 : 1.6;
        let iX = body.x + Math.cos(body.angle + side) * (115 * VISUAL_SCALE), iY = body.y + Math.sin(body.angle + side) * (115 * VISUAL_SCALE);
        if (!leg.isStepping && Math.hypot(iX - leg.x, iY - leg.y) > 95 * VISUAL_SCALE) {
            leg.isStepping = true; leg.stepProgress = 0; leg.stepStartX = leg.x; leg.stepStartY = leg.y;
            leg.targetX = iX + Math.cos(body.angle) * (70 * VISUAL_SCALE); leg.targetY = iY + Math.sin(body.angle) * (70 * VISUAL_SCALE);
        }
        if (leg.isStepping) {
            leg.stepProgress += CONFIG.legSpeed;
            if (leg.stepProgress >= 1) { leg.isStepping = false; leg.x = leg.targetX; leg.y = leg.targetY; }
            else {
                let t = leg.stepProgress;
                leg.x = leg.stepStartX + (leg.targetX - leg.stepStartX) * t; leg.y = leg.stepStartY + (leg.targetY - leg.stepStartY) * t;
                leg.lift = Math.sin(t * Math.PI) * (45 * VISUAL_SCALE);
            }
        }
    });

    if(shieldCooldown > 0) shieldCooldown--;
    if(frame % 60 === 0) {
        if(dragonHP < dragonMaxHP && dragonRegen > 0) dragonHP = Math.min(dragonMaxHP, dragonHP + dragonRegen * 60);
        if(shieldCooldown <= 0 && dragonShield < dragonMaxShield) {
            dragonShield = Math.min(dragonMaxShield, dragonShield + dragonShieldRegen * 60);
        }
    }

    // --- METER LOGIC ---
    let anyMeterActivated = false;

    // FURY
    if (furyEnabled && !furyActive && furyMeter < 100) furyMeter += (0.05 + furyRegenPassive);
    if (furyEnabled && furyMeter >= 100 && !furyActive) {
        furyActive = true; furyTimer = furyDuration; shockwaveEnabled = true; anyMeterActivated = true;
        if (furyExplosion) {
             enemies.forEach(e => { if (Math.hypot(e.x - head.x, e.y - head.y) < 500) e.takeDamage(200 * dragonAtk); });
             ctx.fillStyle = "rgba(255, 0, 0, 0.5)"; ctx.beginPath(); ctx.arc(head.x, head.y, 500, 0, Math.PI*2); ctx.fill();
        }
    }
    if (furyActive) {
        furyTimer--; furyMeter = (furyTimer / furyDuration) * 100;
        if (furyTimer <= 0) { 
            furyActive = false; furyMeter = 0; 
            if(furyEndExplosion) {
                enemies.forEach(e => { if (Math.hypot(e.x - head.x, e.y - head.y) < 600) e.takeDamage(500 * dragonAtk); });
                ctx.fillStyle = "rgba(255, 100, 0, 0.7)"; ctx.beginPath(); ctx.arc(head.x, head.y, 600, 0, Math.PI*2); ctx.fill();
            }
        }
    }

    // GHOST (Activated by Space or Auto? Current code says Space. Let's make it auto for consistency with prompt desire "toggle logic")
    // Wait, prompt asked "Can they toggle at one time?" I'll keep spacebar for Ghost manual, others auto.
    if (unlockedGhost && !ghostActive && ghostMeter < ghostMaxMeter) ghostMeter += (0.05 + ghostRegen);
    if (ghostActive) {
        ghostMeter -= 0.5;
        if (ghostMeter <= 0) ghostActive = false;
    }

    // VOID
    if (unlockedVoid && !voidActive && voidMeter >= 100) {
        voidActive = true; voidTimer = voidDuration; anyMeterActivated = true;
    }
    if (voidActive) {
        voidTimer--; voidMeter = (voidTimer / voidDuration) * 100;
        if (voidTimer <= 0) { voidActive = false; voidMeter = 0; }
    }

    // HOLY
    if (unlockedHoly && !holyActive && holyMeter >= 100) {
        holyActive = true; holyTimer = holyDuration; anyMeterActivated = true;
        // Cleanse
        if (holyHealTick > 0) { 
            // Heal flat amount initially
            dragonHP = Math.min(dragonMaxHP, dragonHP + 250); 
        }
    }
    if (holyActive) {
        holyTimer--; holyMeter = (holyTimer / holyDuration) * 100;
        if (frame % 30 === 0 && holyHealTick > 0) dragonHP = Math.min(dragonMaxHP, dragonHP + holyHealTick);
        if (frame % 60 === 0 && holySmiteChance > 0) {
             let target = enemies[Math.floor(Math.random()*enemies.length)];
             if(target) {
                 target.takeDamage(100 * dragonAtk);
                 lightningEffects.push(new LightningEffect(head.x, head.y, target.x, target.y));
             }
        }
        if (holyTimer <= 0) { holyActive = false; holyMeter = 0; }
    }

    // OVERLOAD
    if (anyMeterActivated) {
        overloadActive = true; overloadTimer = 180; // 3 Seconds
    }
    if (overloadActive) {
        overloadTimer--;
        if (overloadTimer <= 0) overloadActive = false;
    }

    // GAMBLER
    if (gamblerMode) {
        gamblerTimer++;
        if (gamblerTimer > 600) {
             gamblerTimer = 0;
             dragonBaseAtk = dragonBaseAtk * (0.8 + Math.random() * 0.4);
             updateStatsBySize();
             damageNumbers.push(new FloatingText(head.x, head.y, "REROLL STATS", "#fff", 30));
        }
    }

    if (timeStopActive) {
        timeStopTimer--;
        if (timeStopTimer <= 0) timeStopActive = false;
        else return; 
    }
    if (timeStopChance > 0 && !timeStopActive && frame % 600 === 0 && Math.random() < timeStopChance) {
        timeStopActive = true; timeStopTimer = 120;
    }

    if(shockwaveEnabled) {
        shockwaveTimer++;
        if(shockwaveTimer > (furyActive ? 30 : shockwaveInterval)) { 
            shockwaveTimer = 0;
            shockwaveActiveFrame = 15;
            const center = spine[Math.floor(spine.length/2)];
            enemies.forEach(e => {
                let d = Math.hypot(center.x - e.x, center.y - e.y);
                if(d < shockwaveRange) {
                    e.takeDamage(shockwaveDmg * dragonAtk);
                    if(!e.isBoss) {
                        let a = Math.atan2(e.y - center.y, e.x - center.x);
                        let push = 150 * G_SCALE * knockbackStr;
                        e.x += Math.cos(a) * push; e.y += Math.sin(a) * push;
                    }
                }
            });
        }
    }
    
    // WEAPON FIRE LOGIC
    let effectiveFireRate = fireRateMult;
    if (shieldAmpFire && dragonShield > 0) effectiveFireRate *= 1.15;

    // ORBS (Long Range)
    if (mouse.down && orbLevel > 0) {
        const fireRate = Math.max(1, (20 - (orbLevel * 2)) / effectiveFireRate);
        if (frame % Math.floor(fireRate) === 0) {
            projectiles.push(new Projectile(head.x, head.y, head.angle, orbStats, 'orb'));
            if (orbLevel >= 3) { 
                projectiles.push(new Projectile(head.x, head.y, head.angle + 0.3, orbStats, 'orb'));
                projectiles.push(new Projectile(head.x, head.y, head.angle - 0.3, orbStats, 'orb'));
            }
        }
    }

    // SPARKS (Short Range)
    if (mouse.down && unlockedShort) {
        const fireRate = Math.max(1, 15 / effectiveFireRate); // Fast
        if (frame % Math.floor(fireRate) === 0) {
            for(let i=0; i<shortStats.count; i++) {
                let spread = (Math.random()-0.5) * 0.8;
                projectiles.push(new Projectile(head.x, head.y, head.angle + spread, shortStats, 'short'));
            }
        }
    }

    // BOLTS (Mid Range)
    if (mouse.down && unlockedMid) {
        const fireRate = Math.max(1, 45 / effectiveFireRate); // Slow
        if (frame % Math.floor(fireRate) === 0) {
            for(let i=0; i<midStats.count; i++) {
                let spread = (i - (midStats.count-1)/2) * 0.2;
                projectiles.push(new Projectile(head.x, head.y, head.angle + spread, midStats, 'mid'));
            }
        }
    }
    
    // Summons Logic
    if (unlockedMissiles && frame % Math.floor(60 / effectiveFireRate) === 0) {
        for(let m=0; m<missileCount; m++) summons.push(new Missile(head.x, head.y));
    }
    if (unlockedMines && frame % 120 === 0) summons.push(new Mine(head.x, head.y));
    // Boomerangs
    if (unlockedBoomerang && frame % Math.floor(90 / effectiveFireRate) === 0) {
        for(let b=0; b<boomerangCount; b++) summons.push(new Boomerang(head.x, head.y, (b*0.5) - ((boomerangCount-1)*0.25)));
    }
    // Grenades
    if (unlockedGrenade && frame % Math.floor(120 / effectiveFireRate) === 0) {
        for(let g=0; g<grenadeCount; g++) {
             let tx = mouse.x + (Math.random()-0.5)*200;
             let ty = mouse.y + (Math.random()-0.5)*200;
             summons.push(new Grenade(head.x, head.y, tx, ty));
        }
    }
    
    saws.forEach(s => s.update(head));
    if (!mouse.down && dragonHP < dragonMaxHP && frame % 60 === 0) {
        dragonHP = Math.min(dragonMaxHP, dragonHP + 5);
    }
    
    enemies.forEach((e, i) => {
        e.update();
        if (e.hp <= 0) { 
            score += 10; gems.push(new ExpGem(e.x, e.y, e.xp)); 
            enemies.splice(i, 1); 
        }
      });
    damageNumbers = damageNumbers.filter(d => d.update());
    lightningEffects = lightningEffects.filter(l => l.update()); 
    gems = gems.filter(g => !g.update());
    projectiles = projectiles.filter(p => !p.update());
    enemyProjectiles = enemyProjectiles.filter(p => !p.update());
    summons = summons.filter(s => !s.update());
    if (dragonHP <= 0) gameActive = false;
}

function draw() {
    ctx.fillStyle = timeStopActive ? "#111122" : "#00020a";
    ctx.fillRect(0, 0, width, height);
    
    drawLasers(spine[0]);
    drawShockwave(spine);
    if (reactorDmg > 0 || (voidActive)) {
        ctx.beginPath();
        let r = voidActive ? 400 * G_SCALE : 200 * VISUAL_SCALE * reactorRadiusMult;
        ctx.arc(spine[0].x, spine[0].y, r, 0, Math.PI*2);
        ctx.strokeStyle = voidActive ? "rgba(100, 0, 200, 0.2)" : "rgba(255, 100, 0, 0.1)"; 
        ctx.stroke();
    }

    gems.forEach(g => g.draw());
    summons.forEach(s => s.draw());
    lightningEffects.forEach(l => l.draw()); 
    projectiles.forEach(p => p.draw());
    enemyProjectiles.forEach(p => p.draw());
    enemies.forEach(e => e.draw());
    damageNumbers.forEach(d => d.draw());
    
    ctx.strokeStyle = COLORS.accent; ctx.lineWidth = 1;
    if (ghostActive) ctx.globalAlpha = 0.5;

    drawWings(spine[CONFIG.wingAttachment]);
    spine.forEach((s, i) => {
        let ribStart = 10, ribEnd = 50, ribSpan = ribEnd - ribStart;
        let ribW = (i > ribStart && i < ribEnd) ? Math.sin((i-ribStart)/ribSpan*Math.PI)*CONFIG.maxRibWidth : 0;
        if (ribW > 0) {
            let p = s.angle + Math.PI/2;
            ctx.beginPath(); ctx.moveTo(s.x + Math.cos(p)*ribW, s.y + Math.sin(p)*ribW);
            ctx.quadraticCurveTo(s.x - Math.cos(s.angle)*15*VISUAL_SCALE, s.y - Math.sin(s.angle)*15*VISUAL_SCALE, s.x - Math.cos(p)*ribW, s.y - Math.sin(p)*ribW);
            ctx.stroke();
        }
        if (i > 0) {
            ctx.lineWidth = i < 40 ? 5 * VISUAL_SCALE : 2 * VISUAL_SCALE;
            ctx.strokeStyle = furyActive ? "#ff3300" : (ghostActive ? "#fff" : (voidActive ? "#a0a" : (holyActive ? "#ffd700" : COLORS.accent)));
            ctx.beginPath(); 
            ctx.moveTo(spine[i - 1].x, spine[i - 1].y); ctx.lineTo(s.x, s.y); ctx.stroke();
        }
    });
    drawShield(spine[0]); 
    
    legs.forEach(leg => {
        let body = spine[leg.anchorIndex], hSide = leg.isLeft ? -1.5 : 1.5;
        let hX = body.x + Math.cos(body.angle + hSide) * (25 * VISUAL_SCALE), hY = body.y + Math.sin(body.angle + hSide) * (25 * VISUAL_SCALE);
        let dx = leg.x - hX, dy = (leg.y - leg.lift) - hY;
        let dist = Math.min(Math.sqrt(dx * dx + dy * dy), CONFIG.upperLegLen + CONFIG.lowerLegLen - 2);
        let a = Math.atan2(dy, dx), cos = (CONFIG.upperLegLen**2 + dist**2 - CONFIG.lowerLegLen**2) / (2 * CONFIG.upperLegLen * dist);
        let kneeA = leg.isLeft ? a + Math.acos(Math.max(-1, Math.min(1, cos))) : a - Math.acos(Math.max(-1, Math.min(1, cos)));
        let kX = hX + Math.cos(kneeA) * CONFIG.upperLegLen, kY = hY + Math.sin(kneeA) * CONFIG.upperLegLen;
        drawDragonBone(hX, hY, kX, kY, 8 * VISUAL_SCALE); drawDragonBone(kX, kY, leg.x, leg.y - leg.lift, 6 * VISUAL_SCALE);
    });
    drawDragonHead(spine[0]);
    
    ctx.globalAlpha = 1.0; 
    drawUI();
    if (!gameActive) {
        ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(0,0,width,height);
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.font = "50px monospace";
        ctx.fillText("GAME OVER", width/2, height/2);
        ctx.font = "20px monospace";
        ctx.fillText(`Max Level: ${level} | Wave: ${wave}`, width/2, height/2 + 50);
        ctx.fillText("Refresh to restart", width/2, height/2 + 80);
    }
}

function init() {
    resize();
    spine = [];
    for (let i = 0; i < CONFIG.segmentCount; i++) spine.push({ x: mouse.x, y: mouse.y, angle: 0 });
    legs = [
        { anchorIndex: 18, isLeft: true, x: 0, y: 0 }, { anchorIndex: 18, isLeft: false, x: 0, y: 0 },
        { anchorIndex: 50, isLeft: true, x: 0, y: 0 }, { anchorIndex: 50, isLeft: false, x: 0, y: 0 }
    ];
    loop();
}

function resize() { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('mousedown', () => {
    if (isPaused) {
        if (canReroll) {
            let rerolled = false;
            cardBounds.forEach((b, i) => {
                let btnW = 80; let btnH = 30; let btnX = b.x + b.w/2 - btnW/2; let btnY = b.y + b.h + 10;
                if (mouse.x > btnX && mouse.x < btnX + btnW && mouse.y > btnY && mouse.y < btnY + btnH) {
                    canReroll = false; 
                    let pool = UPGRADES.filter(u => !u.req || u.req() === true);
                    let newChoice = pool[Math.floor(Math.random() * pool.length)];
                    upgradeChoices[i] = newChoice;
                    rerolled = true;
                }
            });
            if (rerolled) return;
        }

        cardBounds.forEach((b, i) => {
            if (mouse.x > b.x && mouse.x < b.x + b.w && mouse.y > b.y && mouse.y < b.y + b.h) selectUpgrade(i);
        });
    } else { mouse.down = true; }
});
window.addEventListener('mouseup', () => mouse.down = false);
window.addEventListener('keydown', e => {
    if (e.code === 'Space' && unlockedGhost && ghostMeter > 0 && !ghostActive) ghostActive = true;
});
function loop() { update(); draw(); requestAnimationFrame(loop); }
init();
