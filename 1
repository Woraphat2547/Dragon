const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let width, height;
let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2, down: false };
let frame = 0;
// --- GLOBAL SCALING ---
const G_SCALE = 0.5; 

// --- THEME & RARITY ---
const COLORS = {
    bone: "#001a4d", accent: "#0066ff", glow: "#00ffff", laser: "#ccf2ff",
    plasma: "#ff00ff", enemyProj: "#ff3333", shield: "rgba(0, 255, 255, 0.3)",
    shockwave: "rgba(255, 255, 0, 0.4)", bossBar: "#ff0000", fury: "#ff3300",
    cursed: "#800080",
    // Rarity Colors
    common: "#b0b0b0", rare: "#0088ff", epic: "#9900ff", legendary: "#ffaa00", mythic: "#00ffcc"
};

// --- GAME STATE ---
let dragonHP = 18000; 
let dragonMaxHP = 18000;
let dragonShield = 0;
let dragonMaxShield = 0;
let dragonShieldRegen = 0; 
let shieldCooldown = 0;

// Caps & Config
const CAP_DEF = 0.75; 
const CAP_DODGE = 0.60;
const CAP_CRIT = 1.0; 
const MAX_LASER_MAIN = 6;
const MAX_LASER_SIDE = 4;
const MAX_LASER_REAR = 3;

// Stats
let dragonDefPct = 0; 
let dragonAtk = 1;
let dragonRegen = 0.2; 
let xpMultiplier = 1.0;
let lifeSteal = 0; 
let dodgeChance = 0; 
let globalSlow = 1.0;
let tailDmgMult = 1.0;
let critChance = 0.05; 
let critDmg = 1.5;     
let thornsDmg = 0;
let knockbackStr = 1.0;
let executeThreshold = 0; 
let dmgTakenMult = 1.0; 
let laserDmgMult = 1.0; 

// Special Mechanics & Unlocks
let unlockedShield = false;
let unlockedFury = false;
let unlockedOrbs = false;
let unlockedMissiles = false;
let unlockedMines = false;
let unlockedHoming = false; 
let unlockedStatic = false; 
let furyEnabled = false;
let furyMeter = 0;
let furyActive = false;
let furyTimer = 0;
let furyDuration = 600;
let autoTurretCount = 0;
let magnetRange = 1.0;
let hasBloodLust = false; 
let reviveCount = 0;
let timeStopChance = 0;
let timeStopActive = false;
let timeStopTimer = 0;
let chainLightningChance = 0;
let poisonDmg = 0; 
let missileCount = 0;
let mineTimer = 0;
let auraFireDmg = 0;
let auraIceSlow = 0;
let summonDrakeCount = 0;
let droneCount = 0;
let sawBladeCount = 0;
let elementalProcChance = 0;
let ricochetCount = 0;
let fearChance = 0;
let ghostForm = false;

// Shockwave Stats
let shockwaveEnabled = false;
let shockwaveTimer = 0;
let shockwaveInterval = 180;
let shockwaveRange = 300 * G_SCALE; 
let shockwaveDmg = 50;
let shockwaveActiveFrame = 0;

let level = 1;
let exp = 0;
let expNext = 800; 
let wave = 0;
let score = 0;
let gameActive = true;
let isPaused = false;

// --- STACKABLE UPGRADE STATS ---
let laserCount = 1;
let laserWidthBase = 1;
let laserRear = 0;
let laserSide = 0;
let laserType = 'normal'; 
let orbLevel = 0;
let orbStats = { speed: 8 * G_SCALE, size: 10 * G_SCALE, pen: 1, damageMult: 1, count: 1 };
let reactorDmg = 0; 
let reactorRadiusMult = 1.0;

let enemies = [];
let projectiles = [];
let enemyProjectiles = [];
let gems = [];
let upgradeChoices = [];
let cardBounds = [];
let damageNumbers = [];
let summons = [];

// --- CONFIG (Dragon Specs) ---
let VISUAL_SCALE = 0.6 * G_SCALE;
const CONFIG = {
    segmentCount: 85,
    segmentDist: 8 * VISUAL_SCALE, 
    headSpeed: 0.015, 
    maxRibWidth: 42 * VISUAL_SCALE, 
    legSpeed: 0.05,
    upperLegLen: 75 * VISUAL_SCALE, 
    lowerLegLen: 85 * VISUAL_SCALE, 
    wingSpan: 340 * VISUAL_SCALE,   
    wingFlapSpeed: 0.03,
    wingAttachment: 18
};
let spine = [];
let legs = [];

// --- HELPER FUNCTIONS ---
function healPct(pct) {
    let amt = dragonMaxHP * pct;
    dragonHP = Math.min(dragonMaxHP, dragonHP + amt);
    damageNumbers.push(new FloatingText(spine[0].x, spine[0].y, "+" + Math.floor(amt), "#0f0", 25));
}
function addMaxHP(pct) {
    let oldMax = dragonMaxHP;
    dragonMaxHP *= (1 + pct);
    dragonHP += (dragonMaxHP - oldMax); 
}
function romanize(num) {
    if (num === 1) return "I"; if (num === 2) return "II"; if (num === 3) return "III";
    if (num === 4) return "IV"; if (num === 5) return "V"; return "X";
}

// --- UPGRADES DATABASE ---
const UPGRADES = [
    // --- COMMON (Tier 1) ---
    { r: 0, type: 'def', name: "Thick Skin", desc: "Max HP +10%", run: () => addMaxHP(0.1) },
    { r: 0, type: 'def', name: "Regen Cell", desc: "Regen +1 HP/frame", run: () => dragonRegen += 1 },
    { r: 0, type: 'def', name: "Hard Scales", desc: "Defense +5%", run: () => dragonDefPct = Math.min(CAP_DEF, dragonDefPct + 0.05) },
    { r: 0, type: 'def', name: "Spikes", desc: "Thorns +20 DMG", run: () => thornsDmg += 20 },
    // Updated Descriptions
    { r: 0, type: 'wep', name: "Extra Barrel", desc: "+1 Main Laser (Total Dmg -20%)", req: () => laserCount < MAX_LASER_MAIN, run: () => { laserCount++; laserDmgMult *= 0.80; } },
    { r: 0, type: 'wep', name: "Focus Lens", desc: "Laser Width +10%", run: () => laserWidthBase += 0.1 },
    { r: 0, type: 'wep', name: "Sharpen", desc: "ATK +10%", run: () => dragonAtk += 0.1 },
    { r: 0, type: 'util', name: "Magnetism", desc: "Pickup Range +25%", run: () => magnetRange *= 1.25 },
    { r: 0, type: 'util', name: "Learning", desc: "XP Gain +10%", run: () => xpMultiplier += 0.1 },
    // Updated Descriptions
    { r: 0, type: 'wep', name: "Rear Shot", desc: "+1 Rear Laser (Total Dmg -10%)", req: () => laserRear < MAX_LASER_REAR, run: () => { laserRear++; laserDmgMult *= 0.90; } },
    { r: 0, type: 'wep', name: "Side Cannons", desc: "+1 Side Pair (Total Dmg -10%)", req: () => laserSide < MAX_LASER_SIDE, run: () => { laserSide++; laserDmgMult *= 0.90; } },
    { r: 0, type: 'util', name: "Agility", desc: "Movement Speed +5%", run: () => CONFIG.headSpeed *= 1.05 },
    { r: 0, type: 'wep', name: "Sniper", desc: "Crit Chance +5%", run: () => critChance = Math.min(CAP_CRIT, critChance + 0.05) },
    
    // --- RARE (Tier 2) ---
    { r: 1, type: 'def', name: "Reinforced Plating", desc: "Max HP +25%", run: () => addMaxHP(0.25) },
    { r: 1, type: 'def', name: "Shield Generator", desc: "Unlock 500 Shield", req: () => !unlockedShield, run: () => { unlockedShield = true; dragonMaxShield += 500; dragonShieldRegen += 2; } },
    { r: 1, type: 'def', name: "Shield Battery", desc: "Shield +500, Regen +2", req: () => unlockedShield, run: () => { dragonMaxShield += 500; dragonShieldRegen += 2; } },
    { r: 1, type: 'wep', name: "Dual Beam", desc: "+1 Laser, +10% DMG (Penalty -10%)", req: () => laserCount < MAX_LASER_MAIN, run: () => { laserCount++; dragonAtk += 0.1; laserDmgMult *= 0.9; } },
    { r: 1, type: 'wep', name: "Tail Mastery", desc: "Tail Dmg x3", run: () => tailDmgMult += 3 },
    { r: 1, type: 'wep', name: "Orbiter", desc: "Unlock/Upgrade Orbs", run: () => { unlockedOrbs = true; orbLevel++; orbStats.count++; } },
    { r: 1, type: 'util', name: "Greed", desc: "XP +30%", run: () => xpMultiplier += 0.3 },
    { r: 1, type: 'wep', name: "Auto Turret", desc: "Unlock/Upgrade Turret", run: () => autoTurretCount++ },
    { r: 1, type: 'wep', name: "Crit Master", desc: "Crit Dmg +50%", run: () => critDmg += 0.5 },
    { r: 1, type: 'def', name: "Dodge Roll", desc: "Dodge +10%", run: () => dodgeChance = Math.min(CAP_DODGE, dodgeChance + 0.1) },
    { r: 1, type: 'wep', name: "Reactor", desc: "Burn Aura +40 DMG/s", run: () => reactorDmg += 40 },
    { r: 1, type: 'wep', name: "Frost Aura", desc: "Enemies near you slow down", run: () => auraIceSlow = Math.min(0.5, auraIceSlow + 0.1) },
    { r: 1, type: 'wep', name: "Poison Tips", desc: "Lasers deal Poison DoT", run: () => poisonDmg += 30 },

    // --- EPIC (Tier 3) ---
    { r: 2, type: 'abil', name: "Draconic Fury", desc: "Unlock Fury Mode", req: () => !unlockedFury, run: () => { unlockedFury = true; furyEnabled = true; } },
    { r: 2, type: 'abil', name: "Rage Fuel", desc: "Fury lasts 5s longer", req: () => unlockedFury, run: () => furyDuration += 300 },
    { r: 2, type: 'wep', name: "Missile Silo", desc: "Fire Homing Missiles", run: () => { unlockedMissiles = true; missileCount++; } },
    { r: 2, type: 'def', name: "Second Heart", desc: "+1 Revive", run: () => reviveCount++ },
    { r: 2, type: 'wep', name: "Plasma Beam", desc: "Lasers Pierce Armor", run: () => laserType = 'plasma' },
    { r: 2, type: 'wep', name: "Chain Lightning", desc: "15% Chance to Arc DMG", run: () => chainLightningChance = Math.min(0.8, chainLightningChance + 0.15) },
    { r: 2, type: 'wep', name: "Executioner", desc: "Kill enemies <10% HP", run: () => executeThreshold = 0.1 },
    { r: 2, type: 'wep', name: "Giga Blast", desc: "Laser Size +50%", run: () => laserWidthBase += 0.5 },
    { r: 2, type: 'util', name: "Chronos", desc: "Global Enemy Slow 15%", run: () => globalSlow *= 0.85 },
    { r: 2, type: 'sum', name: "Mini Drake", desc: "Summon a baby dragon ally", run: () => { summonDrakeCount++; summons.push(new SummonDrake(summonDrakeCount)); } },
    { r: 2, type: 'wep', name: "Vampiric Touch", desc: "Heal 2 HP on Crit", run: () => lifeSteal += 2 },
    { r: 2, type: 'wep', name: "Mine Layer", desc: "Drop mines behind you", req: () => !unlockedMines, run: () => { unlockedMines = true; } },
    { r: 2, type: 'wep', name: "Ricochet", desc: "Projectiles bounce +1", run: () => ricochetCount++ },

    // --- NEW CREATIVE UPGRADES ---
    { r: 1, type: 'util', name: "Ghost Form", desc: "Dodge +10% & Move through enemies", req: () => !ghostForm, run: () => { dodgeChance += 0.1; ghostForm = true; } },
    { r: 2, type: 'wep', name: "Saw Blade", desc: "Orbiting Saw deals contact dmg", run: () => { sawBladeCount++; summons.push(new SawBlade(sawBladeCount)); } },
    { r: 2, type: 'wep', name: "Static Discharge", desc: "Moving charges electricity", req: () => !unlockedStatic, run: () => { unlockedStatic = true; } },
    { r: 3, type: 'abil', name: "Black Hole", desc: "Chance to spawn black hole", run: () => { elementalProcChance += 0.05; } },
    { r: 1, type: 'wep', name: "Shotgun", desc: "Main laser fires burst", req: () => laserType !== 'shotgun', run: () => { laserType = 'shotgun'; laserWidthBase += 0.5; } }, 
    { r: 2, type: 'sum', name: "Drone Swarm", desc: "+1 Attack Drone", run: () => { droneCount++; summons.push(new Drone(droneCount)); } },
    { r: 2, type: 'def', name: "Reactive Armor", desc: "Explode when hit", run: () => { thornsDmg += 100; } },
    { r: 3, type: 'util', name: "Gold Rush", desc: "Enemies drop more XP", run: () => xpMultiplier += 0.5 },
    { r: 1, type: 'def', name: "Nano Repair", desc: "Heal +5 when NOT shooting", run: () => { /* Logic in update */ } },
    { r: 2, type: 'wep', name: "Fear Aura", desc: "Enemies run away", run: () => fearChance += 0.1 },
    { r: 3, type: 'wep', name: "Meteor Shower", desc: "Meteors fall randomly", run: () => { /* Logic in update */ } },
    { r: 2, type: 'wep', name: "Homing Lasers", desc: "Lasers curve to enemies", req: () => !unlockedHoming, run: () => { unlockedHoming = true; } },
    { r: 1, type: 'def', name: "Stone Skin", desc: "Def +20%, Speed -10%", run: () => { dragonDefPct += 0.2; CONFIG.headSpeed *= 0.9; } },
    { r: 2, type: 'wep', name: "Berserker Blood", desc: "Low HP = More Dmg", run: () => { /* Logic in atk calc */ } },
    { r: 2, type: 'wep', name: "Executioner II", desc: "Execute Threshold 15%", run: () => executeThreshold = 0.15 },
    { r: 3, type: 'god', name: "Divinity", desc: "All stats small boost", run: () => { dragonAtk+=0.2; dragonDefPct+=0.05; addMaxHP(0.1); } },
    { r: 1, type: 'util', name: "Sprint", desc: "Move Speed +15%", run: () => { CONFIG.headSpeed *= 1.15; } },
    { r: 2, type: 'wep', name: "Ice Age", desc: "Freeze enemies on hit", run: () => { auraIceSlow = 0.8; } },
    { r: 2, type: 'wep', name: "Venom Nova", desc: "Poison explosion on kill", run: () => { poisonDmg += 50; } },
    { r: 3, type: 'sum', name: "Hydra Head", desc: "Grow a firing head", run: () => { autoTurretCount++; } },
    { r: 2, type: 'def', name: "Mirror Shield", desc: "Reflect projectiles", run: () => { /* Logic */ } },
    { r: 1, type: 'util', name: "Magnet II", desc: "Magnet Range MAX", run: () => magnetRange *= 2 },
    { r: 2, type: 'wep', name: "Sniper II", desc: "Crit Dmg x2", run: () => critDmg *= 2 },
    { r: 3, type: 'god', name: "Time Lord", desc: "Time stop lasts longer", run: () => { /* Logic */ } },
    { r: 2, type: 'wep', name: "Double Tap", desc: "Chance to fire twice", run: () => { /* Logic */ } },
    { r: 1, type: 'def', name: "Iron Will", desc: "Immune to Knockback", run: () => { /* Logic */ } },
    { r: 2, type: 'wep', name: "Life Leech", desc: "Life Steal +5", run: () => lifeSteal += 5 },
    { r: 3, type: 'god', name: "Odin's Sight", desc: "Crit Chance +20%", run: () => critChance += 0.2 },
    { r: 2, type: 'util', name: "Phase Shift", desc: "Dodge +20%", run: () => { dodgeChance += 0.2; } },
    { r: 1, type: 'wep', name: "Heavy Caliber", desc: "Dmg +50%, Atk Spd -20%", run: () => { dragonAtk *= 1.5; } },
    
    // --- LEGENDARY (Tier 4) ---
    { r: 3, type: 'wep', name: "Void Cannon", desc: "Lasers deal % Max HP Dmg", run: () => laserType = 'void' },
    { r: 3, type: 'util', name: "Time Stop", desc: "5% chance to Freeze Time", run: () => timeStopChance += 0.05 },
    { r: 3, type: 'def', name: "Titan Scales", desc: "Cap Armor at 75% & +10% Def", run: () => dragonDefPct = Math.min(CAP_DEF, dragonDefPct + 0.1) },
    { r: 3, type: 'wep', name: "Armageddon", desc: "All Projectiles explode", run: () => orbStats.damageMult *= 2 },
    { r: 3, type: 'def', name: "Phoenix Soul", desc: "+3 Revives", run: () => reviveCount += 3 },
    { r: 3, type: 'wep', name: "Orbital Cannon", desc: "Orbs are massive and fast", run: () => { orbStats.size *= 2; orbStats.speed *= 2; } },
    { r: 3, type: 'abil', name: "Perma-Fury", desc: "Fury charges 2x faster", req: () => unlockedFury, run: () => furyDuration -= 100 },

    // --- MYTHIC (Tier 5) ---
    { r: 5, type: 'god', name: "God Mode", desc: "All Stats +50%", run: () => { dragonAtk*=1.5; addMaxHP(0.5); dragonDefPct+=0.1; } },
    { r: 5, type: 'god', name: "Evolution", desc: "Grow larger, HP x2", run: () => { VISUAL_SCALE *= 1.2; updateDragonSize(); addMaxHP(1.0); } },
    { r: 5, type: 'god', name: "Black Hole Sun", desc: "Reactor pulls enemies in", run: () => reactorRadiusMult *= 2 },

    // --- CURSED ---
    { r: 4, type: 'cursed', name: "Blood Contract", desc: "DMG +100%, Max HP -40%", run: () => { dragonAtk += 1.0; dragonMaxHP *= 0.6; dragonHP = Math.min(dragonHP, dragonMaxHP); } },
    { r: 4, type: 'cursed', name: "Glass Cannon", desc: "DMG +200%, Take +50% DMG", run: () => { dragonAtk += 2.0; dmgTakenMult += 0.5; } },
    { r: 4, type: 'cursed', name: "Death Wish", desc: "XP +200%, Enemies +100% HP", run: () => { xpMultiplier += 2.0; } },
    { r: 4, type: 'cursed', name: "Berserk", desc: "Infinite Fury, No Regen", req: () => unlockedFury, run: () => { furyActive = true; furyDuration = 999999; dragonRegen = -10; } }
];

// Procedural Upgrades
const STAT_TYPES = [
    { name: "Vitality", stat: () => addMaxHP(0.15), desc: "HP +15%", type: 'def' },
    { name: "Strength", stat: () => dragonAtk += 0.15, desc: "ATK +15%", type: 'wep' },
    { name: "Haste", stat: () => CONFIG.headSpeed *= 1.1, desc: "Speed +10%", type: 'util' },
    { name: "Fortitude", stat: () => dragonDefPct += 0.03, desc: "Def +3%", type: 'def' }
];

for (let i = 0; i < 30; i++) {
    let t = STAT_TYPES[i % STAT_TYPES.length];
    UPGRADES.push({ 
        r: 0, 
        type: t.type, 
        name: `${t.name} ${romanize(Math.floor(i/4)+1)}`, 
        desc: t.desc, 
        run: t.stat 
    });
}

function updateDragonSize() {
    CONFIG.segmentDist = 8 * VISUAL_SCALE;
    CONFIG.maxRibWidth = 42 * VISUAL_SCALE;
    CONFIG.upperLegLen = 75 * VISUAL_SCALE;
    CONFIG.lowerLegLen = 85 * VISUAL_SCALE;
    CONFIG.wingSpan = 340 * VISUAL_SCALE;
}

// --- CLASSES ---
class FloatingText {
    constructor(x, y, text, color, size) {
        this.x = x + (Math.random()-0.5)*20; this.y = y;
        this.text = text; this.color = color; this.life = 60;
        this.size = size; this.vy = -1;
    }
    update() { this.y += this.vy; this.life--; return this.life > 0; }
    draw() {
        ctx.globalAlpha = Math.max(0, this.life / 20);
        ctx.fillStyle = this.color; ctx.font = `bold ${this.size}px monospace`;
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1.0;
    }
}

class ExpGem {
    constructor(x, y, val) { this.x = x; this.y = y; this.val = val; }
    update() {
        const head = spine[0];
        const d = Math.hypot(head.x - this.x, head.y - this.y);
        if (d < 400 * G_SCALE * magnetRange) { 
            const a = Math.atan2(head.y - this.y, head.x - this.x);
            this.x += Math.cos(a) * (25 * G_SCALE); this.y += Math.sin(a) * (25 * G_SCALE);
        }
        if (d < 60 * G_SCALE) {
            exp += this.val * xpMultiplier;
            // NERFED FURY CHARGE
            if (furyEnabled && !furyActive) furyMeter = Math.min(100, furyMeter + 0.3);
            if (exp >= expNext) levelUp();
            return true;
        }
        return false;
    }
    draw() {
        ctx.fillStyle = COLORS.glow; ctx.shadowBlur = 10; ctx.shadowColor = COLORS.glow;
        ctx.beginPath(); ctx.arc(this.x, this.y, 6 * G_SCALE, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
    }
}

class SummonDrake {
    constructor(id) {
        this.x = spine[0].x; this.y = spine[0].y;
        this.angle = 0; this.target = null;
        this.attackCooldown = 0;
        this.id = id;
    }
    update() {
        let head = spine[0];
        // Repulsion logic
        summons.forEach(s => {
            if (s !== this && s instanceof SummonDrake) {
                let dx = this.x - s.x; let dy = this.y - s.y;
                let d = Math.hypot(dx, dy);
                if (d < 40) {
                    this.x += (dx/d) * 2; this.y += (dy/d) * 2;
                }
            }
        });

        if (!this.target || this.target.hp <= 0) {
            let minD = Infinity;
            enemies.forEach(e => {
                let d = Math.hypot(e.x - this.x, e.y - this.y);
                if (d < minD) { minD = d; this.target = e; }
            });
            if (!this.target) {
                let time = frame * 0.05 + (this.id * 2); 
                let tx = head.x + Math.cos(time) * 100 * VISUAL_SCALE;
                let ty = head.y + Math.sin(time) * 100 * VISUAL_SCALE;
                this.x += (tx - this.x) * 0.1;
                this.y += (ty - this.y) * 0.1;
                return;
            }
        }
        
        let dx = this.target.x - this.x, dy = this.target.y - this.y;
        let dist = Math.hypot(dx, dy);
        let ang = Math.atan2(dy, dx);
        this.x += Math.cos(ang) * 5; this.y += Math.sin(ang) * 5;
        this.angle = ang;
        
        if (this.attackCooldown > 0) this.attackCooldown--;

        if (dist < 100 && this.attackCooldown <= 0) {
            this.target.takeDamage(10 * dragonAtk);
            this.attackCooldown = 45; 
            ctx.fillStyle="orange"; ctx.beginPath(); ctx.arc(this.target.x, this.target.y, 20, 0, Math.PI*2); ctx.fill();
        }
    }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
        ctx.fillStyle = "#0f0"; ctx.beginPath(); ctx.moveTo(10,0); ctx.lineTo(-5, 5); ctx.lineTo(-5,-5); ctx.fill();
        ctx.restore();
    }
}

class SawBlade {
    constructor(id) {
        this.id = id; this.angle = 0;
    }
    update() {
        this.angle += 0.2;
        let head = spine[0];
        let r = 150 * VISUAL_SCALE;
        let x = head.x + Math.cos(frame * 0.05 + this.id * 2) * r;
        let y = head.y + Math.sin(frame * 0.05 + this.id * 2) * r;
        
        enemies.forEach(e => {
            if (Math.hypot(e.x - x, e.y - y) < 40 * G_SCALE + e.radius) {
                e.takeDamage(5 * dragonAtk);
            }
        });
        
        ctx.save(); ctx.translate(x, y); ctx.rotate(this.angle);
        ctx.fillStyle = "#aaa"; ctx.beginPath();
        for(let i=0; i<8; i++) { ctx.rotate(Math.PI/4); ctx.moveTo(0,-20); ctx.lineTo(10,0); ctx.lineTo(0,20); }
        ctx.fill(); ctx.restore();
        return false; 
    }
    draw() {} 
}

class Drone {
    constructor(id) {
        this.x = spine[0].x; this.y = spine[0].y; this.id = id;
    }
    update() {
        let head = spine[0];
        let tx = head.x - Math.cos(frame*0.02 + this.id)*150;
        let ty = head.y - Math.sin(frame*0.02 + this.id)*150;
        this.x += (tx - this.x)*0.05; this.y += (ty - this.y)*0.05;
        
        if (frame % 60 === 0) {
            let nearest = enemies[0]; 
            if (nearest) {
                projectiles.push(new Projectile(this.x, this.y, Math.atan2(nearest.y-this.y, nearest.x-this.x), 5));
            }
        }
        ctx.fillStyle="#0ff"; ctx.fillRect(this.x-5, this.y-5, 10, 10);
        return false;
    }
    draw() {}
}

class Missile {
    constructor(x, y) {
        this.x = x; this.y = y; this.life = 120;
        this.target = enemies.length > 0 ? enemies[Math.floor(Math.random()*enemies.length)] : null;
        this.vx = (Math.random()-0.5)*10; this.vy = (Math.random()-0.5)*10;
    }
    update() {
        this.life--;
        if (this.target && this.target.hp > 0) {
            let a = Math.atan2(this.target.y - this.y, this.target.x - this.x);
            this.vx += Math.cos(a) * 1.5; this.vy += Math.sin(a) * 1.5;
            this.vx *= 0.9; this.vy *= 0.9;
        }
        this.x += this.vx; this.y += this.vy;
        
        for (let e of enemies) {
            if (Math.hypot(e.x - this.x, e.y - this.y) < e.radius + 10) {
                e.takeDamage(100 * dragonAtk);
                ctx.fillStyle = "orange"; ctx.beginPath(); ctx.arc(this.x, this.y, 50, 0, Math.PI*2); ctx.fill();
                return true;
            }
        }
        return this.life <= 0;
    }
    draw() {
        ctx.fillStyle = "yellow"; ctx.fillRect(this.x-2, this.y-2, 4, 4);
        ctx.strokeStyle = "orange"; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x-this.vx*2, this.y-this.vy*2); ctx.stroke();
    }
}

class Mine {
    constructor(x, y) { this.x = x; this.y = y; this.timer = 600; }
    update() {
        this.timer--;
        for (let e of enemies) {
            if (Math.hypot(e.x - this.x, e.y - this.y) < e.radius + 20) {
                e.takeDamage(200 * dragonAtk);
                ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(this.x, this.y, 80, 0, Math.PI*2); ctx.fill();
                return true;
            }
        }
        ctx.fillStyle = (frame%20<10)?"red":"#500"; ctx.beginPath(); ctx.arc(this.x, this.y, 5, 0, Math.PI*2); ctx.fill();
        return this.timer <= 0;
    }
    draw() {}
}

class EnemyProjectile {
    constructor(x, y, angle, type = 'normal') {
        this.x = x; this.y = y;
        this.vx = Math.cos(angle) * (6 * G_SCALE); 
        this.vy = Math.sin(angle) * (6 * G_SCALE);
        this.radius = 8 * G_SCALE; this.type = type;
        this.dmg = 30;
        
        if(type === 'sniper') this.dmg = 100;
        if(type === 'boss') { this.radius = 20 * G_SCALE; this.dmg = 150; }
        if(type === 'web') { this.radius = 12 * G_SCALE; this.dmg = 20; }
        if(type === 'titan') { this.radius = 50 * G_SCALE; this.dmg = 300; }
        if(type === 'spawner') { this.radius = 15 * G_SCALE; this.dmg = 0; } 
    }
    update() {
        if (timeStopActive) return false;
        this.x += this.vx * globalSlow; this.y += this.vy * globalSlow;
        const head = spine[0];
        const center = spine[Math.floor(spine.length/2)];
        const hitHead = Math.hypot(this.x - head.x, this.y - head.y) < (40 * VISUAL_SCALE);
        const hitBody = Math.hypot(this.x - center.x, this.y - center.y) < (50 * VISUAL_SCALE);
        
        if (this.type === 'spawner' && frame % 5 === 0) {
             if (Math.random() < 0.05) {
                 let e = new Enemy('swarmer', wave); e.x = this.x; e.y = this.y;
                 enemies.push(e);
                 return true;
             }
        }

        if (hitHead || hitBody) {
            if (this.type === 'spawner') {
                let e = new Enemy('brute', wave); e.x = this.x; e.y = this.y; enemies.push(e);
                return true;
            }
            takeDamage(this.dmg); 
            if(this.type === 'web') CONFIG.headSpeed *= 0.9; 
            return true; 
        }
        return (this.x < -200 || this.x > width+200 || this.y < -200 || this.y > height+200);
    }
    draw() {
        ctx.fillStyle = this.type === 'boss' ? "#ff00ff" : "#ff3300"; 
        if(this.type === 'web') ctx.fillStyle = "#fff";
        if(this.type === 'titan') ctx.fillStyle = "#ffff00";
        if(this.type === 'spawner') ctx.fillStyle = "#00ff00";
        ctx.shadowBlur = 10; ctx.shadowColor = "red";
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
    }
}

// --- ENEMY DATA CONFIGURATION ---
const ENEMY_DEFS = {
    // TIER 1
    'swarmer': { hp: 50, spd: 3.0, xp: 10, col: '#ff5500', r: 12, shape: 'tri', ai: 'swarm' },
    'fly': { hp: 30, spd: 4.0, xp: 8, col: '#ccaa00', r: 10, shape: 'tri', ai: 'strafe' },
    'mite': { hp: 60, spd: 2.5, xp: 12, col: '#aa5500', r: 15, shape: 'circle', ai: 'zigzag' },
    'spore': { hp: 40, spd: 1.5, xp: 15, col: '#00aa00', r: 12, shape: 'spore', ai: 'drift' },
    'wasp': { hp: 25, spd: 5.0, xp: 20, col: '#ffff00', r: 8, shape: 'tri' },
    'blob': { hp: 150, spd: 0.8, xp: 25, col: '#0055aa', r: 25, shape: 'blob' },
    'drone': { hp: 60, spd: 3.5, xp: 18, col: '#aaaaaa', r: 14, shape: 'diamond' },
    // TIER 2
    'grunt': { hp: 300, spd: 1.2, xp: 40, col: '#aa0000', r: 22, shape: 'rect' },
    'soldier': { hp: 400, spd: 1.1, xp: 50, col: '#cc0000', r: 25, shape: 'rect' },
    'shielded': { hp: 800, spd: 0.9, xp: 70, col: '#00ffff', r: 30, shape: 'shield' },
    'lancer': { hp: 250, spd: 2.0, xp: 55, col: '#ff8800', r: 18, shape: 'spike' },
    'zealot': { hp: 200, spd: 3.5, xp: 60, col: '#ff00ff', r: 20, shape: 'star', ai: 'kamikaze' },
    'dasher': { hp: 200, spd: 1.5, xp: 60, col: '#00ff00', r: 18, shape: 'tri', ai: 'dash' },
    // TIER 3
    'shooter': { hp: 350, spd: 0.9, xp: 80, col: '#8800ff', r: 25, shape: 'tri', ai: 'range_normal' },
    'sniper': { hp: 250, spd: 0.7, xp: 120, col: '#ff0088', r: 20, shape: 'cross', ai: 'range_snipe' },
    'mortar': { hp: 500, spd: 0.5, xp: 100, col: '#444444', r: 35, shape: 'pent', ai: 'range_heavy' },
    'hunter': { hp: 300, spd: 1.2, xp: 90, col: '#00aa44', r: 22, shape: 'tri', ai: 'range_move' },
    'webber': { hp: 400, spd: 0.8, xp: 100, col: '#cccccc', r: 30, shape: 'spider', ai: 'range_web' },
    // TIER 4+
    'glitch': { hp: 450, spd: 1.6, xp: 110, col: '#ffffff', r: 22, shape: 'glitch', ai: 'teleport' },
    'phantom': { hp: 350, spd: 1.4, xp: 110, col: '#88aaff', r: 25, shape: 'ghost', ai: 'fade' },
    'healer': { hp: 600, spd: 1.0, xp: 150, col: '#00ff00', r: 30, shape: 'cross', ai: 'heal' },
    'summoner': { hp: 500, spd: 0.6, xp: 160, col: '#aa00ff', r: 35, shape: 'robe', ai: 'summon' },
    'tank': { hp: 2000, spd: 0.6, xp: 250, col: '#222222', r: 45, shape: 'tank' },
    'golem': { hp: 5000, spd: 0.3, xp: 600, col: '#554433', r: 60, shape: 'block' },
    'monolith': { hp: 6000, spd: 0.2, xp: 500, col: '#111111', r: 70, shape: 'obelisk' },
    // BOSSES
    'mini_slayer': { hp: 12000, spd: 1.3, xp: 2000, col: '#aa00aa', r: 40, shape: 'boss', isBoss: true, ai: 'pounce' },
    'boss_hydra': { hp: 25000, spd: 0.5, xp: 5000, col: '#00aa00', r: 90, shape: 'hydra', isBoss: true },
    'boss_titan': { hp: 60000, spd: 0.3, xp: 8000, col: '#aa5500', r: 120, shape: 'titan', isBoss: true },
    'boss_ufo': { hp: 30000, spd: 1.5, xp: 6000, col: '#8888ff', r: 60, shape: 'ufo', isBoss: true },
    'mini_mecha': { hp: 20000, spd: 0.5, xp: 3000, col: '#888888', r: 60, shape: 'tank', isBoss: true },
    'boss_giga': { hp: 80000, spd: 0.2, xp: 10000, col: '#552200', r: 140, shape: 'giant', isBoss: true, ai: 'thrower' }
};

class Enemy {
    constructor(type, waveNum) {
        let def = ENEMY_DEFS[type] || ENEMY_DEFS['swarmer'];
        const side = Math.random() > 0.5;
        this.x = side ? -100 : width + 100;
        this.y = Math.random() * height;
        this.type = type;
        this.angle = 0;
        this.timer = Math.random() * 100;
        this.state = 0; 
        
        let scale = 1 + (waveNum * 0.25);
        if (def.isBoss && waveNum < 10) scale *= 0.5; 
        if (hasBloodLust) scale *= 2; 

        this.hp = def.hp * scale;
        this.maxHp = this.hp;
        this.speed = def.spd * G_SCALE; 
        this.radius = def.r * G_SCALE; 
        this.xp = Math.floor(def.xp * scale);
        this.isBoss = def.isBoss || false;
        this.col = def.col;
        this.shape = def.shape;
        this.ai = def.ai || (def.isBoss && def.ai ? def.ai : 'basic'); 
        this.poisonTimer = 0; 

        // --- ELITE MECHANIC ---
        this.eliteMod = null;
        if (!this.isBoss && Math.random() < 0.15 + (wave * 0.01)) { 
            const mods = ['AEGIS', 'WARP', 'REGEN', 'VOLATILE', 'GIANT'];
            this.eliteMod = mods[Math.floor(Math.random() * mods.length)];
            this.xp *= 3;
        }
        
        if (this.eliteMod === 'GIANT') { this.hp *= 2; this.radius *= 1.5; this.maxHp = this.hp; }
        if (this.eliteMod === 'AEGIS') { this.shield = this.hp * 0.5; }
    }

    update() {
        if (timeStopActive) return;
        
        // FIXED DOT LOGIC (Increased damage rate and visual feedback)
        if (this.poisonTimer > 0) {
            // Damage every 20 frames
            if (this.poisonTimer % 20 === 0) {
                this.takeDamage(poisonDmg * 0.5, true); 
            }
            this.poisonTimer--;
        }
        if (this.eliteMod === 'REGEN' && frame % 60 === 0) {
            this.hp = Math.min(this.maxHp, this.hp + this.maxHp*0.05);
        }

        const head = spine[0];
        let targetX = head.x; let targetY = head.y;
        const dist = Math.hypot(targetX - this.x, targetY - this.y);
        const angleToPlayer = Math.atan2(targetY - this.y, targetX - this.x);
        this.angle += 0.05;
        this.timer++;

        let moveSpeed = this.speed * globalSlow;
        if (auraIceSlow > 0 && dist < 300) moveSpeed *= (1 - auraIceSlow);
        if (fearChance > 0 && Math.random() < fearChance && dist < 200) moveSpeed *= -1; 

        let mx = Math.cos(angleToPlayer); let my = Math.sin(angleToPlayer);

        if (this.eliteMod === 'WARP' && frame % 120 === 0 && Math.random() < 0.3) {
            this.x += (Math.random()-0.5)*300; this.y += (Math.random()-0.5)*300;
        }

        // --- UPDATED AI BEHAVIORS ---
        switch(this.ai) {
            case 'swarm':
                // Accelerate when close
                if (dist < 300 * G_SCALE) moveSpeed *= 1.5;
                break;
            case 'strafe':
                // Move in a sine wave
                mx = Math.cos(angleToPlayer + Math.sin(frame * 0.1));
                my = Math.sin(angleToPlayer + Math.sin(frame * 0.1));
                break;
            case 'zigzag':
                // Rapid erratic movement
                if (frame % 30 < 15) { mx = -my; my = mx; }
                break;
            case 'drift':
                // Drifts randomly, ignores player slightly
                if (frame % 60 === 0) {
                     this.angle = Math.random() * Math.PI * 2;
                }
                mx = Math.cos(this.angle); my = Math.sin(this.angle);
                moveSpeed *= 0.5;
                break;
            case 'pounce': // Mini Boss Pounce
                if (this.state === 0) { // Stalk
                    moveSpeed *= 0.8;
                    if (this.timer > 120) { this.state = 1; this.timer = 0; }
                } else if (this.state === 1) { // Freeze/Charge
                    moveSpeed = 0;
                    ctx.fillStyle="red"; ctx.beginPath(); ctx.arc(this.x,this.y,this.radius+5,0,Math.PI*2); ctx.fill();
                    if (this.timer > 40) { this.state = 2; this.timer = 0; }
                } else if (this.state === 2) { // Dash
                    moveSpeed *= 6;
                    if (this.timer > 15) { this.state = 0; this.timer = 0; }
                }
                break;
            case 'thrower': 
                if (this.timer > 150) {
                     enemyProjectiles.push(new EnemyProjectile(this.x, this.y, angleToPlayer, 'spawner'));
                     this.timer = 0;
                }
                moveSpeed *= 0.5; 
                break;
            case 'dash':
                if (this.state === 0) { 
                    if (this.timer > 100) { this.state = 1; this.timer = 0; }
                } else if (this.state === 1) { 
                    moveSpeed = 0; this.x += (Math.random()-0.5)*2; 
                    if (this.timer > 40) { this.state = 2; this.timer = 0; }
                } else if (this.state === 2) { 
                    moveSpeed *= 8;
                    if (this.timer > 15) { this.state = 0; this.timer = 0; }
                }
                break;
            case 'heal':
                if (this.timer % 60 === 0) {
                    enemies.forEach(e => {
                        if (e !== this && Math.hypot(e.x - this.x, e.y - this.y) < 300 * G_SCALE) {
                            e.hp = Math.min(e.maxHp, e.hp + 100);
                            ctx.strokeStyle = "#0f0"; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(e.x, e.y); ctx.stroke();
                        }
                    });
                }
                break;
            case 'summon':
                if (dist > 400 * G_SCALE) moveSpeed *= 1; else moveSpeed = -0.5 * G_SCALE;
                if (this.timer > 200) {
                    this.timer = 0;
                    enemies.push(new Enemy('swarmer', wave));
                }
                break;
            case 'range_normal':
            case 'range_snipe':
            case 'range_heavy':
            case 'range_web':
            case 'range_move':
                let keepDist = (this.ai === 'range_snipe' ? 600 : 350) * G_SCALE;
                if (dist > keepDist + 50) { /* move forward */ } 
                else if (dist < keepDist - 50) { mx *= -1; my *= -1; } 
                else { mx = 0; my = 0; }
                
                let fireRate = this.ai === 'range_snipe' ? 220 : 120;
                if (this.type === 'boss_ufo') fireRate = 180; 
                
                if (this.timer > fireRate) {
                    let pType = this.ai === 'range_snipe' ? 'sniper' : (this.ai === 'range_web' ? 'web' : 'normal');
                    if (this.type === 'boss_ufo') pType = 'boss';
                    enemyProjectiles.push(new EnemyProjectile(this.x, this.y, angleToPlayer, pType));
                    this.timer = 0;
                }
                break;
            case 'teleport':
                if (this.timer > 120) {
                    this.x = head.x + (Math.random()-0.5)*400;
                    this.y = head.y + (Math.random()-0.5)*400;
                    this.timer = 0;
                }
                break;
        }

        this.x += mx * moveSpeed;
        this.y += my * moveSpeed;

        // Player Collision Damage
        let hit = false;
        let points = [0, Math.floor(spine.length/2), spine.length-1];
        
        for(let idx of points) {
            let seg = spine[idx];
            if (Math.hypot(this.x - seg.x, this.y - seg.y) < this.radius + (20 * VISUAL_SCALE)) {
                hit = true;
                if (idx === spine.length-1 && tailDmgMult > 1.0) {
                    this.takeDamage(20 * dragonAtk * tailDmgMult, false);
                    let push = 50 * knockbackStr;
                    this.x -= mx * push; this.y -= my * push;
                }
                break;
            }
        }

        if (hit) {
            let baseDmg = 5;
            if(this.isBoss || this.type === 'golem') baseDmg = 50;
            if(this.ai === 'kamikaze' || this.eliteMod === 'VOLATILE') { 
                baseDmg = 80;
                this.hp = 0; 
                for(let k=0; k<8; k++) enemyProjectiles.push(new EnemyProjectile(this.x, this.y, k * (Math.PI/4)));
            }
            takeDamage(baseDmg);
            if(thornsDmg > 0) this.takeDamage(thornsDmg, false);
        }
        
        // Passive AoE (Reactor Burn)
        if (reactorDmg > 0 && dist < 200 * VISUAL_SCALE * reactorRadiusMult) {
             // Burn damage every 10 frames
             if (frame % 10 === 0) {
                 this.takeDamage(reactorDmg * 2, true);
                 this.isBurned = true; // Visual Flag
             }
        } else {
             this.isBurned = false;
        }
        
        if (auraFireDmg > 0 && dist < 250 && frame % 10 === 0) this.takeDamage(auraFireDmg * 2, true);

        // Mouse Lasers
        if (mouse.down || autoTurretCount > 0) {
            if (mouse.down) {
                checkLaserHit(this, head, laserCount, 0);
                if(laserRear > 0) checkLaserHit(this, head, laserRear, Math.PI); 
                if(laserSide > 0) {
                    checkLaserHit(this, head, laserSide, Math.PI/2);
                    checkLaserHit(this, head, laserSide, -Math.PI/2);
                }
            }
            if (autoTurretCount > 0 && dist < 600 * G_SCALE) {
                 this.takeDamage(3 * dragonAtk * autoTurretCount * 0.1, true);
            }
        }
    }

    takeDamage(amount, isDoT = false) {
        if (this.eliteMod === 'AEGIS' && Math.random() < 0.5) { 
            damageNumbers.push(new FloatingText(this.x, this.y, "BLOCK", "#fff", 20));
            return;
        }

        if (furyActive) amount *= 2;
        let isCrit = false;
        if (!isDoT && Math.random() < critChance) {
            amount *= critDmg;
            isCrit = true;
            if (lifeSteal > 0) dragonHP = Math.min(dragonMaxHP, dragonHP + lifeSteal);
        }
        
        if (!isDoT && chainLightningChance > 0 && Math.random() < chainLightningChance) {
             let neighbor = enemies.find(e => e !== this && Math.hypot(e.x-this.x, e.y-this.y) < 300);
             if (neighbor) {
                 ctx.strokeStyle = "#00ffff"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(neighbor.x, neighbor.y); ctx.stroke();
                 neighbor.takeDamage(amount * 0.5);
             }
        }

        this.hp -= amount;
        
        if (executeThreshold > 0 && this.hp < this.maxHp * executeThreshold && !this.isBoss) {
            this.hp = -1;
            damageNumbers.push(new FloatingText(this.x, this.y, "EXECUTE", "#ff0000", 30));
        }

        if (!isDoT || frame % 10 === 0) {
            let color = isCrit ? "#ffcc00" : (this.eliteMod ? "#ff00ff" : "#fff");
            let size = isCrit ? 24 : 14;
            if (isDoT) color = "#00ff00"; // Green text for DoT
            if (amount > 1) damageNumbers.push(new FloatingText(this.x, this.y, Math.floor(amount), color, size));
        }
        
        if (this.type === 'spore' && this.hp <= 0) {
            // Visual Gas Cloud
             ctx.fillStyle="rgba(0,255,0,0.5)"; ctx.beginPath(); ctx.arc(this.x,this.y, 60, 0, Math.PI*2); ctx.fill();
        }
    }

    draw() {
        if (this.x < -200 || this.x > width+200 || this.y < -200 || this.y > height+200) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(G_SCALE, G_SCALE); 

        // HP Bar
        const barW = this.isBoss ? 100 : 40;
        if (!this.isBoss) { 
            ctx.fillStyle = "red"; ctx.fillRect(-barW/2, -this.radius/G_SCALE - 15, barW, 4);
            ctx.fillStyle = "#0f0"; ctx.fillRect(-barW/2, -this.radius/G_SCALE - 15, barW * (Math.max(0, this.hp)/this.maxHp), 4);
        }
        
        // Elite Halo
        if (this.eliteMod) {
            ctx.strokeStyle = "#ff00ff"; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0,0,this.radius/G_SCALE + 5, 0, Math.PI*2); ctx.stroke();
        }

        ctx.rotate(this.angle);
        
        // VISUAL FEEDBACK FOR DOTS
        if (this.poisonTimer > 0) ctx.fillStyle = "#00ff00"; // Poison Green
        else if (this.isBurned) ctx.fillStyle = "#ffaa00"; // Burn Orange
        else ctx.fillStyle = this.eliteMod ? "#ffccff" : this.col;
        
        if (this.shape === 'tri') {
            ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(-10, 10); ctx.lineTo(-10, -10); ctx.fill();
        } else if (this.shape === 'square' || this.shape === 'block') {
            ctx.fillRect(-20, -20, 40, 40);
        } else if (this.shape === 'star') {
             ctx.beginPath(); for(let i=0;i<5;i++) { ctx.lineTo(Math.cos(i*Math.PI*2/5)*20, Math.sin(i*Math.PI*2/5)*20); } ctx.fill();
        } else if (this.isBoss) {
            ctx.beginPath(); for(let i=0; i<8; i++) { ctx.rotate(Math.PI/4); ctx.rect(-40, -40, 80, 80); } ctx.fill();
            ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(0,0,30,0,Math.PI*2); ctx.fill();
        } else {
            ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }
}

class Projectile {
    constructor(x, y, angle, speed) {
        this.x = x; this.y = y; 
        this.vx = Math.cos(angle)*speed; this.vy = Math.sin(angle)*speed;
        this.pen = orbStats.pen;
        this.dmg = 40 * dragonAtk * orbStats.damageMult;
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            if (Math.hypot(this.x - e.x, this.y - e.y) < e.radius + (15 * G_SCALE)) {
                e.takeDamage(this.dmg);
                this.pen--;
                ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(this.x,this.y, 5, 0, Math.PI*2); ctx.fill();
                if (this.pen <= 0) return true;
            }
        }
        return (this.x < -100 || this.x > width+100 || this.y < -100 || this.y > height+100);
    }
    draw() {
        ctx.fillStyle = COLORS.glow; ctx.shadowBlur = 10; ctx.shadowColor = COLORS.glow;
        ctx.beginPath(); ctx.arc(this.x, this.y, orbStats.size, 0, Math.PI*2); ctx.fill();
    }
}

// --- CORE LOGIC ---
function takeDamage(amount) {
    if (Math.random() < dodgeChance) {
        damageNumbers.push(new FloatingText(spine[0].x, spine[0].y, "DODGE", "#00ffcc", 20));
        return; 
    }
    
    amount *= dmgTakenMult;
    if (hasBloodLust) amount *= 1.3;
    let mitigation = Math.min(CAP_DEF, dragonDefPct);
    amount *= (1 - mitigation);
    
    if (dragonShield > 0) {
        if (dragonShield >= amount) { dragonShield -= amount; amount = 0; } 
        else { amount -= dragonShield; dragonShield = 0; }
        shieldCooldown = 180;
    }
    
    if (amount > 0) {
        dragonHP -= amount;
        ctx.fillStyle = "rgba(255,0,0,0.3)"; ctx.fillRect(0,0,width,height); 
        
        if (dragonHP <= 0 && reviveCount > 0) {
            reviveCount--;
            dragonHP = dragonMaxHP * 0.5;
            enemies.forEach(e => {
                let d = Math.hypot(spine[0].x - e.x, spine[0].y - e.y);
                if (d < 500) e.x += (e.x - spine[0].x) * 2; 
            });
            damageNumbers.push(new FloatingText(spine[0].x, spine[0].y, "REVIVED!", "#ffff00", 50));
            gameActive = true;
        }
    }
}

function checkLaserHit(enemy, head, count, angleOffset) {
    const spread = 0.15;
    const totalSpread = spread * (count - 1);
    const startAngle = (head.angle + angleOffset) - (totalSpread / 2);
    const range = Math.hypot(width, height) * 1.5; 
    const laserPhysWidth = (20 * VISUAL_SCALE * laserWidthBase) + enemy.radius;
    for(let i=0; i<count; i++) {
        const beamAngle = startAngle + (i * spread);
        const p1 = { x: head.x, y: head.y };
        const p2 = { x: head.x + Math.cos(beamAngle) * range, y: head.y + Math.sin(beamAngle) * range };
        const l2 = (p1.x - p2.x)**2 + (p1.y - p2.y)**2;
        let t = ((enemy.x - p1.x) * (p2.x - p1.x) + (enemy.y - p1.y) * (p2.y - p1.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        const distSq = (enemy.x - (p1.x + t * (p2.x - p1.x)))**2 + (enemy.y - (p1.y + t * (p2.y - p1.y)))**2;
        if (distSq < laserPhysWidth * laserPhysWidth) {
            let mult = 1.0;
            if (hasBloodLust) {
                let missingPct = (dragonMaxHP - dragonHP) / dragonMaxHP;
                mult += (missingPct * 100) * 0.015; 
            }
            if (laserType === 'void') mult += 0.01; 
            
            // Apply Penalty Multiplier
            let dmg = 6 * dragonAtk * mult * laserDmgMult;
            if (laserType === 'shotgun') dmg *= 2; 

            enemy.takeDamage(dmg);
            
            if (poisonDmg > 0) enemy.poisonTimer = 300; // Poison lasts 5s
            if (unlockedHoming) { /* Visual only for now, logic simplified */ }
            if (ghostForm && Math.random() < 0.1) enemy.takeDamage(dmg); // Ghost echo hit
            break; 
        }
    }
}

function levelUp() {
    isPaused = true;
    exp -= expNext;
    expNext = Math.floor(expNext * 1.2) + 500; 
    level++;
    healPct(0.3); 
    
    upgradeChoices = [];
    let pool = UPGRADES.filter(u => !u.req || u.req());
    const weights = [60, 25, 10, 4, 1, 0.1]; 
    while(upgradeChoices.length < 3 && pool.length > 0) {
        let rRoll = Math.random() * 100;
        let selectedRarity = 0;
        let cumulative = 0;
        for(let i=0; i<weights.length; i++) {
            cumulative += weights[i];
            if (rRoll <= cumulative) { selectedRarity = i; break; }
        }
        let rarityPool = pool.filter(u => u.r === selectedRarity);
        if (rarityPool.length === 0) rarityPool = pool; 
        let idx = Math.floor(Math.random() * rarityPool.length);
        let choice = rarityPool[idx];
        if (!upgradeChoices.includes(choice)) { upgradeChoices.push(choice); }
    }
    
    const cardW = 300 * G_SCALE * 1.5;
    const cardH = 400 * G_SCALE * 1.5; 
    const gap = 40 * G_SCALE;
    const totalW = (cardW * 3) + (gap * 2);
    const startX = (width - totalW) / 2;
    cardBounds = upgradeChoices.map((_, i) => ({
        x: startX + i * (cardW + gap), 
        y: height/2 - (200 * G_SCALE), 
        w: cardW, 
        h: cardH
    }));
}

function selectUpgrade(index) {
    upgradeChoices[index].run();
    isPaused = false;
}

function spawnWave() {
    wave++;
    const count = 10 + Math.floor(wave * 2.5);
    const types = [];
    
    if (wave <= 5) types.push('swarmer', 'fly', 'mite', 'spore');
    if (wave > 5) types.push('drone', 'swarmer', 'wasp');
    if (wave > 8) types.push('grunt', 'shielded', 'lancer');
    if (wave > 12) types.push('shooter', 'sniper', 'hunter');
    if (wave > 15) types.push('zealot', 'dasher', 'webber');
    if (wave > 20) types.push('tank', 'healer', 'summoner', 'phantom');
    if (wave > 25) types.push('glitch', 'tank', 'engineer');
    if (wave > 30) types.push('golem', 'monolith');
    if (wave > 40) types.push('mini_slayer', 'boss_ufo'); 

    if (wave % 5 === 0) {
        let bossType = 'mini_slayer';
        if (wave === 10) bossType = 'boss_hydra'; 
        else if (wave === 20) bossType = 'boss_titan';
        else if (wave === 30) bossType = 'boss_ufo';
        else if (wave === 40) bossType = 'mini_mecha';
        else if (wave >= 50 && wave % 10 === 0) bossType = 'boss_giga'; 
        enemies.push(new Enemy(bossType, wave));
    }
    
    for (let i=0; i<count; i++) {
        let t = types[Math.floor(Math.random() * types.length)];
        enemies.push(new Enemy(t, wave));
    }
}

// --- VISUALS ---
function drawLaserFan(head, count, angleOffset, colorOverride) {
    const spread = 0.15;
    const totalSpread = spread * (count - 1);
    const startAngle = (head.angle + angleOffset) - (totalSpread / 2);
    ctx.shadowBlur = furyActive ? 50 : 35; 
    ctx.shadowColor = furyActive ? COLORS.fury : (laserType === 'plasma' ? COLORS.plasma : COLORS.laser);
    ctx.strokeStyle = colorOverride || (furyActive ? COLORS.fury : (laserType === 'plasma' ? COLORS.plasma : COLORS.laser));
    ctx.lineWidth = 10 * VISUAL_SCALE * laserWidthBase;

    for(let i=0; i<count; i++) {
        const a = startAngle + (i * spread);
        const startX = head.x + Math.cos(a)*45*VISUAL_SCALE;
        const startY = head.y + Math.sin(a)*45*VISUAL_SCALE;
        const range = Math.max(width, height) * 1.5;
        ctx.beginPath();
        ctx.moveTo(startX, startY); ctx.lineTo(startX+Math.cos(a)*range, startY+Math.sin(a)*range); ctx.stroke();
    }
}

function drawLasers(head) {
    if (!mouse.down && autoTurretCount === 0) return;
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    if (mouse.down) {
        drawLaserFan(head, laserCount, 0);
        if(laserRear > 0) drawLaserFan(head, laserRear, Math.PI); 
        if(laserSide > 0) {
            drawLaserFan(head, laserSide, Math.PI/2);
            drawLaserFan(head, laserSide, -Math.PI/2);
        }
    }
    if (autoTurretCount > 0) {
        let nearest = null; let minD = Infinity;
        enemies.forEach(e => {
            let d = Math.hypot(e.x - head.x, e.y - head.y);
            if(d < minD) { minD = d; nearest = e; }
        });
        if (nearest && minD < 600 * G_SCALE) {
            ctx.shadowBlur = 10; ctx.strokeStyle = "#ff00ff"; ctx.lineWidth = 5 * VISUAL_SCALE;
            ctx.beginPath(); ctx.moveTo(head.x, head.y); ctx.lineTo(nearest.x, nearest.y); ctx.stroke();
        }
    }
    ctx.restore();
}

function drawShockwave(spine) {
    if(!shockwaveEnabled) return;
    if(shockwaveActiveFrame > 0) {
        const center = spine[Math.floor(spine.length/2)];
        ctx.save();
        ctx.strokeStyle = COLORS.shockwave;
        ctx.lineWidth = 5 + (shockwaveActiveFrame);
        ctx.globalAlpha = shockwaveActiveFrame / 10;
        ctx.beginPath(); ctx.arc(center.x, center.y, shockwaveRange, 0, Math.PI*2); ctx.stroke();
        ctx.fillStyle = "rgba(255, 255, 0, 0.2)"; ctx.fill();
        ctx.restore();
        shockwaveActiveFrame--;
    }
}

function drawShield(head) {
    if(dragonShield > 0) {
        ctx.save();
        ctx.strokeStyle = COLORS.shield;
        ctx.lineWidth = 3;
        ctx.shadowBlur = 10; ctx.shadowColor = "cyan";
        ctx.beginPath(); ctx.arc(head.x, head.y, 60 * VISUAL_SCALE, 0, Math.PI*2); ctx.stroke();
        ctx.globalAlpha = 0.1; ctx.fillStyle = COLORS.shield; ctx.fill();
        ctx.restore();
    }
}

function drawDragonBone(x1, y1, x2, y2, thickness, isWing = false) {
    const dist = Math.hypot(x2 - x1, y2 - y1);
    const angle = Math.atan2(y2 - y1, x2 - x1);
    ctx.save();
    ctx.translate(x1, y1); ctx.rotate(angle);
    ctx.fillStyle = isWing ? "rgba(0, 150, 255, 0.25)" : (furyActive ? "#330000" : COLORS.bone);
    ctx.strokeStyle = furyActive ? "#ff3300" : COLORS.accent;
    ctx.shadowBlur = furyActive ? 15 : 0; ctx.shadowColor = "red";
    
    ctx.beginPath(); ctx.moveTo(0, -thickness * 0.7);
    ctx.quadraticCurveTo(dist / 2, -thickness * 0.2, dist, -thickness * 0.7);
    ctx.lineTo(dist, thickness * 0.7);
    ctx.quadraticCurveTo(dist / 2, thickness * 0.2, 0, thickness * 0.7);
    ctx.fill(); ctx.stroke();
    ctx.restore();
}

function drawWings(anchor) {
    const flap = Math.sin(frame * CONFIG.wingFlapSpeed);
    const drawSide = (isLeft) => {
        let side = isLeft ? -1 : 1;
        let a1 = anchor.angle + (side * 1.5) + (flap * 0.2 * side);
        let armLen = CONFIG.wingSpan * 0.35;
        let j1X = anchor.x + Math.cos(a1) * armLen, j1Y = anchor.y + Math.sin(a1) * armLen;
        let a2 = a1 + (0.6 * side) + (flap * 0.1 * side);
        let foreLen = CONFIG.wingSpan * 0.45;
        let j2X = j1X + Math.cos(a2) * foreLen, j2Y = j1Y + Math.sin(a2) * foreLen;
        let fingerPoints = [];
        for (let i = 0; i < 4; i++) {
            let fA = a2 + (0.4 + i * 0.5) * side + (flap * 0.05);
            let fLen = CONFIG.wingSpan * (0.9 - i * 0.15);
            fingerPoints.push({ x: j2X + Math.cos(fA) * fLen, y: j2Y + Math.sin(fA) * fLen });
        }
        ctx.fillStyle = furyActive ? "rgba(255, 0, 0, 0.15)" : "rgba(0, 120, 255, 0.15)";
        ctx.beginPath(); ctx.moveTo(anchor.x, anchor.y); ctx.lineTo(j1X, j1Y); ctx.lineTo(j2X, j2Y);
        fingerPoints.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.fill();
        drawDragonBone(anchor.x, anchor.y, j1X, j1Y, 9 * VISUAL_SCALE, true);
        drawDragonBone(j1X, j1Y, j2X, j2Y, 7 * VISUAL_SCALE, true);
        fingerPoints.forEach(p => drawDragonBone(j2X, j2Y, p.x, p.y, 3 * VISUAL_SCALE, true));
    };
    drawSide(true); drawSide(false);
}

function drawDragonHead(s) {
    ctx.save();
    ctx.translate(s.x, s.y); ctx.rotate(s.angle); ctx.scale(VISUAL_SCALE, VISUAL_SCALE);
    ctx.fillStyle = furyActive ? "#330000" : COLORS.bone; 
    ctx.strokeStyle = furyActive ? "#ff0000" : COLORS.accent;
    const drawHorn = (side) => {
        ctx.save(); ctx.beginPath(); ctx.moveTo(-12, side * 8);
        ctx.quadraticCurveTo(-35, side * 40, -75, side * 35);
        ctx.lineTo(-72, side * 34); ctx.quadraticCurveTo(-32, side * 32, -18, side * 12);
        ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();
    };
    drawHorn(1); drawHorn(-1);
    ctx.beginPath(); ctx.moveTo(-20, -12); ctx.lineTo(12, -18); ctx.lineTo(48, -4);
    ctx.lineTo(50, 0); ctx.lineTo(48, 4); ctx.lineTo(12, 18); ctx.lineTo(-20, 12);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle = furyActive ? "#ff0000" : COLORS.glow; 
    ctx.shadowBlur = 15; ctx.shadowColor = ctx.fillStyle;
    ctx.beginPath();
    ctx.arc(15, -8, 4, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(15, 8, 4, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
}

function drawUI() {
    canvas.style.cursor = isPaused ? "default" : "none";
    ctx.fillStyle = "#111"; ctx.fillRect(0, 0, width, 10);
    ctx.fillStyle = COLORS.glow; ctx.fillRect(0, 0, width * (exp/expNext), 10);
    
    ctx.textAlign = "left";
    ctx.fillStyle = "white";
    ctx.font = `bold ${16 * G_SCALE * 1.5}px monospace`;
    ctx.fillText(`LVL ${level} | WAVE ${wave}`, 20, 35);
    ctx.fillText(`ATK ${dragonAtk.toFixed(1)} | DEF ${(dragonDefPct*100).toFixed(0)}%`, 20, 55);
    
    if (furyEnabled) {
        ctx.fillText(`FURY`, 20, 80);
        ctx.fillStyle = "#330000"; ctx.fillRect(70, 68, 100, 12);
        ctx.fillStyle = furyActive ? "#ffff00" : "#ff0000"; ctx.fillRect(70, 68, furyMeter, 12);
        ctx.strokeRect(70, 68, 100, 12);
    }
    
    if (reviveCount > 0) ctx.fillText(`REVIVES: ${reviveCount}`, 20, 105);

    let bosses = enemies.filter(e => e.isBoss);
    if (bosses.length > 0) {
        let boss = bosses[0];
        let bw = 600 * G_SCALE; let bh = 20; let bx = width/2 - bw/2;
        ctx.fillStyle = "#330000"; ctx.fillRect(bx, 50, bw, bh);
        ctx.fillStyle = boss.type.includes('mini') ? "#aa00aa" : "#ff0000"; ctx.fillRect(bx, 50, bw * (Math.max(0,boss.hp)/boss.maxHp), bh);
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.strokeRect(bx, 50, bw, bh);
        ctx.fillStyle = "#fff"; ctx.textAlign = "center";
        ctx.fillText(boss.type.toUpperCase(), width/2, 45);
    }

    const barW = 400 * G_SCALE * 1.5;
    const bx = width/2 - barW/2;
    ctx.fillStyle = "#222"; ctx.fillRect(bx, height - 30, barW, 20);
    const hpPct = Math.min(1, Math.max(0, dragonHP/dragonMaxHP)); 
    ctx.fillStyle = hpPct > 0.3 ? (furyActive ? "#ffaa00" : "lime") : "red";
    ctx.fillRect(bx, height - 30, barW * hpPct, 20);
    ctx.strokeStyle = "#fff"; ctx.strokeRect(bx, height-30, barW, 20);
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center"; ctx.fillText(`${Math.floor(dragonHP)}/${Math.floor(dragonMaxHP)}`, width/2, height - 15);
    
    if (dragonShield > 0) {
        const shPct = Math.min(1, dragonShield / dragonMaxShield);
        ctx.fillStyle = "cyan"; ctx.fillRect(bx, height - 35, barW * shPct, 5);
    }

    if (isPaused) {
        ctx.fillStyle = "rgba(0,0,0,0.85)"; ctx.fillRect(0,0,width,height);
        ctx.textAlign = "center"; 
        ctx.fillStyle = COLORS.glow; ctx.font = "bold 40px monospace";
        ctx.shadowBlur = 20; ctx.shadowColor = COLORS.glow;
        ctx.fillText("EVOLUTION", width/2, height/2 - 250);
        ctx.shadowBlur = 0;
        
        upgradeChoices.forEach((c, i) => {
            const b = cardBounds[i];
            let rColor = COLORS.common;
            if(c.r===1) rColor=COLORS.rare; if(c.r===2) rColor=COLORS.epic;
            if(c.r===3) rColor=COLORS.legendary; if(c.r===4) rColor=COLORS.cursed;
            if(c.r===5) rColor=COLORS.mythic;

            ctx.fillStyle = "#050a14"; ctx.fillRect(b.x, b.y, b.w, b.h);
            ctx.strokeStyle = rColor; ctx.lineWidth = 4; ctx.strokeRect(b.x, b.y, b.w, b.h);
            
            let grad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.h);
            grad.addColorStop(0, rColor); grad.addColorStop(1, "transparent");
            ctx.fillStyle = grad; ctx.globalAlpha = 0.2; ctx.fillRect(b.x, b.y, b.w, b.h);
            ctx.globalAlpha = 1.0;

            ctx.fillStyle = rColor; ctx.font = `bold ${22 * G_SCALE * 1.5}px monospace`; 
            ctx.fillText(c.name, b.x + b.w/2, b.y + 60);
            
            let rText = ["COMMON", "RARE", "EPIC", "LEGENDARY", "CURSED", "MYTHIC"][c.r];
            ctx.font = `bold 14px monospace`; ctx.fillText(rText, b.x + b.w/2, b.y + 85);

            ctx.fillStyle = "white"; ctx.font = `${16 * G_SCALE * 1.5}px monospace`;
            wrapText(ctx, c.desc, b.x + b.w/2, b.y + 140, b.w - 40, 24);
            
            ctx.fillStyle = rColor;
            ctx.font = `bold ${18 * G_SCALE * 1.5}px monospace`;
            ctx.fillText("[ CLICK TO SELECT ]", b.x + b.w/2, b.y + b.h - 40);
        });
    }
}

function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    let words = text.split(' ');
    let line = '';
    for(let n = 0; n < words.length; n++) {
        let testLine = line + words[n] + ' ';
        let metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && n > 0) {
            ctx.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
        } else { line = testLine; }
    }
    ctx.fillText(line, x, y);
}

// --- MAIN LOOP ---
function update() {
    if (!gameActive || isPaused) return;
    frame++;
    if (enemies.length === 0) spawnWave();

    // 1. Player Update (Moved BEFORE Time Stop check)
    let head = spine[0];
    let speed = mouse.down ? CONFIG.headSpeed * 0.15 : CONFIG.headSpeed;
    if (furyActive) speed *= 1.5;
    head.x += (mouse.x - head.x) * speed;
    head.y += (mouse.y - head.y) * speed;
    head.angle = Math.atan2(mouse.y - head.y, mouse.x - head.x);

    for (let i=1; i<spine.length; i++) {
        let p = spine[i-1], c = spine[i];
        let a = Math.atan2(p.y - c.y, p.x - c.x);
        c.angle = a; c.x = p.x - Math.cos(a)*CONFIG.segmentDist;
        c.y = p.y - Math.sin(a)*CONFIG.segmentDist;
    }
    legs.forEach(leg => {
        let body = spine[leg.anchorIndex], side = leg.isLeft ? -1.6 : 1.6;
        let iX = body.x + Math.cos(body.angle + side) * (115 * VISUAL_SCALE), iY = body.y + Math.sin(body.angle + side) * (115 * VISUAL_SCALE);
        if (!leg.isStepping && Math.hypot(iX - leg.x, iY - leg.y) > 95 * VISUAL_SCALE) {
            leg.isStepping = true; leg.stepProgress = 0; leg.stepStartX = leg.x; leg.stepStartY = leg.y;
            leg.targetX = iX + Math.cos(body.angle) * (70 * VISUAL_SCALE); leg.targetY = iY + Math.sin(body.angle) * (70 * VISUAL_SCALE);
        }
        if (leg.isStepping) {
            leg.stepProgress += CONFIG.legSpeed;
            if (leg.stepProgress >= 1) { leg.isStepping = false; leg.x = leg.targetX; leg.y = leg.targetY; }
            else {
                let t = leg.stepProgress;
                leg.x = leg.stepStartX + (leg.targetX - leg.stepStartX) * t; leg.y = leg.stepStartY + (leg.targetY - leg.stepStartY) * t;
                leg.lift = Math.sin(t * Math.PI) * (45 * VISUAL_SCALE);
            }
        }
    });

    if(frame % 60 === 0) {
        if(dragonHP < dragonMaxHP && dragonRegen > 0) dragonHP = Math.min(dragonMaxHP, dragonHP + dragonRegen * 60);
        if(shieldCooldown > 0) shieldCooldown--;
        else if(dragonShield < dragonMaxShield) dragonShield += dragonShieldRegen * 60;
    }
    
    if (furyEnabled && furyMeter >= 100 && !furyActive) {
        furyActive = true; furyTimer = furyDuration; shockwaveEnabled = true; 
    }
    if (furyActive) {
        furyTimer--; furyMeter = (furyTimer / furyDuration) * 100;
        if (furyTimer <= 0) { furyActive = false; furyMeter = 0; }
    }

    // 2. Time Stop Check
    if (timeStopActive) {
        timeStopTimer--;
        if (timeStopTimer <= 0) timeStopActive = false;
        else return; // Stop Enemy/Projectile Updates
    }

    if (timeStopChance > 0 && !timeStopActive && frame % 600 === 0 && Math.random() < timeStopChance) {
        timeStopActive = true; timeStopTimer = 120;
    }

    // 3. Enemy / Projectile / World Update
    if(shockwaveEnabled) {
        shockwaveTimer++;
        if(shockwaveTimer > (furyActive ? 30 : shockwaveInterval)) { 
            shockwaveTimer = 0; shockwaveActiveFrame = 15;
            const center = spine[Math.floor(spine.length/2)];
            enemies.forEach(e => {
                let d = Math.hypot(center.x - e.x, center.y - e.y);
                if(d < shockwaveRange) {
                    e.takeDamage(shockwaveDmg * dragonAtk);
                    let a = Math.atan2(e.y - center.y, e.x - center.x);
                    let push = 150 * G_SCALE * knockbackStr;
                    e.x += Math.cos(a) * push; e.y += Math.sin(a) * push;
                }
            });
        }
    }
    
    if (mouse.down && orbLevel > 0) {
        const fireRate = Math.max(5, 20 - (orbLevel * 2));
        if (frame % fireRate === 0) {
            projectiles.push(new Projectile(head.x, head.y, head.angle, orbStats.speed));
            if (orbLevel >= 3) { 
                projectiles.push(new Projectile(head.x, head.y, head.angle + 0.3, orbStats.speed));
                projectiles.push(new Projectile(head.x, head.y, head.angle - 0.3, orbStats.speed));
            }
        }
    }
    
    if (unlockedMissiles && frame % 60 === 0) {
        for(let m=0; m<missileCount; m++) summons.push(new Missile(head.x, head.y));
    }
    if (unlockedMines && frame % 120 === 0) {
        summons.push(new Mine(head.x, head.y));
    }
    
    // Static Discharge logic
    if (unlockedStatic && frame % 30 === 0) {
        let nearest = enemies[0];
        let minD = Infinity;
        enemies.forEach(e => {
            let d = Math.hypot(e.x - head.x, e.y - head.y);
            if(d < minD) { minD = d; nearest = e; }
        });
        if (nearest && minD < 300 * G_SCALE) {
             nearest.takeDamage(20 * dragonAtk);
             ctx.strokeStyle = "#ffff00"; ctx.beginPath(); ctx.moveTo(head.x, head.y); ctx.lineTo(nearest.x, nearest.y); ctx.stroke();
        }
    }

    if (!mouse.down && dragonHP < dragonMaxHP && frame % 60 === 0) {
        dragonHP = Math.min(dragonMaxHP, dragonHP + 5);
    }
    
    enemies.forEach((e, i) => {
        e.update();
        if (e.hp <= 0) { 
            score += 10; 
            gems.push(new ExpGem(e.x, e.y, e.xp)); 
            if(furyEnabled && !furyActive) furyMeter = Math.min(100, furyMeter + (e.isBoss ? 20 : 2));
            enemies.splice(i, 1); 
        }
    });
    
    damageNumbers = damageNumbers.filter(d => d.update());
    gems = gems.filter(g => !g.update());
    projectiles = projectiles.filter(p => !p.update());
    enemyProjectiles = enemyProjectiles.filter(p => !p.update());
    summons = summons.filter(s => !s.update());
    
    if (dragonHP <= 0) gameActive = false;
}

function draw() {
    ctx.fillStyle = timeStopActive ? "#111122" : "#00020a"; ctx.fillRect(0, 0, width, height);
    
    drawLasers(spine[0]);
    drawShockwave(spine);
    if (reactorDmg > 0) {
        ctx.beginPath(); ctx.arc(spine[0].x, spine[0].y, 200 * VISUAL_SCALE * reactorRadiusMult, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(255, 100, 0, 0.1)"; ctx.stroke();
    }
    if (auraIceSlow > 0) {
        ctx.beginPath(); ctx.arc(spine[0].x, spine[0].y, 300 * VISUAL_SCALE, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(0, 255, 255, 0.1)"; ctx.stroke();
    }

    gems.forEach(g => g.draw());
    summons.forEach(s => s.draw());
    projectiles.forEach(p => p.draw());
    enemyProjectiles.forEach(p => p.draw());
    enemies.forEach(e => e.draw());
    damageNumbers.forEach(d => d.draw());
    
    ctx.strokeStyle = COLORS.accent; ctx.lineWidth = 1;
    drawWings(spine[CONFIG.wingAttachment]);
    spine.forEach((s, i) => {
        let ribStart = 10, ribEnd = 50, ribSpan = ribEnd - ribStart;
        let ribW = (i > ribStart && i < ribEnd) ? Math.sin((i-ribStart)/ribSpan*Math.PI)*CONFIG.maxRibWidth : 0;
        if (ribW > 0) {
            let p = s.angle + Math.PI/2;
            ctx.beginPath(); ctx.moveTo(s.x + Math.cos(p)*ribW, s.y + Math.sin(p)*ribW);
            ctx.quadraticCurveTo(s.x - Math.cos(s.angle)*15*VISUAL_SCALE, s.y - Math.sin(s.angle)*15*VISUAL_SCALE, s.x - Math.cos(p)*ribW, s.y - Math.sin(p)*ribW);
            ctx.stroke();
        }
        if (i > 0) {
            ctx.lineWidth = i < 40 ? 5 * VISUAL_SCALE : 2 * VISUAL_SCALE;
            ctx.strokeStyle = furyActive ? "#ff3300" : COLORS.accent;
            ctx.beginPath(); ctx.moveTo(spine[i - 1].x, spine[i - 1].y); ctx.lineTo(s.x, s.y); ctx.stroke();
        }
    });
    drawShield(spine[0]); 
    
    legs.forEach(leg => {
        let body = spine[leg.anchorIndex], hSide = leg.isLeft ? -1.5 : 1.5;
        let hX = body.x + Math.cos(body.angle + hSide) * (25 * VISUAL_SCALE), hY = body.y + Math.sin(body.angle + hSide) * (25 * VISUAL_SCALE);
        let dx = leg.x - hX, dy = (leg.y - leg.lift) - hY;
        let dist = Math.min(Math.sqrt(dx * dx + dy * dy), CONFIG.upperLegLen + CONFIG.lowerLegLen - 2);
        let a = Math.atan2(dy, dx), cos = (CONFIG.upperLegLen**2 + dist**2 - CONFIG.lowerLegLen**2) / (2 * CONFIG.upperLegLen * dist);
        let kneeA = leg.isLeft ? a + Math.acos(Math.max(-1, Math.min(1, cos))) : a - Math.acos(Math.max(-1, Math.min(1, cos)));
        let kX = hX + Math.cos(kneeA) * CONFIG.upperLegLen, kY = hY + Math.sin(kneeA) * CONFIG.upperLegLen;
        drawDragonBone(hX, hY, kX, kY, 8 * VISUAL_SCALE); drawDragonBone(kX, kY, leg.x, leg.y - leg.lift, 6 * VISUAL_SCALE);
    });
    drawDragonHead(spine[0]);
    
    drawUI();
    
    if (!gameActive) {
        ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(0,0,width,height);
        ctx.fillStyle = "white";
        ctx.textAlign = "center"; ctx.font = "50px monospace";
        ctx.fillText("GAME OVER", width/2, height/2);
        ctx.font = "20px monospace";
        ctx.fillText(`Max Level: ${level} | Wave: ${wave}`, width/2, height/2 + 50);
        ctx.fillText("Refresh to restart", width/2, height/2 + 80);
    }
}

function init() {
    resize();
    spine = [];
    for (let i = 0; i < CONFIG.segmentCount; i++) spine.push({ x: mouse.x, y: mouse.y, angle: 0 });
    legs = [
        { anchorIndex: 18, isLeft: true, x: 0, y: 0 }, { anchorIndex: 18, isLeft: false, x: 0, y: 0 },
        { anchorIndex: 50, isLeft: true, x: 0, y: 0 }, { anchorIndex: 50, isLeft: false, x: 0, y: 0 }
    ];
    loop();
}

function resize() { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('mousedown', () => {
    if (isPaused) {
        cardBounds.forEach((b, i) => {
            if (mouse.x > b.x && mouse.x < b.x + b.w && mouse.y > b.y && mouse.y < b.y + b.h) {
                selectUpgrade(i);
            }
        });
    } else { mouse.down = true; }
});
window.addEventListener('mouseup', () => mouse.down = false);
function loop() { update(); draw(); requestAnimationFrame(loop); }
init();
